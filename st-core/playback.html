<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

        <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
		<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
		<!--[if lt IE 9]>
		<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
		<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
		<![endif]-->
        
        <style type="text/css">

            .logo {
                color: green;
                font-weight: bold;
                font-size: 200%;
                margin-bottom: 10px;
            }

            .titleDescriptionLink a {
                color: darkgreen;
                font-size: 140%;
            }

            #textCommentTextArea {
                height: auto;
                min-height: 150px;
            }

            #textCommentTextArea:empty:before {
                content: attr(data-text);
                color:gray;
            }

            .penTable .penColor {
                border-style: solid;
                border-color: gray;                
            }

            #bluePen {
                background-color: blue;
                width: 40px;
                height: 40px;
                padding-left: 10px;
            }

            #blackPen {
                background-color: black;
                width: 40px;
                height: 40px;
                padding-left: 10px;
            }

            #whitePen {
                background-color: white;
                width: 40px;
                height: 40px;
                padding-left: 10px;
            }
            
            #redPen {
                background-color: red;
                width: 40px;
                height: 40px;
                padding-left: 10px;
            }

            .penColorSelected {
                border-color: gray;
                border-style: solid; 
                border-width: 4px;
            }

            #extraLargePen {
                font-size: 250%;
            }

            #largePen {
                font-size: 200%;
            }

            #mediumPen {
                font-size: 150%;
            }

            #smallPen {
                font-size: 100%;
            }

            .penSizeSelected {
                border-color: gray;
                border-style: solid; 
                border-width: 4px;
            }
            /* for code in a playback (by default all italics- relevant code will be changed to normal) */
            .codeChar {
                font-style: italic;
            }

            /* to hide code characters that haven't been played yet */
            .codeNotVisible {
                display: none;
            }

            /* to gray out tabs that hold files that are not present */
            .playbackTabNotVisible {
                font-style: italic;
                color: gray;
                background-color: lightgray;
            }

            /* to hide deleted files/dirs */
            .deletedFileOrDirectoryNotVisible {
                display: none;
            }

            /* to highlight code that satisfies all of the filters */
            .relevantCode {
                color: green;
                font-style: normal; /* override the default italic */
                font-weight: bold;
            }
            
            /* used to indicate recent changes since the last play/pause cycle.
               Add a mark to the previous neighbor of a deleted character */
            .recentDelete {
                border-right-color: red;
                border-right-style: double;
            }

            /* used to indicate recent changes since the last play/pause cycle */
            .recentInsert {
                color: blue;
                /*font-style: italic;*/
            }
            
            /* used to highlight new inserts for a brief amount of time */
            .briefInsertHighlight {
                text-decoration: underline;
            }

            /* used to highlight new deletes for a brief amount of time */
            .briefDeleteHighlight {
                color: red;
                text-decoration: line-through;
                display: initial;
            }

            

            

            .recentFileChange::after {
                content: " *";
            }

            /* for a blinking cursor */
            @-webkit-keyframes blinkingCursor { 
                50% { border-right-color: transparent; border-right-width: 2px; border-right-style: solid; } 
            }
            @keyframes blinkingCursor { 
                50% { border-right-color: transparent; border-right-width: 2px; border-right-style: solid; } 
            }

            /* for displaying a cursor in the playback after an insert */
            .insertCaretCursor {
                border-right-color: green;
                border-right-width: 2px;
                border-right-style: solid; 
                
                animation: blinkingCursor .60s step-end infinite alternate;
                -webkit-animation: blinkingCursor .60s step-end infinite alternate;
            }
            
            /* for displaying a cursor in the playback after a delete */
            .deleteCaretCursor {
                border-right-color: red;
                border-right-width: 2px;
                border-right-style: solid; 
                
                animation: blinkingCursor .60s step-end infinite alternate;
                -webkit-animation: blinkingCursor .60s step-end infinite alternate;
            }

            /* to display the active file/dir in the playback */
            .activeFileOrDirectory {
                font-weight: bold;
                font-style: italic;
            }

            .activeCommentMarkerContainer {
                background-color:rgba(0, 120, 0, 1.0);
            }

            /* make this very close to the color of the slider to people can get a sense of where the comments are */
            .inactiveCommentMarkerContainer {
                background-color:rgba(0, 120, 0, 0.30);
            }

            .commentMarker {
                width: 2px;
                background-color: inherit;
                position: absolute;
                top: 0px;  
            }

            .hiddenUntilEditable {
                display: none;
            }

            #allCodeCommentsContainer {
                /*width: 50px;*/
                height: 600px;
                overflow-y: scroll;
                overflow-x:hidden;
            }

            #commentsReadProgress {
                text-align: right;
            }

            #commentsReadProgress.someUnreadComments {
                font-weight: normal;
                font-style: italic;
            }

            .someUnreadComments::before {
                content: "*";
            }
            
            .commentNumberUnread {
                font-style: italic;
                color: gray;
            }
            
            .commentNumberRead {
                font-style: normal;
                color: black;
            }

            .activeComment {
                border-color: green;
            }

            /* to highlight code that is linked to a comment */
            .commentRelevant {
                background-color: greenyellow;
            }

            .selectedCode {
                background-color: yellowgreen;            
            }
            ::selection {
                background: yellowgreen;
            }
            ::-moz-selection {
                background: yellowgreen;
            }

            .commentRelevant.selectedCode {
                background-color: darkseagreen;            
            }

            /* for code comment display (not in the code but off to the side) */
            .codeCommentText {
                /*background-color: greenyellow;*/
                /*font-weight: bold;*/
                border-width: 2px; 
            }

            /* timestamp in the comments */
            .codeCommentTimestamp {
                font-style: italic;
                /*display: block;*/
            }

            /* display of images */
            .selectableCommentImageTable {
                display: inline-table;
                margin: 3px;
            }
            
            .table {
                margin-bottom: 0px;
            }

            @keyframes recording-flashing {
                from {color: black;}
                to {color: red;}
            }

            .videoButtonRecording {
                animation-name: recording-flashing;
                animation-duration: 1.5s;
                animation-iteration-count: infinite;
            }

            .videoWindow {
                width: 100%;
                height: 100%;
            }
            
            .potentialVideoClip {
                padding-bottom: 2px;
                padding-top: 20px;
                padding-left: 20px;
                padding-right: 20px;
            } 

            /* to hide the last span element yet give it some space on the screen */
            .lastSpan {
                visibility: hidden;
            }

            /* current active line in a playback */
            .currentLine {
                font-weight: bold;
                background-color: #EBEBEB;
                font-size: 110%;
            }

            /* the main playback container. It holds a playback window and a line number gutter */
            #playbackWindows {
                min-height: 500px;
                overflow-y: scroll; /* for scrolling */
                height:500px;
                white-space: nowrap; /* for horizontal scrolling to prevent wrap */
                font-size: 18px;
                background-color: #C9DBA3;
                font-family: 'Courier New', Courier, monospace;
                resize: vertical;
            }

            /* for the main code window */
            .playbackWindow {
                font-style: italic;
            }

            /* the div that holds the gutter */
            .lineNumberGutter {
                counter-reset: lineNumCounter; /* set the line num counter to 0 */
                background-color: #DBDBDB; /* color of the gutter */
                float: left;
            }

            /* list of contents of a dir */
            .playbackViewFileOrDirList
            {
                list-style-type: none;
            }

            /* name of a dir */
            .playbackDirNameLabel {
                margin-left: 5px;
            }

            /* for hiding file/dir names in a playback */
            .hiddenFile {
                display: none;
            }
            .hiddenDirectory {
                display: none;
            }

            /* playback info */
            #playbackControlTD {
                width: 30%;
            }
            #eventInfoTD {
                width: 40%;
            }
            #eventDevInfo {
                width: 30%;
            }

            /* a line number in the gutter */
            .lineNum {
                padding-left: 10px;
                padding-right: 10px;
                text-align: right;
            }

            /* increment line numbers */
            .lineNum::before {
                counter-increment: lineNumCounter;
                content: counter(lineNumCounter);
            }

            /* a deleted file */
            .deletedFileOrDirectory {
                color: red;
                font-style: italic;
            }
            
            /* dir icon */
            .dirIcon {
                margin-right: 5px;
            }

            /* list of files/dirs in the filtering menu */
            .fileOrDirListForFiltering
            {
                list-style-type: none;
            }

            /* link to open a tab */
            .fileLink {
                color: black;
            }

            /* for the playback control slider */
            #progressBarContainer {
                margin-top: 3px;
                margin-bottom: 3px;
                position: relative;
            }

            /* all divs that hold tabs*/
            .tab-content {
                margin-top:5px
            }

            /* the div that is holding the tab structure */
            #tabContainer {
                margin-top:10px
            }

            /* event time and dev info */
            #timeAndDevEventInfo {
                margin: 5px;
            }

            /* image of a dev */
            .devImage {
                border-style: solid;
                border-width: 2px;
            }

            /* for making the file editor tablist move to the right */
            .nav-rtl {
                padding-left:40px;
                padding-right:0px;
            }
            .nav-rtl li {
                float:right;
            }

            #descriptionFormatControls {
                width: 25%;
            }

            .clickedForInsertBefore {
                background-color: white;
                border-left-color: darkgreen;
                border-left-style: solid;
                border-left-width: 3px;
            }
            .clickedForInsertAfter {
                background-color: white;
                border-right-color: darkgreen;
                border-right-style: solid;
                border-right-width: 3px;
            }
        </style>

		<title>Storyteller- Playback</title>
	</head>

	<body>        
		<!-- bootstrap container -->
		<div class="container-fluid">
			<div id="playbackContainer">
                <!-- playback title and description -->
                <div id="playbackTitleAccordion" role="tablist">
                    <div>
                        <div role="tab" id="playbackTitleLink">
                            <span class="logo">
                                Storyteller:
                            </span>   
                            <span class="titleDescriptionLink"> 
                            <a class="collapsed" role="button" data-toggle="collapse" data-parent="#playbackTitleAccordion" href="#playbackDescriptionPanel" aria-expanded="false" aria-controls="playbackDescriptionPanel">
                                <span id="playbackTitle"></span> <span class="caret"></span>
                            </a>
                            </span>
                        </div>

                        <div id="playbackDescriptionPanel" class="panel-collapse collapse" role="tabpanel" aria-labelledby="playbackTitleLink">
                            <div class="panel-body">
                                <fieldset>
                                    <legend>
                                        <div id="playbackTitleEditable" class="editablePlaybackTitleDescription storytellerEditable">
                                            
                                        </div>
                                    </legend>
                                    <div id="playbackDescriptionEditable" class="editablePlaybackTitleDescription storytellerEditable">
                                        
                                    </div>
                                    <hr/>
                                    <div id="descriptionFormatControls" class="hiddenUntilEditable descriptionFormatControls">
                                        <div class="collapse" id="descriptionFormatToolbar">
                                            
                                        </div>
                                        <a class="small" data-toggle="collapse" href="#descriptionFormatToolbar">
                                            Description Formatting Options
                                        </a>
                                    </div>
    
                                    <div class="pull-right">
                                        <a id="editPlaybackTitleDescriptionButton" class="btn btn-default btn-xs" href="#">Edit title/description</a>
                                    </div>
                                </fieldset>
                            </div>                                    
                        </div>
                    </div>
                </div>            

				<div class="row">     
                    <!-- playback comments 25% of screen -->
					<div class="col-md-3">
						<fieldset>
                            <!-- links for toggling between reading comments and making comments -->
							<legend>Comments</legend>
							<ul class="nav nav-tabs" role="tablist">
								<li id="addNewCommentListItem" class="active"><a href="#addNewCommentTab" data-toggle="tab">Add Comment</a></li>
								<li id="playbackCommentsListItem"><a href="#playbackCommentsTab" data-toggle="tab">Playback Comments</a></li>
							</ul>

							<!-- actual comment tabs -->
							<div class="tab-content">
								<div role="tabpanel" class="tab-pane fade in active" id="addNewCommentTab">
									<fieldset>
                                        <legend>Text for the Comment</legend>                                        
                                        <!-- a place to add comment text -->
                                        <div class="form-group">
                                            <div id="textCommentTextArea" contenteditable="true" class="form-control storytellerEditable" data-text="Add a comment at this point in the playback. Highlight some code if you'd like to link the comment to it.">
    
                                            </div>
                                        </div>
                                        <div>
                                            <div class="collapse" id="commentFormatToolbar">
                                            </div>
                                            <a class="small" data-toggle="collapse" href="#commentFormatToolbar">
                                                Comment Formatting Options
                                            </a>
                                        </div>
                                        </fieldset>
                                
                                    
                                    <filedset>
                                        <legend>Images for the Comment</legend>

                                        <!-- a place to see all of the comment images for the current comment -->
                                        <div id="commentImagesInComment"></div>

                                        <div class="form-group">
                                            <button type="button" data-toggle="modal" data-target="#editCommentPictureModal" class="btn btn-default">
                                                Add a picture 
                                            </button>
                                        </div>
                                    </filedset>
                                    

                                    <fieldset>
                                        <legend>Video for the Comment</legend>
                                        <!-- control to whether to allow video comments or not -->
                                        <div class="form-group">
                                            <div class="checkbox">
                                                <label>
                                                    <input type="checkbox" id="enableVideoCommentsCheckbox" name="enableVideo" value="0">
                                                    <span>Enable video comments</span>
                                                </label>
                                            </div>
                                        </div>
                                        <div id="previewVideoControls" class="form-group hiddenUntilEditable">
                                            <!-- video preview window -->
                                            <video id="previewVideoWindow" class="videoWindow" autoplay muted></video>

                                            <button id="addNewVideoComment" type="button" class="btn btn-default">
                                                Start Recording
                                            </button>
                                            <span id="videoRecordingStateIcon" class="">Not Recording</span>
                                        </div>

                                        <div id="videoCommentClips"></div>
                                    </fieldset>

                                    <!-- submit comment controls -->
									<div class="form-group">
										<button id="addCommentButton" type="button" class="btn btn-primary pull-right">
                                            Add Comment 
                                        </button>
									</div>
								</div>

                                <!-- tab to display comments from a playback -->
								<div role="tabpanel" class="tab-pane fade" id="playbackCommentsTab">
                                    <div id="commentsReadProgress" class="someUnreadComments">
                                    </div>
                                    <div id="allCodeCommentsContainer">
                                    --
									</div>
								</div>
							</div>
                            <br/>
                            <br/>
                            <div id="commentAlertArea">
                            </div>
						</fieldset>

                        <!-- the view of the file system at any point in a playback -->
						<fieldset>
							<legend>Current View of the File System</legend>
							
                            <!-- button to save the state of the playback at the current point -->
                            <div class="form-group">
                                <button id="saveStateModalButton" data-toggle="modal" data-target="#saveStateModal" class="btn btn-primary">
                                    Download Files at this Point 
                                </button>
                            </div>
                            
                            <!-- display of the files system at the current point in the playback -->
                            <ul id="playbackViewOfFileSystem" class="playbackViewFileOrDirList">
							</ul>
                        </fieldset>
					</div>                    
                    <!-- playback window 75% of screen -->                   
					<div class="col-md-9">
						<!-- tabs for the playback windows -->
						<!-- start with a group of clickable file names -->
						<ul id="playbackWindowTabLinks" class="nav nav-tabs nav-rtl">
                            <!--
							<li class="playbackWindowLinkListItem" id="playbackWindowLinkListItem-fileId">
								<a href="#playbackWindowTab-fileId" data-toggle="tab">file name</a>
							</li>
							-->
						</ul>

                        <!-- next the tabs -->
						<div id="playbackWindows" class="tab-content">

							<!-- All playback window tab ids will look like this "playbackWindowTab-fileId" 
								<div id="lineNumberGutter-fileId" class="lineNumberGutter">
									<div class='lineNum'></div>
								</div>

								<div id="playbackWindow-fileId" class="playbackWindow">
									<span id="firstSpan-fileId" class="firstSpan"></span>
									<span id="lastSpan-fileId" class="lastSpan">X</span>
								</div>
                            </div>	
                            -->						
						</div>

						<!-- this holds the controls for a code playback -->
						<div id="codeControl">

							<!-- this is where the playback slider (bootstrap progress bar) will go -->
							<div class="progress" id="progressBarContainer">

								<!-- adjustable part of the progress bar -->
								<div class="progress-bar progress-bar-success" role="progressbar" id="playbackProgressBar" style="width:0%"></div>
                                
                                <!-- used to show where comments are in the playback -->
                                <div id="commentMarkerContainer" class="activeCommentMarkerContainer">
                                </div>
							</div>
                            

							<!-- this is a table of playback controls and playback info -->
							<div>
								<table class="table table-bordered">
									<tr>
										<th>Playback Control</th>
										<th>Event Info</th>
										<th>Developer(s)</th>
									</tr>

									<tr>
                                        <!-- pause/play, step, and filter controls -->
										<td id="playbackControlTD">
                                            <div>
                                                <!-- step backward button -->
                                                <button id="stepBackwardToBeginningButton" class="btn btn-default"
                                                        data-toggle="tooltip" data-placement="bottom" title="Step backward to the previous comment (shift + left arrow)">
                                                    &lt;&lt;
                                                </button>

                                                <button id="stepBackwardButton" class="btn btn-default  btn-sm"
                                                        data-toggle="tooltip" data-placement="bottom" title="Step backward one step (left arrow)">
                                                    &lt;
                                                </button>
                                                
                                                <!-- play/pause button -->
                                                <button id="playPauseButton" class="btn btn-default btn-lg"
                                                        data-toggle="tooltip" data-placement="bottom" title="Play/Pause (space bar)">
                                                    Play
                                                </button>

                                                <!-- step forward button -->
                                                <button id="stepForwardButton" class="btn btn-default btn-sm"
                                                        data-toggle="tooltip" data-placement="bottom" title="Step forward one step (right arrow)">
                                                    &gt;
                                                </button>

                                                <button id="stepForwardToEndButton" class="btn btn-default"
                                                        data-toggle="tooltip" data-placement="bottom" title="Step forward to the next comment (shift + right arrow or double tap the playback window)">
                                                    <!-- image for the step forward button -->
                                                    &gt;&gt;
                                                </button>
                                            </div>
                                            <div class="pull-right">
                                                <!-- filter button -->
                                                <button id="playbackOptionsDropUp" data-toggle="modal" data-target="#filtersModal" class="btn btn-primary btn-lg pull-right">
                                                    Filters 
                                                </button>
                                            </div>
										</td>

                                        <!-- event info -->
										<td id="eventInfoTD">

                                            <div>Relevant Event count: <span id="relevantEventCountDiv"></span></div>
                                            <div>Total Event count: <span id="totalEventCountDiv"></span></div>
											<div>Event type: <span id="eventTypeDiv"></span></div>
											<div>Details: <span id="eventInfoDiv"></span></div >
											<div>Timestamp: <span id="timestampDiv"></span></div >
										</td>

                                        <!-- developer group info -->
										<td id="eventDevInfo"></td>
									</tr>                                    
								</table>

                                <div class="clearfix">
                                    <!-- options link at bottom of page -->
                                    <div class="pull-left">
                                        <a href="#editPlaybackCollapsable" data-toggle="collapse">Edit a Playback<span class="caret"></span></a>
                                    </div>
                                    <div class="pull-right">
                                        <a href="#" data-toggle="modal" data-target="#playbackOptionsModal">Options</a>
                                    </div>
                                </div>
                            </div>
                            <div class="collapse" id="editPlaybackCollapsable">
                                <fieldset>
                                    <legend>
                                        Editing a Playback in the Browser
                                    </legend>
                                    <p>
                                        Information about using Storyteller as a version control system can be found <a href="https://markm208.github.io/storyteller/versionControl.html" target="_blank">here</a>.
                                    </p>
                                    <p>
                                        Like with video, it is sometimes useful to edit a playback after the code has been written. You might have forgotten
                                        to add a semi-colon while writing the code and did not realize it until you saw a playback. Some light rewriting of 
                                        history is possible in a Storyteller playback. 
                                        Information about replacing, deleting, and editing code in the browser can be found <a href="https://markm208.github.io/storyteller/editPlayback.html" target="_blank">here</a>.
                                    </p>
                                    <ul class="nav nav-tabs" role="tablist">
                                        <li id="mergeEditListItem" class="active"><a href="#mergeEditTab" data-toggle="tab">Merge</a></li>
                                        <li id="replaceEditListItem"><a href="#replaceEditTab" data-toggle="tab">Replace Text</a></li>
                                        <li id="deleteEditListItem"><a href="#deleteEditTab" data-toggle="tab">Delete Text</a></li>
                                        <li id="insertEditListItem"><a href="#insertEditTab" data-toggle="tab">Insert Text</a></li>
                                    </ul>
        
                                    <!-- actual comment tabs -->
                                    <div class="tab-content">
                                        <div role="tabpanel" class="tab-pane fade in active" id="mergeEditTab">
                                            <ol>
                                                <li>
                                                    Create a new branch. Download a playback, unzip the contents of the file, and edit the code using Storyteller.
                                                </li>
                                                <li>
                                                    Download the playback.json file of the new branch. This will have the original state of the playback plus any edits you made in the editor. 
                                                </li>
                                                <li>
                                                    Continue editing the original code using Storyteller. You will now have two versions of the code that each shares some history. 
                                                </li>
                                                <li>
                                                    Upload the branch's playback.json file into this playback. The current playback will be updated with the data from both. 
                                                    Conflicts will be identified in the code and it is up to the a developer to download the playback and resolve those conflicts.
                                                    <br/>   
                                                    <!-- merge in a different history to this playback -->
                                                    <label class="btn btn-default btn-file">
                                                        Merge another branch's playback.data<input id="mergeButton" type="file" style="display: none;">
                                                    </label>                                                
                                                </li>
                                            </ol>
                                            <hr/>
                                        </div>    
                                        <div role="tabpanel" class="tab-pane fade in" id="replaceEditTab">
                                            <ol>
                                                <li>Select the code that you want to replace on the screen</li>
                                                <li>
                                                    Write the code that you want to replace the selected code with: <br/>
                                                    Text to insert:<br/>
                                                    <textarea id="replaceNewHistoryText" rows="7" cols="50" class="storytellerEditable"></textarea><br/>                                
                                                </li>
                                                <li>
                                                    Click the button below to replace it:<br/>
                                                    <button id="replaceOldHistoryButton" class="btn btn-default" onclick="replaceHistory()">Replace selected code</button><br/>
                                                </li>
                                            </ol>
                                            <hr/>
                                        </div>    
                                        <div role="tabpanel" class="tab-pane fade in" id="deleteEditTab">
                                            <ol>
                                                <li>Select the code that you want to delete on the screen</li>
                                                <li>
                                                    Click the button below to delete it:<br/>
                                                    <button id="deleteOldHistoryButton" class="btn btn-default" onclick="deleteHistory()">Delete selected code</button><br/>
                                                </li>
                                            </ol> 
                                            <hr/>
                                        </div>    
                                        <div role="tabpanel" class="tab-pane fade in" id="insertEditTab">
                                            <ol>
                                                <li>Make the code in the playback windows selectable by clicking the button below:<br/>
                                                    <button id="makeCodeSelectableButton" class="btn btn-default" onclick="makeIndividualCodeCharsSelectable()">Make the code selectable</button><br/>
                                                    (when selected, a character will be highlighted)
                                                </li>
                                                <li>
                                                    Choose whether the insert will go before the selected character or after it.
                                                    This is necessary when adding before the first character in a line or after the last one: <br/>
                                                    <input id="newHistoryBeforeElement" name="newHistoryBeforeAfterElement" type="radio" value="Insert before the selected element" checked> <label for="newHistoryBeforeElement">Insert before selected element</label><br/>
                                                    <input id="newHistoryAfterElement" name="newHistoryBeforeAfterElement" type="radio" value="Insert after the selected element"> <label for="newHistoryAfterElement">Insert after selected element</label><br/>
                                                    (a solid cursor will be added to one of the sides of the selected character)
                                                </li>
                                                <li>
                                                    Write the code that you want to insert at the selected location: <br/>
                                                    Text to insert:<br/>
                                                    <textarea id="insertNewHistoryText" rows="7" cols="50" class="storytellerEditable"></textarea><br/>
                                                </li>
                                                <li>
                                                    Click the button below to insert the text:<br>
                                                    <button id="insertNewHistoryButton" class="btn btn-default" onclick="insertHistory()">Insert new code</button><br/>
                                                </li>
                                            </ol>                    
                                            <hr/>                
                                        </div>    
                                    </div>
                                </fieldset>                    
                            </div>
                        </div>	
					</div>

					<!-- end of nested tabs for the playback windows -->
				</div>
			</div>
		</div>

		<!-- playback modals -->
		<!-- playback options modal -->
        <div id="playbackOptionsModal" class="modal fade in" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                        <h3 class="modal-title">Storyteller Options</h3>
                    </div>

                    <div class="modal-body">
                        <ul class="nav nav-tabs" role="tablist">
                            <li role="presentation" class="active"><a href="#playbackControlOptionsTab" role="tab" data-toggle="tab">Playback Control</a></li>
                            <li role="presentation"><a href="#savingReplayingPlaybackOptionsTab" role="tab" data-toggle="tab">Saving and Replaying Playbacks</a></li>
                            <li role="presentation"><a href="#otherOptionsTab" role="tab" data-toggle="tab">Other</a></li>
                        </ul>

                        <!-- Tab panes -->
                        <div class="tab-content">
                            <div role="tabpanel" class="tab-pane active" id="playbackControlOptionsTab">
                                <div class="row">
                                    <div class="col-sm-4">
                                        <label>Play/Pause</label>
                                    </div>
                                    <div class="col-sm-8">
                                        <p>
                                            The <button class="btn btn-default btn-xs">Play/Pause</button> button starts and pauses a playback. You can hit the <code>space bar</code> to toggle this from the keyboard.
                                            You can also use the slider to go to any point in the playback.
                                        </p>
                                        <p>
                                            The <button class="btn btn-default btn-xs">&lt;</button> and <button class="btn btn-default btn-xs">&gt;</button> buttons move the playback one step at a time for fine grained control of a playback. 
                                            You can use <code>left arrow</code> and <code>right arrow</code> keys to control this from the keyboard.
                                        </p>
                                        <p>
                                            The <button class="btn btn-default btn-xs">&lt;&lt;</button> moves the playback to the beginning and the <button class="btn btn-default btn-xs">&gt;&gt;</button> buttons move the playback to the next comment (or the end if there are none). 
                                            You can use <code>shift + left arrow</code> and <code>shift + right arrow</code> keys to control this from the keyboard.
                                        </p>
                                        <p>
                                            You can use <code>ctrl + shift + left arrow</code> and <code>ctrl + shift + right arrow</code> keys to move to the beginning and end of the playback. All comments will be skipped.
                                        </p>
                                    </div>
                                </div>
                                <hr/>
                                <div class="row">
                                    <div class="col-sm-4">                                    
                                        <label>Playback speed </label>   
                                        <br/>                                  
                                        <div class="btn-group" role="group">
                                            <button type="button" id="playbackSpeedIncreaseButton" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Make the playback move faster">Faster</button>
                                            <button type="button" id="playbackSpeedDecreaseButton" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Make the playback move slower">Slower</button>
                                        </div>
                                        <p>
                                            Current speed: <span id="currentPlaybackSpeed"><strong>100 ms</strong> in between events</span>
                                        </p>
                                    </div>
                                    <div class="col-sm-8">
                                        <p>
                                            There is a user defined amount of time in between each coding event. You can adjust this amount of time by using this control.
                                        </p>
                                        
                                        <p>
                                            You can hit <code>shift + up arrow</code> to speed up and <code>shift + down arrow</code> to slow down the playback from the keyboard.
                                        </p>
                                    </div>
                                </div>      
                                <hr/>
                                <div class="row">
                                    <div class="col-sm-4">                                    
                                        <label for="userWantsPauseOnCommentsCheckbox">
                                            <input type="checkbox" id="userWantsPauseOnCommentsCheckbox" checked="true">
                                                Pause playback for all comments

                                        </label>
                                    </div>
                                
                                    <div class="col-sm-8">
                                        <p>
                                            When a comment is encountered the playback will be paused so the user can see it and the current state of the code.
                                            By default, the playback will pause for all comments.
                                        </p>
                                        <p>
                                            You can hit <code>shift + p</code> to toggle whether to pause for comments from the keyboard.
                                        </p>
                                    </div>                  
                                </div>
                                <hr/>
                                <div class="row">
                                    <div class="col-sm-4">
                                        <label for="cutPasteInBlocksCheckbox">
                                            <input type="checkbox" id="cutPasteInBlocksCheckbox">
                                            Show all cuts and pastes in blocks
                                        </label>
                                    </div>
                                    <div class="col-sm-8">
                                        <p>
                                            Cuts, pastes, and group tabbing affect many different code characters at once. These operations can be slow to watch. 
                                            By default, entire groups of characters that were cut, pasted, or tabbed will be shown in a single step to improve watchability. 
                                            If you'd like to animate each individual character, use this control.
                                        </p>
                                        <p>
                                            You can hit <code>shift + b</code> to toggle whether to show cuts/pastes in blocks from the keyboard.
                                        </p>
                                    </div>    
                                </div>
                                <hr/>
                                <div class="row">
                                    <div class="col-sm-4">
                                        <label for="showRecentHighlightsCheckbox">
                                            <input type="checkbox" id="showRecentHighlightsCheckbox" checked="true">
                                            Highlight recent changes
                                        </label>
                                    </div>
                                    <div class="col-sm-8">
                                        <p>
                                            To make it easier to see what changes have been made since the last pause point, new inserts and deletes are highlighted.
                                            The highlights are removed each time you resume a playback by hitting <button class="btn btn-default btn-xs">Play</button>.                                        
                                        </p>
                                        <p>
                                            You can hit <code>shift + h</code> to toggle whether to highlight new events from the keyboard.
                                        </p>
                                    </div>    
                                </div>

                                <div class="row">
                                    <div class="col-sm-4">
                                        <button id="clearRecentChangesButton" class="btn btn-default"  data-toggle="tooltip" data-placement="top" title="Clear recent change highlights">
                                            Clear recent changes
                                        </button>
                                    </div>
                                    <div class="col-sm-8">
                                        <p>
                                            To clear all recent changes without resuming the playback use this control. You can hit <code>shift + c</code> to clear the changes from the keyboard.
                                        </p>
                                    </div>    
                                </div>
                            </div>
                            
                            <div role="tabpanel" class="tab-pane" id="savingReplayingPlaybackOptionsTab">
                                <div class="row">                                
                                    <div class="col-sm-4">                                
                                        <p>
                                            <label>Download playback to your filesystem</label>
                                            <button id="savePlaybackButton" class="btn btn-default"  data-toggle="tooltip" data-placement="top" title="Download playback to your file system">Download this playback</button>
                                        </p>                                        
                                    </div>
                                    
                                    <div class="col-sm-8">
                                        <p>
                                            Save the current playback to your file system in a file. This file can be uploaded in the future to replay the exact same playback.
                                        </p>
                                    </div>    
                                </div>
                                <hr/>
                                <div class="row">
                                    <div class="col-sm-4">
                                        <p>
                                            <label class="btn btn-default btn-file" data-toggle="tooltip" data-placement="top" title="Play a previous playback">
                                                Upload a previous playback<input type="file" id="uploadPlaybackButton" style="display: none;">
                                            </label> 
                                        </p>
                                    </div>
                                    <div class="col-sm-8">
                                        <p>
                                            Select a previously downloaded playback file to replay it. The current playback information will be lost.
                                        </p>
                                    </div>    
                                </div>
                            </div>
                            
                            <div role="tabpanel" class="tab-pane" id="otherOptionsTab">
                                <div class="row">
                                    <div class="col-sm-4">
                                        <p>
                                            <label>
                                                Increase/decrease the font size: 
                                            </label>         
                                            <br/>                           
                                            <div class="btn-group" role="group">
                                                <button type="button" id="fontIncreaseButton" class="btn btn-default"  data-toggle="tooltip" data-placement="top" title="Make the text bigger">Bigger</button>
                                                <button type="button" id="fontDecreaseButton" class="btn btn-default"  data-toggle="tooltip" data-placement="top" title="Make the text smaller">Smaller</button>
                                            </div>
                                        </p>
                                    </div>
                                    <div class="col-sm-8">
                                        <p>
                                            Change the size of the text on the screen.
                                        </p>
                                        <p>
                                            <code>shift + alt + up arrow</code> and <code>shift + alt + down arrow</code> will change the size of the text.    
                                        </p>
                                    </div>    
                                </div>
                                <hr/>
                                <div class="row">
                                    <div class="col-sm-4">                                    
                                        <label>Options</label>                                    
                                    </div>
                                    <div class="col-sm-8">
                                        <p>
                                            <code>shift o</code> opens this options window. <code>esc</code> closes it.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        </div>


        <!-- save state modal -->
        <div id="saveStateModal" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">

                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                        <h3 class="modal-title">Save State of Playback</h3>
                    </div>

                    <div class="modal-body">
                        <p>
                            Saving the state of a playback will cause a zip file to be downloaded to your machine. You can unzip 
                            the file and then open the project inside of it with a Storyteller supported editor. This has the 
                            contents of the code where the playback was paused so that you can build from that point in the playback.                              
                        </p>
                        <p>
                            There are three options when saving the state of a playback:
                        </p>
                        
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <div class="radio">
                                    <label>
                                        <input type="radio" name="saveStateRadios" id="saveStateRadioX" value="upToPausePoint" checked>
                                        <span class="panel-title">No History Beyond Pause Point</span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="panel-body">
                                <p>
                                    With this type of save, all the code and comments up to the pause point are recorded but none after. In
                                    the download there will be no code or comments past the pause point in the playback. 
                                </p>
                                <p>
                                    This is the best option if you'd like to forget everything after the pause point.
                                </p>
                            </div>
                        </div>

                        
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <div class="radio">
                                    <label>
                                        <input type="radio" name="saveStateRadios" id="saveStateRadioX" value="minimal">
                                        <span class="panel-title">Minimal History</span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="panel-body">
                                <p>
                                    With this type of save, only the code on the screen is added to the download. Any code that was
                                    added and then deleted will not be a part of the download's history.
                                </p>
                                <p>
                                    This is the best option if you'd like to completely forget all the past history except 
                                    for what is on the screen.
                                </p>
                            </div>
                        </div>

                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <div class="radio">
                                    <label>
                                        <input type="radio" name="saveStateRadios" id="saveStateRadioX" value="full">
                                        <span class="panel-title">Full History with Future Events Undone</span>
                                    </label>
                                </div>
                            </div>
    
                            <div class="panel-body">
                                <p>
                                    With this type of save, <em>all</em> of the history of the playback is recorded in the download, 
                                    even after the point where the playback was paused. However, all events after the pause point are 
                                    undone by adding the inverse of those events. 
                                </p>
                                <p>
                                    For example, if there is a create file followed by three inserts after the point in the playback
                                    where the user paused, then three deletes and a delete file will be added to the list of events 
                                    to roll back the starting state of the new download to the pause point. 
                                </p>
                                <p>
                                    All comments and history are available to see in playbacks from that project but the starting point 
                                    for future development is the pause point in the playback. This is the best option if you want a deep 
                                    history of all the changes in your code.
                                </p>
                            </div>
                        </div>
                        <div class="text-right form-group">
                            <input type="checkbox" name="removeCommentsCheckbox" id="removeCommentsCheckbox">
                            <label for="removeCommentsCheckbox">Remove all comments from the downloaded playback data </label>
                        </div>
                    </div>
                    
                    <div class="modal-footer">
                        <div class="form-group">
                            
                            <button type="button" id="saveStateOfFilesButton" class="btn btn-default" data-dismiss="modal">
                                Save 
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- playback filter modal -->
        <div id="filtersModal" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">

                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                        <h3 class="modal-title">Filter Options</h3>
                    </div>

                    <div class="modal-body">
                        <div id="filterOptionsContainer">
                            <!-- links for the filter tabs -->
                            <ul class="nav nav-tabs" role="tablist">
                                <li class="active"><a href="#filterByTimeTab" data-toggle="tab">By Time</a></li>
                                <li><a href="#filterByDevGroupTab" data-toggle="tab">By Developer Group</a></li>
                                <li><a href="#filterByFileTab" data-toggle="tab">By File</a></li>
                                <li><a href="#filterBySelectedTextTab" data-toggle="tab">By Selected Text</a></li>
                            </ul>

                            <!-- filter tab panes -->
                            <div class="tab-content">
                                <!-- by time -->
                                <div class="tab-pane active" id="filterByTimeTab">
                                    <p>
                                        This filter allows you to see coding activity during different periods of time. 
                                        Below is a list of all time spans that, if code was written in that time frame, it will be animated.
                                        Any code written outside of these time spans will <em><strong>not</strong></em> be animated but it will still be shown among the rest of the code.
                                    </p>
                                    <p>
                                        You can use the timestamp of the current event to make your filters.
                                        This is useful to skip unintersting parts of the development process.
                                    </p>
                                    <p>
                                        By default, a time span with the entire history is provided. 
                                        You can add multiple time spans and remove them as needed. 
                                    </p>
                                    <hr/>
                                    <div>                                        
                                        <table id="userSelectedTimeSpans" class="table table-striped table-condensed table-hover"> 
                                            <caption>Selected time span filters</caption>
                                            <tr>
                                                <th>&nbsp;</th>
                                                <th>Start Time</th>
                                                <th>End Time</th>
                                            </tr>                                            
                                        </table>
                                    </div>
                                    <hr/>
                                    <div>
                                        <div class="form-group">
                                            <label for="startTimeInput" >Start time: </label>
                                            <div class="input-group">
                                                <input type="text" class="form-control storytellerEditable" id="startTimeInput" placeholder="MM/DD/YYYY HH:MM::SS"/>
                                                <span class="input-group-btn">
                                                    <button type="button" id="useCurrentEventStartTimeButton" class="btn btn-default">
                                                        Use the current event's time
                                                    </button>
                                                </span>
                                            </div>
                                        
                                            <label for="endTimeInput" >End time: </label>
                                            <div class="input-group">
                                                <input type="text" class="form-control storytellerEditable" id="endTimeInput" placeholder="MM/DD/YYYY HH:MM::SS"/>
                                                <span class="input-group-btn">
                                                    <button type="button" id="useCurrentEventEndTimeButton" class="btn btn-default">
                                                        Use the current event's time
                                                    </button>
                                                </span>
                                            </div>
                                            <br/>
                                            <button type="button" id="addTimeFilterButton" class="btn btn-default">
                                                Add a time span to the filter 
                                            </button>
                                            
                                        </div>
                                    </div>                                    
                                </div>

                                <!-- by dev group -->
                                <div class="tab-pane" id="filterByDevGroupTab">
                                    <p>
                                        This filter allows you to animate the code written by certain developer(s). 
                                    </p>
                                    <p>
                                        All selected developers' code will be animated. 
                                        The code from developers who were not selected is still shown but it is <em><strong>not</strong></em> animated in the playback.
                                    </p>
                                    <p>
                                        This is useful for focusing on the contribution of one or more developers.
                                    </p>
                                    <hr/>
                                    <div id="devGroupFilter"></div>
                                </div>

                                <!-- by file -->
                                <div class="tab-pane" id="filterByFileTab">
                                    <p>
                                        This filter allows you to animate the code written in certain files. 
                                    </p>
                                    <p>
                                        Only the code in the selected files will be animated and displayed. 
                                        The code in the other files will be shown but will <em><strong>not</strong></em> be animated.
                                        This is useful for focusing on one or more files.
                                    </p>
                                    <p>
                                        Files and folders that were added and then deleted will be available for selection.
                                    </p>
                                    <hr/>
                                    <div class="form-group">
                                        <!-- list of all files/dirs in the system even deleted ones -->
                                        <ul id="viewOfFileSystemForFiltering" class="fileOrDirListForFiltering"></ul>

                                        <!-- controls to show or hide deleted files/dirs-->
                                        <input type="checkbox" name="hideDeletedDirsCheckbox" id="hideDeletedDirsCheckbox">
                                        <label for="hideDeletedDirsCheckbox">Hide deleted files and directories</label>
                                    </div>
                                </div>

                                <!-- by selected text -->                                
                                <div class="tab-pane" id="filterBySelectedTextTab">
                                    <p>
                                        This filter allows you to select some code and have it be animated in a playback. 
                                        Only the selected text on the screen will be played back.
                                    </p>
                                    <p>
                                        It will show all the code that ever touched the selected code. 
                                        This is useful for finding out the full history of a block of code (like a method).                                        
                                    </p>
                                    <hr/>
                                    <div class="form-group">
                                        <!-- choose the text that is selected on the screen -->
                                        <label for="selectedTextCheckbox">
                                            <input type="checkbox" id="selectedTextCheckbox">
                                            Playback the Selected Text on the Screen
                                        </label>  
                                        <br/>
                                        &nbsp;&nbsp;&nbsp;<input type="radio" name="selectedTextFilterType" id="noOtherFiltersRadio" checked="true">
                                        <label for="noOtherFiltersRadio">use only the selected text and no other filters</label>
                                        <br/>
                                        &nbsp;&nbsp;&nbsp;<input type="radio" name="selectedTextFilterType" id="withOtherFiltersRadio">
                                        <label for="withOtherFiltersRadio">use the selected text and the other filters (time, dev group, file)</label>

                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="modal-footer">
                        <div class="form-group">
                            
                            <label for="showRelevantCutCopyPastesCheckbox">
                                <input type="checkbox" id="showRelevantCutCopyPastesCheckbox">
                                Show where relevant code was cut/copied from
                            </label>
                            &nbsp;&nbsp;&nbsp;&nbsp;
                            <!-- clear all filters -->
                            <button type="button" id="clearFilterButton" class="btn btn-default" data-dismiss="modal">
                                Clear All Filters 
                            </button>

                            <button type="button" id="filterButton" class="btn btn-default" data-dismiss="modal">
                                Filter 
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- playback comment picture modal -->
        <div id="editCommentPictureModal" class="modal fade" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div id="commentDrawingModal" class="modal-content">

                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                        <h3 class="modal-title">Add an image</h3>
                    </div>

                    <div class="modal-body">
                        <!-- the drawing canvas -->
                        <canvas id="commentCanvas" class="img-thumbnail" height="675" width="860">                            
                        </canvas>

                        <div>
                            <div class="row">
                                <div class="col-sm-4">
                                    <table class="penTable">
                                        <tr>
                                            <td>Pen Color &nbsp;</td>
                                            <td id="bluePen" class="penColorSelected penColor">&nbsp;</td> 
                                            <td id="blackPen" class="penColor">&nbsp;</td> 
                                            <td id="whitePen" class="penColor">&nbsp;</td>
                                            <td id="redPen" class="penColor">&nbsp;</td>
                                        </tr>
                                    </table>
                                </div>

                                <div class="col-sm-4">
                                    <table>
                                        <tr>
                                            <td>Pen size &nbsp;</td>
                                            <td id="extraLargePen">&#x25CF;</td>
                                            <td id="largePen">&#x25CF;</td>
                                            <td id="mediumPen" class="penSizeSelected">&#x25CF;</td>
                                            <td id="smallPen">&#x25CF;</td>
                                        </tr>
                                    </table>
                                </div>

                                <div class="col-sm-4">
                                    <table>
                                        <tr>
                                            <td>&nbsp;History &nbsp;</td>
                                            <td>
                                                <div class="form-group">
                                                    <button type="button" id="undoDraw" class="btn btn-default btn-sm" data-toggle="tooltip" data-placement="top" title="ctrl/cmd + z">
                                                        Undo
                                                    </button>
                                                </div>
                                            </td>
                                            <td>
                                                <div class="form-group">
                                                    <button type="button" id="redoDraw" class="btn btn-default btn-sm" data-toggle="tooltip" data-placement="top" title="ctrl/cmd + y">
                                                        Redo
                                                    </button>
                                                </div>
                                            </td>
                                        </tr>
                                    </table>
                                </div>
                            </div>
                            
                            <label class="btn btn-default btn-file">
                                    Browse for an image <input type="file" id="importImageButton" style="display: none;"/>
                            </label>
                            <!-- a collection of previous images to start a new image from -->                                               
                            <div id="commentImageStartingPointGallery">  
                                                          
                            </div>
                        </div>

                    </div>

                    <div class="modal-footer">
                        <div class="form-group">
                            <!-- clear the image and create a blank slate -->
                            <button type="button" id="clearCommentImageButton" class="btn btn-default">
                                Clear Image 
                            </button>

                            <!-- save the image -->
                            <button type="button" id="useImageInACommentButton" class="btn btn-default" data-dismiss="modal">
                                Use this Image 
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- playback comment picture modal for displaying comments -->
        <div id="commentPictureDisplayModal" class="modal fade" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">

                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                        <h3 class="modal-title">Comment Image</h3>
                    </div>

                    <div class="modal-body">
                        <!-- the image will go here-->
                        <img id="largeImageDisplay" class="img-thumbnail" height="675" width="820" alt="Comment Image">

                        <!-- a repeat of the comment text will go here -->
                        <div id="commentTextInLargeDisplay">
                        </div>
                    </div>

                    <div class="modal-footer">
                        <button type="button" class="btn btn-default" data-dismiss="modal">
                            Close
                        </button>
                    </div>
                </div>
            </div>
        </div>
		
        <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
        <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>

        <!-- Latest compiled and minified JavaScript -->
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

        <!-- md5 -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.3.1/js/md5.min.js"></script>
        
        <!-- zip -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.3/jszip.min.js"></script>

        <script>
  
            /*
             * This data structure holds information necessary for a playback.
             */
            var playbackData = {
                codeEvents: [],						//holds all of the events to be played back
                codeEventsIndex: -1,				//holds the index of the 'current' event during playback
                mostRecentDirection: "forward",		//holds the direction of the latest animated event
                numberOfRelevantEvents: 0,			//holds the number of events that are marked as relevant
                relevantEventIndex: 0,				//the index of the most recent relevant event
                playbackState: "paused",			//state of the playback (playing/paused)
                playbackTimerId: null,				//id of the timer used to control animating events
                activeFileId: null,					//the latest active file id in the playback
                activeLineNumber: null,				//the latest active line number in the playback
                allDevelopers: null,				//an object of all of the developers (each dev id is a key)
                allDeveloperGroups: null,			//an object with of all of the developer groups
                currentDevGroupId: null,			//the id of the dev group that will be used to create new comments and events
                latestPlaybackEventDevGroupId: null,//the id of the last dev group to make a relevant contribution during playback 
                allFiles: null,             		//an object with info about all the files ever created in the system 
                allDirs: null,              		//an object with info about all of the directories ever created in the system 
                delay: 100,							//delay in between playback events in ms
                highlightDelay: 300,    			//amount of time a new element will be highlighted on insert/delete
                showPastesInABlock: false,			//show any pasted code as a single big block of text
                showRecentsChanges: true,           //highlight recent changes in between play/pause cycles
                comments: {},						//an object that will hold event ids as a key and groups of comments to display at the event
                userWantsPauseOnComments: true,     //indicates whether playback should be paused if there is a comment
                playbackDescription: {},            //holds some descriptive info about the playback like the title, description, etc.
                branchId: ""                        //holds the branch id of this playback
            };
            //when adding to this make sure to update getPlaybackWindowsReadyForAnimation()

            /*
             * This object holds info about the canvas that is used to draw on when making comments
             */
            var canvasData = {
                commentCanvas: null,				//the canvas to draw on
                commentCanvasContext: null,			//the context used to do the drawing
                currentMousePosition: {x: 0, y: 0},	//current mouse position on the canvas
                previousMousePosition: {x: 0, y: 0},//previous mouse position on the canvas
                undoList: [],                       //list of points to undo
                redoList: []                        //list of points to redo
            };

            /*
             * This object holds info about the different images that have been created
             */
            var images = {
                prependId: "img_",
                sequenceNumber: 0
            };

            /*
             * For video recording comments
             */
            //a collection of all video comments
            var globalVideoComments = [];

            //a source of video from the user's web cam
            var mediaStream = null;
            //an video recorder to record comments 
            var mediaRecorder = null;

            //flag that says whether the ctrl or command button is pressed
            var ctrlCmdPressed = false;

            //*****************************************************************************
            //                         Page setup related code
            //                         -----------------------
            // This code has to do with setting up the page to be ready to playback code. 
            // It mostly involves setting up the UI to respond to events. Most of what the 
            // listeners do is right in the anonymous functions.
            //*****************************************************************************
            /*
             * Set up the event handlers for all of the controls on the page. Set up the drawing canvas
             * for comment pictures. Load the playback data to make it ready to animate.
             */
            document.addEventListener("DOMContentLoaded", function(event) {

                //construct the playback object. There is a bit of magic here, loadPlaybackData() is added 
                //to this file dynamically by the playback web server and it includes all of the events,
                //dev info, commments, etc.                
                loadPlaybackData();
                
                //set up the UI event handlers
                setUpUIEventHandlers();

                //set up the drawing canvas
                setUpDrawingCanvas();

                //jquery and bootstrap tab related code
                //for tooltips- can remove if move away from bootstrap
                //the tooltips won't show until a hover that lasts 1000 ms and will go away
                //after 200 ms hover out
                $('[data-toggle="tooltip"]').tooltip({delay: {show: 500, hide: 200}});
                
            });

			/*
			 * This function is called by the playback code to get code events and developer info used
			 * for playback. This is one of the only direct dependencies between the playback code and 
			 * this editor. Before a playback begins the playback code will always call a function called
			 * loadPlaybackData to attempt to load data in from an editor (if the playback gets its data
			 * from somewhere else then there won't be an implementation for loadPlaybackData and nothing
			 * will be called).
			 *
			 * If we move away from using an editor and playback in the same page this can be removed
			 * but there has to be another way for the playback data to be filled in (perhaps from a file,
			 * local storage, or from a textbox)
			 */            
            function loadPlaybackData() {} //!!! string replacement of function here !!!
            
            function makeAnAlert(msg, alertType, idOfAlertArea) {
                
                //make the alert div
                var alertElement = document.createElement("div");
                alertElement.classList.add("alert");
                alertElement.classList.add(alertType);
                alertElement.classList.add("alert-dismissible");
                alertElement.classList.add("fade");
                alertElement.classList.add("in");
                
                //add a button 
                var dismissButton = document.createElement("button");
                dismissButton.classList.add("close");
                dismissButton.setAttribute("data-dismiss", "alert");                
                var dismissButtonText = document.createElement("span");
                dismissButtonText.innerHTML = "&times;";
                dismissButton.appendChild(dismissButtonText);

                //add the close button
                alertElement.appendChild(dismissButton);
                //add the message
                alertElement.appendChild(document.createTextNode(msg));
                
                //go to the specified element and add the alert
                document.querySelector("#" + idOfAlertArea).appendChild(alertElement);                
            }

            function makeATextEditToolbar() {

                // <div class="btn-group" role="group">
                //     <button type="button" class="btn btn-default"><strong>B</strong></button>
                //     <button type="button" class="btn btn-default"><em>I</em></button>
                //     <div class="input-group input-group-sm">
                //         <input type="text" class="form-control" placeholder="Link URL">                                            
                //         <span class="input-group-btn">
                //             <button class="btn btn-default" type="button">Create Link</button>
                //         </span>
                //     </div>
                // </div>            


                var textEditToolbar = document.createElement("div");
                textEditToolbar.classList.add("btn-group");
                textEditToolbar.classList.add("btn-group-sm");

                var boldButton = document.createElement("button");
                boldButton.classList.add("btn");
                boldButton.classList.add("btn-default");
                var boldButtonText = document.createElement("span");
                boldButtonText.innerHTML = "<strong>B</strong>";
                boldButton.addEventListener("click", function(){
                    document.execCommand("bold");
                });
                boldButton.appendChild(boldButtonText);

                var italicsButton = document.createElement("button");
                italicsButton.classList.add("btn");
                italicsButton.classList.add("btn-default");
                var italicsButtonText = document.createElement("span");
                italicsButtonText.innerHTML = "<em>I</em>";
                italicsButton.addEventListener("click", function(){
                    document.execCommand("italic");
                });
                italicsButton.appendChild(italicsButtonText);

                var linkInputGroup = document.createElement("div");
                linkInputGroup.classList.add("input-group");
                linkInputGroup.classList.add("input-group-sm");

                var linkTextBox = document.createElement("input");
                linkTextBox.setAttribute("type", "text");
                linkTextBox.classList.add("form-control")
                linkTextBox.setAttribute("placeholder", "Link URL");

                var linkInputGroupButton = document.createElement("span");
                linkInputGroupButton.classList.add("input-group-btn")

                var linkButton = document.createElement("button");
                linkButton.classList.add("btn");
                linkButton.classList.add("btn-default");
                var linkButtonText = document.createElement("span");
                linkButtonText.innerHTML = "Create Link";
                linkButton.appendChild(linkButtonText);
                linkButton.addEventListener("click", function(){
                    var uri = linkTextBox.value;
                    document.execCommand("createLink", false, uri);
                });
                linkInputGroupButton.appendChild(linkButton);

                linkInputGroup.appendChild(linkTextBox);
                linkInputGroup.appendChild(linkInputGroupButton);

                textEditToolbar.appendChild(boldButton);
                textEditToolbar.appendChild(italicsButton);
                textEditToolbar.appendChild(linkInputGroup);
                
                return textEditToolbar;
            }

            /*
             * This function registers the UI listeners for
             * - step forward/backward buttons
             * - play/pause button
             * - playback progress slider
             * - playback speed controls
             * - font increase/decrease buttons
             * - keyboard shortcuts
             * --- left arrow: go back a step
             * --- right arrow: go forward a step
             * --- up arrow: speed up the playback
             * --- down arrow: slow down the playback
             * --- space bar: toggle the playback state
             * - cut/paste in blocks checkbox
             * - pause for comments checkbox
             * - filter setup
             * --- hide deleted files/dirs
             * --- gather filter info
             * --- selected text filter
             * --- clear all filters
             * - add comments
             * - comment image
             * --- save image
             * --- clear image
             * --- import image
             * - save state of file system
             * - save playback in json file
             * - load saved playback
             */
            function setUpUIEventHandlers() { 

                //TODO make each one of these a separate non-anonymous function

                //step backwards to the beginning button
                document.querySelector("#stepBackwardToBeginningButton").addEventListener("click", function(e) {

                    //stop the playback
                    pausePlayback();

                    //clear the all the new event highlights since the the last pause point
                    clearPreviousEventHighlights();

                    //move back as far as possible
                    step("backward", Number.MAX_SAFE_INTEGER, true);
                });

                //single step backwards button
                document.querySelector("#stepBackwardButton").addEventListener("click", function(e) {

                    //stop the playback
                    pausePlayback();

                    //move backward one element
                    step("backward", 1, true);
                });

                //toggle play/pause
                document.querySelector("#playPauseButton").addEventListener("click", function(e) {

                    //handle the click of the play/pause button
                    togglePlayPause();
                });

                //handle a double tap in the playback window to move to the next comment
                var firstTapComplete = false;
                document.querySelector("#playbackWindows").addEventListener("touchend", function(event) {

                    //consume the toch event and don't pass it on
                    event.preventDefault();

                    //if this is the first tap of a double tap
                    if(firstTapComplete === false) {

                        //create a timer to nullify the first tap a short time later in the future
                        setTimeout(function() {firstTapComplete = false}, 300);

                        //indicate that this is the first tap of a double tap
                        firstTapComplete = true;
                    
                    } else { //the first tap has already happened (within 400 ms)

                        //simulate a corresponding forward button click
                        document.querySelector("#stepForwardToEndButton").click();
                    }
                });

                //single step forwards button
                document.querySelector("#stepForwardButton").addEventListener("click", function(e) {

                    //stop the playback
                    pausePlayback();

                    //move forward one element
                    step("forward", 1, true);
                });

                //step forwards to the end of the playback button
                document.querySelector("#stepForwardToEndButton").addEventListener("click", function(e) {

                    //stop the playback
                    pausePlayback();

                    //clear the all the new event highlights since the the last pause point
                    clearPreviousEventHighlights();
                    
                    //move forward to the end
                    step("forward", Number.MAX_SAFE_INTEGER, true);
                });
                //event slider
                document.querySelector("#progressBarContainer").addEventListener("click", function(e) {

                    //this is somewhat dependent on bootstrap. If we ever get rid of bootstrap
                    //in favor of pure js/html we can use an html5 range as a slider or roll our own

                    //the offset from the beginning of the progress bar (in pixels) when
                    //the progress bar click happened
                    var offsetXFromBeginningOfProgressBar;

                    //older versions of firefox don't support offsetX so this is a work around

                    //if there is an offsetX in the click event (chrome and all other browsers except ff)
                    if(e.offsetX) {

                        //offsetX is the offset in pixels from the beginning of the progress bar
                        offsetXFromBeginningOfProgressBar = e.offsetX;

                    } else { //older versions of firefox don't have offsetX, they have e.layerX

                        //get the equivalent in firefox
                        offsetXFromBeginningOfProgressBar = e.layerX;
                    }

                    //e.target.parentNode.offsetWidth is the width of the entire progress bar (in pixels)
                    //calculate the percentage where the click happened in the progress bar
                    var percentPositionOfClick = offsetXFromBeginningOfProgressBar / e.target.parentNode.offsetWidth;

                    //choose a code event index based on the percent position in the progress bar
                    var clickedEventIndex = Math.round(percentPositionOfClick * playbackData.numberOfRelevantEvents);
                    
                    //stop playback
                    pausePlayback();
                    
                    //if the clicked event index is before the current position
                    if(clickedEventIndex < playbackData.relevantEventIndex) {

                        //clear the all the new event highlights since the the last pause point
                        clearPreviousEventHighlights();

                        //move backwards to the click point and do not pause for comments
                        step("backward", playbackData.relevantEventIndex - clickedEventIndex, false);

                    } else if (clickedEventIndex > playbackData.relevantEventIndex) { //clicked after the current position

                        //move forwards to the click point and do not pause for comments
                        step("forward", clickedEventIndex - playbackData.relevantEventIndex, false);
                    }
                    //else- it is equal and the code does not have to move

                });

                //playback speed increase button
                document.querySelector("#playbackSpeedIncreaseButton").addEventListener("click", function(e) {

                    //increase the delay in between playing back events (function takes a delta)
                    changeSpeed(-25);
                });

                //playback speed decrease button
                document.querySelector("#playbackSpeedDecreaseButton").addEventListener("click", function(e) {

                    //decrease the delay in between playing back events (function takes a delta)
                    changeSpeed(25);
                });

                //font increase button
                document.querySelector("#fontIncreaseButton").addEventListener("click", function(e) {

                    //increase the font of the playback windows and the gutters
                    //get all the playback windows
                    var playbackWindows = document.querySelector("#playbackWindows");

                    //if there is a defined font size
                    if(playbackWindows.style.fontSize) {

                        //get the old size by stripping off the 'px' at the end
                        var oldSizeInPx = parseInt(playbackWindows.style.fontSize.slice(0, playbackWindows.style.fontSize.length - 2));

                        //add 2 points to the size
                        oldSizeInPx = oldSizeInPx + 2;

                        //set the font size
                        playbackWindows.style.fontSize = oldSizeInPx + "px";

                    } else { //no defined font size

                        //default is 18 so make it 2 points bigger
                        playbackWindows.style.fontSize = "20px";
                    }
                });

                //font decrease button
                document.querySelector("#fontDecreaseButton").addEventListener("click", function(e) {

                    //decrease the font of the playback windows and the gutters
                    var playbackWindows = document.querySelector("#playbackWindows");

                    //if there is a defined font size
                    if(playbackWindows.style.fontSize) {

                        //get the old size by stripping off the 'px' at the end
                        var oldSizeInPx = parseInt(playbackWindows.style.fontSize.slice(0, playbackWindows.style.fontSize.length - 2));

                        //deduct 2 points to the size
                        oldSizeInPx = oldSizeInPx - 2;

                        //set the font size
                        playbackWindows.style.fontSize = oldSizeInPx + "px";

                    } else { //no defined font size

                        //default is 18 so make it 2 points smaller
                        playbackWindows.style.fontSize = "16px";
                    }
                });

                //keyboard shortcuts
                document.addEventListener("keydown", function (e) {

                    //left arrow, right arrow, up arrow, down arrow, and space bar control
                    //the playing of events
                    
                    //if the event happened in any of the editable text areas
                    if(e.target.classList.contains("storytellerEditable")) {
                        
                        //don't handle the keydown here because the user could be typing a comment, entering a playback description, etc.
                        e.stopImmediatePropagation();

                    } else { //the keydown did not happen in one of the editable text areas

                        if(e.keyCode === 37){ //left

                            //if this is a shift + arrow
                            if(e.shiftKey) {            

                                //ctrl + shift + arrow 
                                if(e.ctrlKey || e.metaKey) {

                                    //go to the very beginning of the playback
                                    //stop the playback
                                    pausePlayback();

                                    //clear the all the new event highlights since the the last pause point
                                    clearPreviousEventHighlights();
                                    
                                    //move backward to the beginning
                                    step("backward", Number.MAX_SAFE_INTEGER, false);

                                } else {

                                    //simulate a corresponding button click
                                    document.querySelector("#stepBackwardToBeginningButton").click();
                                }

                            } else { //this is just an arrow

                                //simulate a corresponding button click
                                document.querySelector("#stepBackwardButton").click();
                            }

                        } else if(e.keyCode === 39){ //right
                            
                            //if this is a shift + arrow
                            if(e.shiftKey) { 

                                //ctrl + shift + arrow
                                if(e.ctrlKey || e.metaKey) {

                                    //go to the very end of the playback
                                    //stop the playback
                                    pausePlayback();

                                    //clear the all the new event highlights since the the last pause point
                                    clearPreviousEventHighlights();
                                    
                                    //move forward to the end
                                    step("forward", Number.MAX_SAFE_INTEGER, false);                                    

                                } else {

                                    //simulate a corresponding button click
                                    document.querySelector("#stepForwardToEndButton").click();
                                }
                            } else { //just an arrow
                                
                                //simulate a corresponding button click
                                document.querySelector("#stepForwardButton").click();
                            }

                        } else if(e.keyCode === 38 && e.shiftKey){ //shift + up

                            //alt key is pressed too
                            if(e.altKey) {
                                
                                //simulate a corresponding button click
                                document.querySelector("#fontIncreaseButton").click();

                            } else { //just shift + up

                                //simulate a corresponding button click
                                document.querySelector("#playbackSpeedIncreaseButton").click();
                            }

                        } else if(e.keyCode === 40 && e.shiftKey){ //shift + down

                            //alt key is pressed too
                            if(e.altKey) {
                                
                                //simulate a corresponding button click
                                document.querySelector("#fontDecreaseButton").click();

                            } else { //just shift + up

                                //simulate a corresponding button click
                                document.querySelector("#playbackSpeedDecreaseButton").click();
                            }

                        } else if(e.keyCode === 80 && e.shiftKey){ //shift + p

                            //toggle the pause for comments option
                            document.querySelector("#userWantsPauseOnCommentsCheckbox").click();

                        } else if(e.keyCode === 66 && e.shiftKey){ //shift + b

                            //toggle the show cuts/pastes in blocks option
                            document.querySelector("#cutPasteInBlocksCheckbox").click();

                        } else if(e.keyCode === 72 && e.shiftKey){ //shift + h

                            //toggle the show recent highlights option
                            document.querySelector("#showRecentHighlightsCheckbox").click();

                        } else if(e.keyCode === 79 && e.shiftKey){ //shift + o

                            //open the options modal
                            $('#playbackOptionsModal').modal('show');

                        } else if(e.keyCode === 70 && e.shiftKey){ //shift + f

                            //open the filters modal
                            $('#filtersModal').modal('show');

                        } else if(e.keyCode === 68 && e.shiftKey){ //shift + d

                            //open the download modal
                            $('#saveStateModal').modal('show');

                        } else if(e.keyCode === 67 && e.shiftKey){ //shift + c

                            //clear all the recent changes
                            clearPreviousEventHighlights();

                        } else if(e.keyCode === 32){ //space bar

                            //space bar outside of the text area

                            //toggle playing and pausing
                            document.querySelector("#playPauseButton").click();
                            
                            //prevent the screen from scrolling on play/pause
                            e.preventDefault();    

                        } else { //check if it is from the drawing modal

                            //get the modal with the drawing canvas
                            var editCommentPictureModal = document.querySelector("#editCommentPictureModal");
                            
                            //if the picture editor modal is open on the screen
                            if(editCommentPictureModal.classList.contains("in")) {
                                
                                //if the user wants to undo
                                if(e.keyCode === 90 && (e.ctrlKey || e.metaKey)) { //ctrl/cmd + z
                                    
                                    //simulate clicking the undo button
                                    document.querySelector("#undoDraw").click();

                                    //prevent the screen from scrolling on play/pause
                                    e.preventDefault();  

                                } else if(e.keyCode === 89 && e.ctrlKey) { //ctrl/cmd + y, redo
                                    
                                    //simulate clicking the redo button
                                    document.querySelector("#redoDraw").click();

                                    //prevent the screen from scrolling on play/pause
                                    e.preventDefault();  
                                }
                            }
                        }
                    }
                });

                //indicates whether the user wants to see all cuts and pastes in blocks
                document.querySelector("#cutPasteInBlocksCheckbox").addEventListener("click", function(e) {

                    //store the user's choice about whether to see all cuts/pastes in blocks
                    playbackData.showPastesInABlock = e.target.checked;
                });

                //indicates whether the user wants to highlight recent changes
                document.querySelector("#showRecentHighlightsCheckbox").addEventListener("click", function(e) {

                    //store the user's choice about whether to see recent changes
                    playbackData.showRecentsChanges = e.target.checked;
                });

                //indicates whether the user wants to clear all the recent change highlights
                document.querySelector("#clearRecentChangesButton").addEventListener("click", function(e) {

                    //clear all the recent changes
                    clearPreviousEventHighlights();
                });

                //indicates whether the user wants to have playback pause whenever there is a comment
                document.querySelector("#userWantsPauseOnCommentsCheckbox").addEventListener("click", function(e) {

                    //store the user's choice about whether to pause for comments
                    playbackData.userWantsPauseOnComments = e.target.checked;
    
                    //get the div that holds all of the comment markers
                    var commentMarkerContainer = document.querySelector("#commentMarkerContainer");

                    //if we would like to see comments
                    if(playbackData.userWantsPauseOnComments) {

                        //remove the hidden class
                        commentMarkerContainer.classList.remove("inactiveCommentMarkerContainer");
                        commentMarkerContainer.classList.add("activeCommentMarkerContainer");

                    } else { //we do not want to see comments

                        //add the class to hide all of the comment markers
                        commentMarkerContainer.classList.remove("activeCommentMarkerContainer");
                        commentMarkerContainer.classList.add("inactiveCommentMarkerContainer");
                    }
                });

                //used to edit the title description of the playback
                document.querySelector("#editPlaybackTitleDescriptionButton").addEventListener("click", function(e) {
                    
                    //get the button that was clicked
                    var button = e.target;
                    
                    //get references to the containers that hold the title and description
                    var playbackTitleEditable = document.querySelector("#playbackTitleEditable");
                    var playbackDescriptionEditable = document.querySelector("#playbackDescriptionEditable");

                    //if this is a save operation
                    if(button.innerHTML === "Save changes") {

                        //change the text on the button to enable editing
                        button.innerHTML = "Edit title/description";
                        button.classList.add("btn-default");
                        button.classList.remove("btn-primary");
                        
                        //make both divs uneditable
                        playbackTitleEditable.setAttribute("contentEditable", false);
                        playbackDescriptionEditable.setAttribute("contentEditable", false);
                        
                        //get the simple text for the title
                        var title = playbackTitleEditable.textContent;
                        //get the markup for the description
                        var description = playbackDescriptionEditable.innerHTML;

                        //make a call to the server to update the title and description
                        updatePlaybackDescriptionInEditorsDB(title, description);

                        //set the title of the playback
                        document.querySelector("#playbackTitle").innerHTML = title;

                        //get the formatting controls
                        var descriptionFormatControls = document.querySelector("#descriptionFormatControls");
                        //make them invisible while the title/description are not editable
                        descriptionFormatControls.classList.add("hiddenUntilEditable");

                    } else { //this is an edit operation

                        //change the text on the button to make enable saving any changes
                        button.innerHTML = "Save changes";
                        button.classList.remove("btn-default");
                        button.classList.add("btn-primary");

                        //get the formatting controls
                        var descriptionFormatControls = document.querySelector("#descriptionFormatControls");
                        //make them visible while the title/description are not editable
                        descriptionFormatControls.classList.remove("hiddenUntilEditable");

                        //make both divs editable
                        playbackTitleEditable.setAttribute("contentEditable", true);
                        playbackDescriptionEditable.setAttribute("contentEditable", true);

                        //give the focus to the desription since this is likely to be updated
                        playbackDescriptionEditable.focus();
                    }
                });

                //indicates whether deleted files/dirs should be hidden in the file filter options
                document.querySelector("#hideDeletedDirsCheckbox").addEventListener("click", function(e) {

                    //get all of the deleted files and directory checkboxes
                    var allDeletedFileAndDirectoryCheckBoxes = document.querySelectorAll(".deletedFileOrDirectory");

                    //if the user wants to hide them
                    if(e.target.checked === true) {

                        //go through all of them
                        for(var i = 0;i < allDeletedFileAndDirectoryCheckBoxes.length;i++){

                            //hide by adding a class that makes them display: none
                            allDeletedFileAndDirectoryCheckBoxes[i].classList.add("deletedFileOrDirectoryNotVisible");
                        }

                    } else { //the user want to see the deleted files and directories

                        //go through them all
                        for(var i = 0;i < allDeletedFileAndDirectoryCheckBoxes.length;i++){

                            //show them by removing the class that hides them
                            allDeletedFileAndDirectoryCheckBoxes[i].classList.remove("deletedFileOrDirectoryNotVisible");
                        }
                    }
                });

                //wire the button to use the current event's timestamp as a start time
                document.querySelector("#useCurrentEventStartTimeButton").addEventListener("click", function(e) {

                    //if there are any events in the playback
                    if(playbackData.codeEvents.length > 0) {

                        var currEvent;

                        //if the playback has been started
                        if(playbackData.codeEventsIndex >= 0) {

                            //get the current event
                            currEvent = playbackData.codeEvents[playbackData.codeEventsIndex];

                        } else { //no movement in the playback

                            //use the first event
                            currEvent = playbackData.codeEvents[0];                        
                        }

                        //get the time from the event and display it
                        document.querySelector("#startTimeInput").value = formatDateShortWithDayOfWeek(new Date(currEvent.timestamp));
                    }                    
                });

                //wire the button to use the current event's timestamp as an end time
                document.querySelector("#useCurrentEventEndTimeButton").addEventListener("click", function(e) {

                    //if there are any events in the playback
                    if(playbackData.codeEvents.length > 0) {

                        var currEvent;

                        //if the playback has been started
                        if(playbackData.codeEventsIndex >= 0) {

                            //get the current event
                            currEvent = playbackData.codeEvents[playbackData.codeEventsIndex];

                        } else { //no movement in the playback

                            //use the first event
                            currEvent = playbackData.codeEvents[0];                        
                        }

                        //get the time from the event and display it
                        document.querySelector("#endTimeInput").value = formatDateShortWithDayOfWeek(new Date(currEvent.timestamp));
                    }                    
                });

                //add a time span to the group of time spans
                document.querySelector("#addTimeFilterButton").addEventListener("click", function(e) {
            
                    //get the times from the text boxes 
                    var startTime = new Date(document.querySelector("#startTimeInput").value);
                    var endTime = new Date(document.querySelector("#endTimeInput").value);

                    //if the dates are incorrect
                    if(startTime === NaN) {
                        console.log("Error with the start time");

                        //use a start date a long time in the past
                        startTime = new Date(0);
                    }

                    if(endTime === NaN) {
                        console.log("Error with the end time");

                        //use right now as the end date
                        endTime = new Date();
                    }

                    //add a row to the table that lists all of the selected timeframes
                    addFilteredTimeFrame(startTime, endTime);
                });

                //collect the user's filter info and start filtering
                document.querySelector("#filterButton").addEventListener("click", function(e) {

                    //these are the filter parameters
                    var timeFilters = [];
                    var devGroupFilter = null;
                    var fileDirFilter = null;

                    //time filtering
                    //get all the rows from the table with selected time frames
                    var filterTimeFrames = document.querySelectorAll(".filterTimeframe");
                    
                    //go through each selected time frame
                    for(var i = 0;i < filterTimeFrames.length;i++) {
                        
                        //get time from the table (pos 0 is a delete button, 1 is the start time, 2 is the end time)
                        var startTime = filterTimeFrames[i].children[1];
                        var endTime = filterTimeFrames[i].children[2];

                        //convert the strings to epoch vals
                        var epochStartTime = Date.parse(startTime.innerHTML);
                        var epochEndTime = Date.parse(endTime.innerHTML);
                        
                        //bump up the end time to get the last ms in the selected time's second value
                        epochEndTime = epochEndTime + (999 - (epochEndTime % 1000));

                        //create a time filter object that holds the requested start and end time
                        var timeFilter = {
                            startTimestamp: epochStartTime,
                            endTimestamp: epochEndTime
                        };

                        //add each time filter to the collection
                        timeFilters.push(timeFilter);
                    }


                    //developer filtering
                    //get all of the selected dev group checkboxes
                    var allSelectedDevGroupCheckboxes = document.querySelectorAll(".devGroupSelectCheckbox:checked");

                    //holds the values of the selected dev group checkboxes
                    var selectedDevGroupIds = [];

                    //go through the checkboxes
                    for(var i = 0;i < allSelectedDevGroupCheckboxes.length;i++) {

                        //get the developer group id from the value of the checkbox and store it
                        selectedDevGroupIds.push(allSelectedDevGroupCheckboxes[i].value);
                    }

                    //if there were some dev groups selected
                    if(selectedDevGroupIds.length > 0) {

                        //create an object with all of the selected dev group ids
                        devGroupFilter = {
                            devGroupIds: selectedDevGroupIds
                        };
                    }


                    //file filtering
                    //get all of the selected file and dir checkboxes and add the file ids to the filter object
                    var allSelectedFilesAndDirCheckboxes = document.querySelectorAll(".filterCheckBox:checked");

                    //holds the values of the selected file/dir checkboxes
                    var selectedFileAndDirIds = [];

                    //go through the checkboxes
                    for(var i = 0;i < allSelectedFilesAndDirCheckboxes.length;i++) {

                        //get the file/dir id from the value of the checkbox and store it
                        selectedFileAndDirIds.push(allSelectedFilesAndDirCheckboxes[i].value);
                    }

                    //if there were some files/dirs selected
                    if(selectedFileAndDirIds.length > 0) {

                        //create an object with all of the selected file/dir ids
                        fileDirFilter = {
                            fileDirIds: selectedFileAndDirIds
                        };
                    }

                    //if the user wants to see the selected text as well
                    var showSelectedText = document.querySelector("#selectedTextCheckbox").checked;
                    //if the user wants to use other filters in addition to the selected text 
                    var showSelectedTextWithOtherFilters = document.querySelector("#withOtherFiltersRadio").checked;

                    //determines if we should show relevant cut/copies/pastes
                    var showRelevantCutCopyPastes = document.querySelector("#showRelevantCutCopyPastesCheckbox").checked;

                    //collect the info about the filters
                    var filterInfo = {
                        timeFilters: timeFilters,
                        devGroupFilter: devGroupFilter,
                        fileDirFilter: fileDirFilter,
                        showSelectedText: showSelectedText,
                        showSelectedTextWithOtherFilters: showSelectedTextWithOtherFilters,
                        showRelevantCutCopyPastes: showRelevantCutCopyPastes
                    };
                    
                    //reset the window for a new playback
                    getPlaybackWindowsReadyForAnimation(false);

                    //filter the playback data to mark some of the code as relevant
                    filterPlayback(filterInfo);

                    //clear any highlighted text
                    clearSelectedCode();

                    //reset the event counts
                    document.querySelector("#relevantEventCountDiv").innerHTML = "0/" + playbackData.numberOfRelevantEvents;
                    document.querySelector("#totalEventCountDiv").innerHTML = "0/" + playbackData.codeEvents.length;
                });

                //used to turn this back into an unfiltered playback
                document.querySelector("#clearFilterButton").addEventListener("click", function(e) {

                    //remove the property that states whether an event is relevant or not (the events in a brand new playback do not have this property)
                    clearFiltering();

                    //reset the entire playback
                    getPlaybackWindowsReadyForAnimation(true);
                });

                //to get a zip with the state of the file system
                document.querySelector("#saveStateOfFilesButton").addEventListener("click", function(e) {

                    //pause the playback if it is not already paused
                    pausePlayback();
                    
                    //if there are any events that have been played on the screen
                    if(playbackData.codeEventsIndex >= 0) {
                    
                        //get the type of playback
                        var typeOfSave = document.querySelector("input[name='saveStateRadios']:checked").value;

                        //indicates whether the comments should be saved in the downloaded playback or removed
                        var saveComments = !document.querySelector("#removeCommentsCheckbox").checked;

                        //the playback is paused at a single event. Save the state of the files/dirs, the playbackData.json, 
                        //and editorState.json files at this point in a zip file. A user can unzip and open the root dir
                        //and begin from the pause point. There are three different types of saved files 
                        saveStateOfPlaybackAtPausePoint(typeOfSave, saveComments);

                    } else {

                        //TODO notify user there is nothing to zip
                        console.log("Nothing to zip up");
                    }
                });

                //merge with another playbackData file
                document.querySelector("#mergeButton").addEventListener("change", function(e) {

                    //pause the playback if it is not already paused
                    pausePlayback();

                    //get the file from the file input
                    var uploadedFile = this.files[0];

                    //create a reader to read the data
                    var fileReader = new FileReader();

                    //once the data is done being read
                    fileReader.onload = function(data){

                        //get the selected playback.json file
                        var playbackDataBranch2 = JSON.parse(data.target.result);
                        
                        //send it to the merge function
                        storytellerMerge(playbackDataBranch2);
                    };

                    //begin the read operation (as text)
                    fileReader.readAsText(uploadedFile);
                    
                });
                
                //to add a comment
                document.querySelector("#addCommentButton").addEventListener("click", function(e) {

                    //if the playback is paused, we can make a comment
                    if(playbackData.playbackState === "paused") {

                        //get the text area
                        var textCommentTextArea = document.querySelector("#textCommentTextArea");

                        //get the comment text
                        var commentText = textCommentTextArea.innerHTML;
                        if(commentText) {
                            commentText = commentText.trim();
                        }

                        //get any selected text ids if there are any
                        var selectedCodeIds = getSelectedCodeIds();

                        //an array of images to go along with this comment
                        var commentImages = [];

                        //get the selected comment images
                        var selectedImageCheckBoxes = document.querySelectorAll(".selectedCommentImage:checked");
                        for(var i = 0;i < selectedImageCheckBoxes.length;i++) {

                            //get the image id from the checkbox
                            var imgId = selectedImageCheckBoxes[i].getAttribute("value");

                            //use the image id to retrieve the image object
                            commentImages.push(images[imgId]);
                        }
                        
                        //if there was some text for a comment, some selected text, at least one image, or one video comment
                        if(commentText.length > 0 || selectedCodeIds.length > 0 || 
                           commentImages.length > 0 || globalVideoComments.length > 0) {

                            //clear out the text area
                            textCommentTextArea.innerHTML = "";

                            //clear the previously selected code
                            clearSelectedCode();

                            //get each potential video clip control and revoke the object url
                            revokePotentialVideoComments()

                            //clear out the actual video control elements
                            videoCommentClips = document.querySelector("#videoCommentClips");
                            videoCommentClips.innerHTML = "";

                            //playbackData.codeEventsIndex starts at -1 and is incremented every step forward
                            //this ? is to account for comments before any events are played back
                            var eventIndex = playbackData.codeEventsIndex >= 0 ? playbackData.codeEventsIndex : 0

                            //if we are moving backwards move the event index forward to account for the
                            if(playbackData.mostRecentDirection === "backward" && eventIndex > 0) {
                                eventIndex--;
                            }

                            //get the event to playback this comment
                            var commentEvent = playbackData.codeEvents[eventIndex];

                            //create an object that has all of the comment info
                            var comment = {
                                displayCommentEvent: commentEvent,
                                developerGroupId: playbackData.currentDevGroupId, 
                                timestamp: new Date().getTime(),
                                commentText: commentText,
                                selectedCodeIds: selectedCodeIds,
                                images: commentImages,
                                videoComments: globalVideoComments
                            };

                            //clear out the reference to the video clips to get ready for the next comment
                            globalVideoComments = [];

                            //if there is not an array to hold comments on this event
                            if(!playbackData.comments[commentEvent.id]) {

                                //create an empty array to hold comments keyed by the comment event
                                playbackData.comments[commentEvent.id] = [];
                            }

                            //add the comment to the array of comments for this particular event
                            playbackData.comments[commentEvent.id].push(comment);

                            //attempt to add the comment to the server 
                            addCommentInEditorsDB(comment);

                            //get the collection of images that will be added to the comment
                            var commentImagesInComment = document.querySelector("#commentImagesInComment");
                            //clear the images in comment
                            commentImagesInComment.innerHTML = "";

                            //add a comment marker for the new comment in the progress bar
                            //setCommentMarker(eventIndex, playbackData.codeEvents.length, commentEvent.id);
                            setCommentMarker(playbackData.relevantEventIndex - 1, playbackData.numberOfRelevantEvents, commentEvent.id);

                            //display all the comments (do not scroll to the top)
                            displayComments(commentEvent.id, false);

                            //higlight any code that was highlighted for the comment
                            focusOnHighlightedCommentCode(comment);
                        }
                        //else- no text or selected code, we can't make a comment
                    }
                    //else- playback is playing, can't comment while the playback is moving
                });

                document.querySelector("#enableVideoCommentsCheckbox").addEventListener("click", function(e) { 

                    //get the div that holds the video controls                    
                    var previewVideoControls = document.querySelector("#previewVideoControls");

                    //if video comments are being enabled
                    if(e.target.checked) {

                        //if the user chooses to enable video comments, set up the media recorder
                        setUpVideoRecordingOfComments();

                        //make the video controls visible
                        previewVideoControls.classList.remove("hiddenUntilEditable");

                    } else { //video is being disbaled

                        //turn off the web cam
                        tearDownVideoRecordingOfComments();

                        //hide the video controls
                        previewVideoControls.classList.add("hiddenUntilEditable");
                    }
                });

                //add a click handler to control recording
                document.querySelector("#addNewVideoComment").addEventListener("click", function(e) {

                    //get the button that was pressed                
                    var videoRecordButton = e.target;

                    //get the recording icon next to the text
                    var recordingIcon = document.querySelector("#videoRecordingStateIcon");

                    //if the media recorder is in the recording state
                    if(mediaRecorder.state === "recording") {

                        //set the text of the button from 'Stop Recording' to 'Start Recording' (keep the span next to the text in the button) 
                        videoRecordButton.innerHTML = "Start Recording";

                        //make the notification stop blinking with this class
                        recordingIcon.classList.remove("videoButtonRecording");
                        recordingIcon.innerHTML = "Not Recording";

                        //stop recording
                        mediaRecorder.stop();

                    } else { //we are in the idle state

                        //set the text of the button from 'Start Recording' to 'Stop Recording' (keep the span next to the text in the button) 
                        videoRecordButton.innerHTML = "Stop Recording";                        

                        //make the notification blink with this class
                        recordingIcon.classList.add("videoButtonRecording");
                        recordingIcon.innerHTML = "Recording";

                        //start the recording process
                        mediaRecorder.start();
                    }                    
                });

                document.querySelector("#commentDrawingModal").addEventListener("paste", function(e) {

                    //get the clipboard data from the paste event
                    var clipboard = e.clipboardData;

                    //if there is at least one item and it is a file
                    if(clipboard.items.length > 0 && clipboard.items[0].kind === "file") {
                        
                        //attempt to load the image on the canvas
                        importImageIntoCanvas(clipboard.files[0]);
                    }
                });

                document.querySelector("#commentDrawingModal").addEventListener("drop", function(e) {
                    
                    //get the data 
                    var dt = e.dataTransfer;
                    
                    //if the browser supports DataTransferItemList
                    if (dt.items) {

                        //we only support dropping a single file (make sure there is at least one)
                        if (dt.items.length > 0 && dt.items[0].kind === "file") {

                            //get the first file
                            var imageFile = dt.items[0].getAsFile();

                            //load the image on the canvas
                            importImageIntoCanvas(imageFile);
                        }

                    } else { //the broswer supports DataTransfer
                        
                        //if there is at least one file
                        if (dt.files.length > 0) {

                            //load the image on the canvas
                            importImageIntoCanvas(dt.files[0]);
                        }  
                    }              

                    e.preventDefault();
                });

                document.querySelector("#commentDrawingModal").addEventListener("dragover", function(e) {
                    
                    //prevent default browser behavior
                    e.preventDefault();
                });
                
                document.querySelector("#commentDrawingModal").addEventListener("dragend", function(e) {

                    //get the data transfer                     
                    var dt = e.dataTransfer;

                    //using DataTransferItemList
                    if (dt.items) {  
                        
                        //remove the drag items
                        for (var i = 0; i < dt.items.length; i++) {

                            dt.items.remove(i);
                        }

                    } else { //using DataTransfer
                        
                        //remove the drag data
                        ev.dataTransfer.clearData();
                    }                    
                });
                
                //save a playback
                document.querySelector("#savePlaybackButton").addEventListener("click", function(e) {

                    //create a blob with the playback data in it in json
                    var blob = new Blob([JSON.stringify(playbackData, null, 2)], {type : 'application/json'});

                    //make a data url out of the blob (this is a downloadable piece of data from a link)
                    var dataURL = window.URL.createObjectURL(blob);

                    //create a temp, invisible anchor and add it to the page
                    var a = document.createElement("a");
                    document.body.appendChild(a);
                    a.style = "display: none";

                    //assign the new with zip data url to the anchor
                    a.href = dataURL;

                    //add a name to the zip
                    a.download = "playback.json";

                    //simulate a click of the button
                    a.click();

                    //clean up the resources for the url
                    window.URL.revokeObjectURL(dataURL);
                    
                    //remove the anchor
                    a.remove();
                });

                //upload a playback from a previously downloaded json file
                document.querySelector("#uploadPlaybackButton").addEventListener("change", function(e) {

                    //get the file from the file input
                    var uploadedFile = this.files[0];

                    //create a reader to read the data
                    var fileReader = new FileReader();

                    //once the data is done being read
                    fileReader.onload = function(data){

                        //get the text of the file and turn it into json                        
                        //store the playback data from the file
                        playbackData = JSON.parse(data.target.result);

                        //re-init the playback
                        getPlaybackWindowsReadyForAnimation(true);
                    };

                    //begin the read operation (as text)
                    fileReader.readAsText(uploadedFile);
                });

                //clear the drawing canvas
                document.querySelector("#clearCommentImageButton").addEventListener("click", function(e) {

                    //clear the image completely from the canvas
                    clearCanvasImage();
                    
                });

                //use the drawing in a comment and save it to build on later
                document.querySelector("#useImageInACommentButton").addEventListener("click", function(e) {

                    //use the image in the canvas for a comment
                    useImageInAComment();
                });

                //import an image onto the comment drawing canvas
                document.querySelector("#importImageButton").addEventListener("change", function(e) {

                    //get the selected file from the file input control
                    var imageFile = this.files[0];

                    //import the imae into the canvas
                    importImageIntoCanvas(imageFile);

                });

                //undo a drawn line
                document.querySelector("#undoDraw").addEventListener("click", function(e) {
                    
                    //undo a drawn line
                    undoADrawnLine();
                });

                document.querySelector("#redoDraw").addEventListener("click", function(e) {

                    //redo a drawn line
                    redoADrawnLine();
                });

                //change the pen color
                document.querySelector("#bluePen").addEventListener("click", function(e) {
                    
                    //set the pen color
                    setPenColor("blue", e.target);

                });

                //change the pen color
                document.querySelector("#blackPen").addEventListener("click", function(e) {
                    
                    //set the pen color
                    setPenColor("black", e.target);

                });

                //change the pen color
                document.querySelector("#whitePen").addEventListener("click", function(e) {
                    
                    //set the pen color
                    setPenColor("white", e.target);

                });

                //change the pen color
                document.querySelector("#redPen").addEventListener("click", function(e) {
                    
                    //set the pen color
                    setPenColor("red", e.target);

                });

                //change the pen size
                document.querySelector("#extraLargePen").addEventListener("click", function(e) {
                    
                    //set the pen width
                    setPenWidth(17, e.target);
                });

                //change the pen size
                document.querySelector("#largePen").addEventListener("click", function(e) {
                    
                    //set the pen width
                    setPenWidth(7, e.target);
                });
                
                //change the pen size
                document.querySelector("#mediumPen").addEventListener("click", function(e) {

                   //set the pen width
                    setPenWidth(4, e.target);
                });

                //change the pen size
                document.querySelector("#smallPen").addEventListener("click", function(e) {
                    
                   //set the pen width
                    setPenWidth(2, e.target);
                });

                //when some code is selected
                document.querySelector("#playbackWindows").addEventListener("mouseup", function(e) {
                    
                    //mark the selected code
                    markSelectedCode();
                });
                
                //additional listeners to listen for the ctrl or command key presses (used for multiple selections in the playback wondows)
                document.addEventListener("keydown", function (e) {

                    //if ctrl or cmd are pressed
                    if(e.key === "Control" || e.key === "Command" || e.ctrlKey || e.metaKey) {
                        ctrlCmdPressed = true;
                        //console.log("Ctrl pressed");
                    }
                });
                document.addEventListener("keyup", function (e) {

                    //if ctrl or cmd are pressed
                    if(e.key === "Control" || e.key === "Command" || e.ctrlKey || e.metaKey) {
                        ctrlCmdPressed = false;
                        //console.log("Ctrl released");
                    }
                });    
            }
            
            /*
             * Adds a time frame to the table of selected filtered timeframes
             */
            function addFilteredTimeFrame(startTime, endTime) {

                //get the table with all of the selected time filters
                var userSelectedTimeSpans = document.querySelector("#userSelectedTimeSpans");

                //add a new row to the table that holds all of the selected time frames
                var timeFrameRow = userSelectedTimeSpans.insertRow();
                timeFrameRow.classList.add("filterTimeframe");

                //button to delete the time frame
                var deleteTimeFrameButton = timeFrameRow.insertCell(0);
                var deleteAnchor = document.createElement("a");
                deleteAnchor.href="#";
                deleteAnchor.innerHTML = "&times";
                deleteAnchor.addEventListener("click", function(e) {
                    
                    //delete the row that this button is on
                    userSelectedTimeSpans.deleteRow(timeFrameRow.rowIndex);
                });
                deleteTimeFrameButton.appendChild(deleteAnchor);

                //display the start time
                var startTimeTD = timeFrameRow.insertCell(1);
                startTimeTD.classList.add("startTimeFrame");
                startTimeTD.innerHTML = formatDateShortWithDayOfWeek(startTime);

                //display the end time
                var endTimeTD = timeFrameRow.insertCell(2);
                endTimeTD.classList.add("endTimeFrame");
                endTimeTD.innerHTML = formatDateShortWithDayOfWeek(endTime);
            }

            //*****************************************************************************
            //                         playback window related code
            //                         ----------------------------
            // This code has to do with adding characters on the playback window
            //*****************************************************************************
            /*
             * Used to get the playback window ready for animating code. There are two types
             * of preparation. If the user wants a complete intitialization (or re-init) then
             * all the playback windows will be wiped out (after uploading a new playback or
             * clearing all filters). If the user has added a new filter then a partial 
             * re-init will happen.
             * 
             * - reset the playback object's data to get ready for a new playback
             * - add an initial span for all 'first' characters in the file to go in front of
             * - add an invisible last span to always have the playback window take up some space
             * - preload all the insert spans to the screen and make them not visible
             */
            function getPlaybackWindowsReadyForAnimation(shouldInitialize) {

                //reset some playback information
                playbackData.codeEventsIndex = -1;
                playbackData.mostRecentDirection = "forward";
                playbackData.relevantEventIndex = 0;
                playbackData.playbackState = "paused";
                playbackData.playbackTimerId = null;
                playbackData.activeFileId = null;
                playbackData.activeLineNumber = null;
                playbackData.latestPlaybackEventDevGroupId = null;
                
                //set the slider back to the beginning and empty the timestamp
                var playbackProgressBar = document.querySelector("#playbackProgressBar");
                playbackProgressBar.setAttribute("style", "width:0%");
                playbackProgressBar.innerHTML = "";


                //empty the timestamp info
                document.querySelector("#relevantEventCountDiv").innerHTML = "";
                document.querySelector("#totalEventCountDiv").innerHTML = "";
                document.querySelector("#eventTypeDiv").innerHTML = "";
                document.querySelector("#eventInfoDiv").innerHTML = "";
                document.querySelector("#timestampDiv").innerHTML = "";

                //add an avatar to take up space in the UI
                var anonDevImage = document.createElement("img");
                anonDevImage.setAttribute("src", "http://www.gravatar.com/avatar/anon?s=50&d=mm");
                anonDevImage.setAttribute("alt", "Developer Info");
                anonDevImage.classList.add("img-thumbnail");

                //add the avatar
                var eventDevInfo = document.querySelector("#eventDevInfo")
                eventDevInfo.innerHTML = "";
                eventDevInfo.appendChild(anonDevImage);


                //filter start and end time
                var startDateTime;
                var endDateTime = new Date();

                //if there are some code events
                if(playbackData.codeEvents.length > 0) {

                    //get the time of the first event and populate the text inputs
                    startDateTime = new Date(playbackData.codeEvents[0].timestamp);

                } else { //no events

                    //use the current time for both inputs just to show something
                    startDateTime = endDateTime;
                }

                //display the start and end time of events for filtering
                //set the time of the two time filter inputs
                document.querySelector("#startTimeInput").value = formatDateShortWithDayOfWeek(startDateTime);
                document.querySelector("#endTimeInput").value = formatDateShortWithDayOfWeek(endDateTime);
                
                //clear out any selected time frames
                var userSelectedTimeSpans = document.querySelector("#userSelectedTimeSpans");

                //we want to keep the first row because it is a row of headers
                while(userSelectedTimeSpans.rows.length > 1) {

                    //remove the last row
                    userSelectedTimeSpans.deleteRow(userSelectedTimeSpans.rows.length - 1);
                }

                //add the default time filter
                addFilteredTimeFrame(startDateTime, endDateTime);

                //if there are some developer groups display them in the filter section
                displayAllDevGroupMembersForFiltering();

                //display a view of the file system for file filtering
                displayFileSystemForFiltering();

                //empty the view of the file system (this gets built up during playback)
                document.querySelector("#playbackViewOfFileSystem").innerHTML = "";

                //clear any previous comments that are displayed
                clearPreviousComment();

                //if we want to completely reinitialize a playback
                if(shouldInitialize === true) {

                    //init some playback data
                    playbackData.delay = 100;
                    playbackData.highlightDelay = 300;
                    playbackData.showPastesInABlock = false;
                    playbackData.showRecentsChanges = true;
                    playbackData.userWantsPauseOnComments = true;

                    //add the formatting toolbar for all new comments
                    var commentFormatToolbar = document.querySelector("#commentFormatToolbar");
                    //get rid of any old toolbar
                    commentFormatToolbar.innerHTML = "";
                    commentFormatToolbar.appendChild(makeATextEditToolbar());

                    //add the formatting toolbar for the description
                    var descriptionFormatToolbar = document.querySelector("#descriptionFormatToolbar");
                    //get rid of any old toolbar
                    descriptionFormatToolbar.innerHTML = "";
                    descriptionFormatToolbar.appendChild(makeATextEditToolbar());
                    
                    //empty out any old playback windows
                    document.querySelector("#playbackWindowTabLinks").innerHTML = "";
                    document.querySelector("#playbackWindows").innerHTML = "";

                    //update the title and description of this playback
                    document.querySelector("#playbackTitle").textContent = playbackData.playbackDescription.title;
                    document.querySelector("#playbackTitleEditable").textContent = playbackData.playbackDescription.title;
                    //get the editable playback description
                    var playbackDescriptionEditable = document.querySelector("#playbackDescriptionEditable");
                    //if there is no description from the playback data
                    if(playbackData.playbackDescription.description === "") {
                        
                        //put some default text in the editable
                        playbackDescriptionEditable.innerHTML = "Put a playback description here"

                    } else { //there is a description from the playback data

                        //put the description in the editable
                        playbackDescriptionEditable.innerHTML = playbackData.playbackDescription.description;

                        //make the full title/description visible in the playback
                        document.querySelector("#playbackDescriptionPanel").classList.add("in");
                    }

                    //take the images from the comments and add them to the starting image gallery
                    displayCommentImagesInGallery();

                    //clear out the number of relevant events (we'll count them below)
                    playbackData.numberOfRelevantEvents = 0;

                    //holds the positions and ids of all of the comment points
                    var posOfComments = [];

                    //go through all of the code and pre-load the playback window with spans that hold
                    //the code to display. Each code event knows the id of its previous neighbor and
                    //will be displayed immediately after a span with that id. There is a style that
                    //will make the code invisible by default. The playback is animated by going through
                    //the code events removing the style so that the code will show up.

                    //the benefit of pre-loading the playback window with all of the spans is that it makes
                    //animating the code easy (no DOM adds/removes during playback), just adding and removing
                    //styles to spans. This makes the code for going forward and backward through the code 
                    //simpler (especially backward).

                    //go through all of the events
                    for(var i = 0;i < playbackData.codeEvents.length;i++) {

                        //the default is to set all of the events that don't have an explicit relevant value
                        //to true in a fresh playback. If this is a saved filtered playback some events may
                        //already have this member. If not, set it to relevant here
                        if(playbackData.codeEvents[i].permanentRelevance === "never relevant") {
                        
                            playbackData.codeEvents[i].relevant = false;

                        } else if(playbackData.codeEvents[i].relevant === undefined) {

                            playbackData.codeEvents[i].relevant = true;

                        } //else- the event has a relevant member already, this data came from a saved, filtered playback

                        //if the event is relevant
                        if(playbackData.codeEvents[i].relevant) {

                            //increase the number of relevant events to keep track of where the user is in a playback
                            playbackData.numberOfRelevantEvents++;
                        } 

                        //if the code character is an insert
                        if(playbackData.codeEvents[i].type === "Insert") {

                            //add it to the file's playback window
                            addCharacter(playbackData.codeEvents[i], playbackData.codeEvents[i].fileId);

                        } else if(playbackData.codeEvents[i].type === "Create File") { //new file

                            //create a new tab to show the code
                            createFilePlaybackTab(playbackData.codeEvents[i].fileId, playbackData.codeEvents[i].initialName);
                        }

                        //if there is a comment at this event (there may be multiple comments but we only need to know the index of the event)
                        if(playbackData.comments[playbackData.codeEvents[i].id]) {

                            //store the index of the event and the id of the event where the comment will be displayed
                            posOfComments.push({"pos": playbackData.numberOfRelevantEvents - 1, eventId: playbackData.codeEvents[i].id});
                        }
                    }

                    //reset the event counts
                    document.querySelector("#relevantEventCountDiv").innerHTML = "0/" + playbackData.numberOfRelevantEvents;
                    document.querySelector("#totalEventCountDiv").innerHTML = "0/" + playbackData.codeEvents.length;

                    //add a marker to show where each comment it
                    setCommentMarkers(posOfComments, playbackData.numberOfRelevantEvents);

                } else { //do not need to reinitialize the whole playback, we just want to start an existing playback over again

                    //get all of the code elements that are visible on the screen
                    var allVisibleCodeElements = document.querySelectorAll(".codeChar:not(.codeNotVisible)");

                    //go through the visible elements and make them invisible
                    for(var i = 0;i < allVisibleCodeElements.length;i++) {

                        //add a style that will hide them
                        allVisibleCodeElements[i].classList.add("codeNotVisible");
                    }

                    //for each file that is displayed, empty out any old line numbers and add the first line number
                    var allLineNumberGutters = document.querySelectorAll(".lineNumberGutter");

                    for(var i = 0;i < allLineNumberGutters.length;i++) {

                        //make a single line number in each playback window tab
                        allLineNumberGutters[i].innerHTML = "<div class='lineNum'></div>";
                    }

                    //hide all of the playback windows
                    //get all of the links to the playback window tabs
                    var allplaybackWindowTabLinks = document.querySelectorAll("#playbackWindowTabLink");

                    for(var i = 0;i < allplaybackWindowTabLinks.length;i++) {

                        //make the tabs 'invisible' by adding a class (not really invisible just styled differently)
                        allplaybackWindowTabLinks[i].classList.add("playbackTabNotVisible");
                    }
                }
            }

            /*
             * This function adds markers to the progress bar to show where comments are in the playback.
             */
            function setCommentMarkers(posOfComments, numberOfRelevantEvents) {

                //get the container that will hold the markers
                var commentMarkerContainer = document.querySelector("#commentMarkerContainer");

                //clear out the old comment markers
                commentMarkerContainer.innerHTML = "";

                //go through each comment position
                for(var i = 0;i < posOfComments.length;i++) {

                    //add a comment marker
                    setCommentMarker(posOfComments[i].pos, numberOfRelevantEvents, posOfComments[i].eventId);
                }
            }

             /*
             * This function adds a marker to the progress bar to show where a comments is in the playback.
             */
            function setCommentMarker(posOfComment, numberOfRelevantEvents, eventId) {

                //get the container that will hold the markers
                var commentMarkerContainer = document.querySelector("#commentMarkerContainer");

                //calculate the percentage offset for every comment
                var percentageOffset = (posOfComment + 1.0) / numberOfRelevantEvents * 100.0;
                
                //comments near the 100% mark do not show up well in the progress bar, bring all the ones
                //near the end back a bit so that the marker is visible
                if(percentageOffset > 99.75) {

                    //set to near the end
                    percentageOffset = 99.75;
                }

                //create a div
                var commentMarker = document.createElement("div");
                commentMarker.innerHTML = "&nbsp;"
                //make it a comment marker
                commentMarker.classList.add("commentMarker");

                //set the left offset to the percentage caluclated above
                commentMarker.setAttribute("style", "left:" + percentageOffset + "%");
                commentMarker.setAttribute("id", "commentPos_" + eventId);
                //add the marker to the div
                commentMarkerContainer.appendChild(commentMarker);

                // <div class="progress" id="progressBarContainer">
                //     <div class="progress-bar progress-bar-success" id="playbackProgressBar" style="width:0%">
                //     </div>
                //
                //     <!-- used to show where comments are in the playback, absolute layout relative to parent -->
                //     <div id="commentMarkerContainer">
                //     </div>
                // </div>
            }

            /*
             * Adds a character to the playback window. It creates a new element (either a <span>
             * for code characters and a <br> for new line characters) and sets the id to
             * be the id of the code event.
             *
             * To place it on the screen it looks at the id of the code event's previous
             * neighbor and finds a span with that id. It then inserts a new element right
             * after that.
             *
             * All code elements are added to the playback window once before the animation starts.
             * They are hidden initially. Once the events are played back they will be made
             * visible and show up on the screen.
             */
            function addCharacter(code, fileId) {

                //new element (either a <span> for code or a <br> for newlines) to put in
                //the playback window
                var newElement;

                //if the code character is a newline
                if(code.character === "\n") {

                    //create a <br> object with the character id and a newLine class
                    //when this is played back it will become visible and the current
                    //line of code will end
                    newElement = document.createElement("br");
                    newElement.setAttribute("id", code.id);
                    newElement.classList.add("newLine");

                } else { //non-newline (tab or code)

                    //create a <span> object with the character id as its id
                    newElement = document.createElement("span");
                    newElement.setAttribute("id", code.id);

                    //if the code character is part of a windows CRLF
                    if(code.character === "\r") {

                        //mark it as \r
                        newElement.classList.add("slash-r");
                        //make the span empty so it is not selectable anymore
                        newElement.innerHTML = "";
                        
                    } else if(code.character === "\t") { //if its a tab

                        //add a tab class
                        newElement.classList.add("tab");

                        //add some spaces for each tab
                        newElement.innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;"

                    } else if(code.character === " ") { //its a single space

                        //add a space class
                        newElement.classList.add("space");

                        //add a visible space
                        newElement.innerHTML = "&nbsp;"

                    } else { //visible character

                        //add the single code character to the span
                        newElement.appendChild(document.createTextNode(code.character));
                    }
                }

                //identify all code characters
                newElement.classList.add("codeChar");

                //default all code elements to not be visible initially. This class will
                //be removed when it is 'played back'
                newElement.classList.add("codeNotVisible");


                //add the code element to the playback window
                //holds the code's previous neighbor element
                var previousElement;
                
                //if the code event has a previous neighbor id
                if(code.previousNeighborId !== "none") {

                    //find the previous neighbor element
                    previousElement = document.querySelector("#" + code.previousNeighborId);

                } else { //no previous neighbor (this is the first character in the file)

                    //use the first span in the file as a previous neighbor
                    previousElement = document.querySelector("#firstSpan-" + fileId);
                }

                //debug- if there is no previous element
                if(!previousElement) {
                    console.log("There is not previous element at all!!!");
                }

                //add the new element right after the previous element (there is no insertAfter)
                previousElement.parentNode.insertBefore(newElement, previousElement.nextSibling);
            }
            
            //*****************************************************************************
            //                         Animation related code
            //                         ----------------------
            // This code has to do with animating the adding and removing of code in the
            // playback window. This is playback.
            //*****************************************************************************
            /*
             * Toggle between playing and pausing. The state ("playing" or "paused") is kept
             * in the main playbackData object.
             */
            function togglePlayPause() {

                //if the playback is in a playing state
                if(playbackData.playbackState === "playing") {

                    //pause the playback
                    pausePlayback();

                } else if(playbackData.playbackState === "paused"){ //the playback is paused

                    //start playing the playback
                    playPlayback();
                }
            }

            /*
             * This is a function that will start an animated playback
             */
            function playPlayback() {

                //change the button to allow pausing the playback
                playPauseButton.innerHTML = "Pause";

                //start playing the playback
                playbackData.playbackState = "playing";

                //create a timer to animate the next step with a call to timedPlayback() after a delay 
                playbackData.playbackTimerId = window.setTimeout(timedPlayback, playbackData.delay);

                //clear the all the new event highlights since the the last pause point
                clearPreviousEventHighlights();
            }

            /*
             * This function will be called every playbackData.delay ms during the playing state.
             * When the end of the playback is reached it will automatically stop.
             * If the requested delay ever hits 0 it will jump right to the end in one big step.
             */
            function timedPlayback() {

                //if there are no more events to play back
                if(playbackData.relevantEventIndex === playbackData.numberOfRelevantEvents) {

                    //stop the playback because its done
                    pausePlayback();

                } else if(playbackData.delay <= 0) { //if the delay is so small they don't want to see any animation

                    //step forward to the very end of the code (unless paused for a comment)
                    step("forward", playbackData.numberOfRelevantEvents, true);

                    //stop the playback
                    pausePlayback();

                } else { //normal playback operation

                    //take one step forward
                    step("forward", 1, true);

                    //if we haven't been interrupted by a comment
                    if(playbackData.playbackState === "playing") {

                        //create a timer to animate the next step with a call to this function after a delay
                        playbackData.playbackTimerId = window.setTimeout(timedPlayback, playbackData.delay);
                    }
                }
            }

            /*
             * This is a function that will pause playback,
             */
            function pausePlayback() {

                //change the text of the button to allow playing
                playPauseButton.innerHTML = "Play";

                //change the state of the playback
                playbackData.playbackState = "paused";

                //stop the automatic stepping of the playback
                window.clearTimeout(playbackData.playbackTimerId);

                //remove the timer id since it isn't needed anymore
                playbackData.playbackTimerId = null;
            }

            /*
             * Moves a playback forward or backward some number of steps. First it verifies the number of steps to
             * move is valid. Then it grabs the next relevant event from the playback data and handles it based on 
             * its type. If there is a comment the playback will stop for it (unless the user wishes to not pause on 
             * comments). The last event in the step will cause some changes to the UI like making the correct tab 
             * active and updating the file system view of the playback. At the last step we look forward to the next 
             * event in sequence to see if it has the same timestamp. If so, and the user wants to see cuts/pastes in 
             * a big block then it will move forward since events with the same timestamp are cuts/pastes.
             */
            function step(direction, numRelevantStepsRequested, pauseForComments) {

                //get the actual number of relevant steps to move
                numRelevantStepsRequested = getExactNumberOfRelevantStepsFromReqest(direction, numRelevantStepsRequested);

                //holds information about a step
                var stepData = {
                    codeEvent: null,	//holds the current code event that is being handled
                    codeElement: null,	//holds an element in the playback window to either show/hide
                    currentStep: 0		//holds the number of steps handled so far
                };

                //if there are any steps to playback after adjusting numRelevantStepsRequested
                if(numRelevantStepsRequested > 0) {
                    
                    //for each requested relevant step
                    while(stepData.currentStep < numRelevantStepsRequested) {
                        
                        //move the code event index forward/backward to move through the events before the animated step
                        //if we are continuing forward (either in a single large step or from a previous step)
                        if(playbackData.mostRecentDirection === "forward" && direction === "forward") {

                            //move forward to the next event in sequence
                            playbackData.codeEventsIndex++;

                        } else if(playbackData.mostRecentDirection === "backward" && direction === "backward") { //continuing backward

                            //move backward to the previous position
                            playbackData.codeEventsIndex--;

                        } else if(playbackData.mostRecentDirection === "forward" && direction === "backward") { //changing direction from forward to backward
                                                        
                            //store the most recent direction
                            playbackData.mostRecentDirection = "backward";  

                            //switch to going from forwards to backwards, don't change the playbackData.codeEventsIndex

                            //clear the comments
                            clearPreviousComment();

                        } else { //change of direction from backwards to forwards, no need to change the code events index
                
                            //store the most recent direction
                            playbackData.mostRecentDirection = "forward";                          
                        }

                        //get the next code event in sequence
                        var currentEvent = playbackData.codeEvents[playbackData.codeEventsIndex];
                        
                        //store it as part of the step data
                        stepData.codeEvent = currentEvent;

                        //progress either forward or backwards
                        if(direction === "forward") {

                            //display the event as if it were happening in the forward direction
                            handleEventForward(stepData);
                            
                            //if this event is relevant 
                            if(currentEvent.relevant) {

                                //we have moved to the next relevant event
                                playbackData.relevantEventIndex++;

                                //indicate that we have handled a relevant step
                                stepData.currentStep++;

                                //display comments (if there are any for this relevant event)
                                //if there are any comments for this event
                                if(playbackData.comments[currentEvent.id]) {

                                    //display the next comment
                                    displayComments(currentEvent.id, true);
                                    
                                    //if we are supposed to pause for comments
                                    if(pauseForComments && playbackData.userWantsPauseOnComments) {

                                        //pause the playback
                                        pausePlayback();

                                        //stop handling events after displaying a new set of comments
                                        break;
                                    }
                                }
                            }                                                        
                            
                        } else { //moving backwards

                            //display the event as if it were happening in the backward direction
                            handleEventBackward(stepData);

                            //if this is a relevant event
                            if(stepData.codeEvent.relevant) {

                                //we have moved backward to the previous relevant event
                                playbackData.relevantEventIndex--;
                                
                                //indicate that we have handled a relevant step
                                stepData.currentStep++;                                
                            }

                            //display comments (if there are any for the event that comes before this one sequentially)

                            //if there is at least one event left
                            if(playbackData.codeEventsIndex > 0) {

                                //TODO may have to search deeper for the last relevant event!!!
                                //get the event that comes before this one sequentially
                                var previousEvent = playbackData.codeEvents[playbackData.codeEventsIndex - 1];

                                //TODO may have to search deeper for the last relevant event!!!
                                //if the previous event is relevant
                                if(previousEvent.relevant) {

                                    //if there are any comments for the previous event 
                                    if(playbackData.comments[previousEvent.id]) {

                                        //display the next comment
                                        displayComments(previousEvent.id, true);

                                        //if we are supposed to pause for comments
                                        if(pauseForComments && playbackData.userWantsPauseOnComments) {
                                            
                                            //pause the playback
                                            pausePlayback();

                                            //stop handling events for now
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        //if showing cuts/pastes in blocks, and we are at the final step in this group, look for 
                        //future events that have the same timestamp and are relevant and playback those too

                        //if the user wants to see pastes in a big block at once AND
                        //this is the last event in the group to step through 
                        if(playbackData.showPastesInABlock && stepData.currentStep === numRelevantStepsRequested) {

                            //if we are going forward
                            if(direction === "forward") {

                                //if there are more events to see AND
                                //the next event has the exact same timestamp as the current one AND
                                //the next event is relevant
                                if(playbackData.codeEventsIndex < playbackData.codeEvents.length - 1 &&
                                   playbackData.codeEvents[playbackData.codeEventsIndex + 1].timestamp === stepData.codeEvent.timestamp &&
                                   playbackData.codeEvents[playbackData.codeEventsIndex + 1].relevant) {

                                    //add another step to playback
                                    numRelevantStepsRequested++;
                                }

                            } else { //we are going backwards

                                //if there are more previous events to see AND
                                //the previous event has the exact same timestamp as the current one AND
                                //the previous event is relevant
                                if(playbackData.codeEventsIndex > 0 &&
                                   playbackData.codeEvents[playbackData.codeEventsIndex - 1].timestamp === stepData.codeEvent.timestamp &&
                                   playbackData.codeEvents[playbackData.codeEventsIndex - 1].relevant) {

                                    //add another step to playback
                                    numRelevantStepsRequested++;
                                }
                            }
                        }
                    } //end while

                    //for the last event in this step, perform some UI related updates that only affect the last in the step
                    //if the last event in this group of events played back is a code character event being added or removed in the editor
                    if(stepData.codeEvent.type === "Insert" || stepData.codeEvent.type === "Delete") {

                        //determines if the event is an insert (if not it must be a delete)
                        var isInsert = (stepData.codeEvent.type === "Insert" && direction === "forward") || (stepData.codeEvent.type === "Delete" && direction === "backward");
	                    
                        //place a caret cursor on the relevant code character 
                        displayCaretCursor(stepData, isInsert);

                        //if this is a relevant character
                        if(stepData.codeEvent.relevant) {
                            
                            //make the correct tab active
                            makePlaybackTabActive(stepData.codeEvent.fileId);

                            //activate the file in the file system
                            addActiveFileStyling(stepData.codeEvent.fileId);
                        }

                        //highlight the current line number
                        highlightLine(stepData.codeEvent.lineNumber, stepData.codeEvent.fileId);

                        //scroll to make the code element visible in the playback window (if necessary)
                        handleScroll(stepData.codeElement);

                    } else if (stepData.codeEvent.type === "Create File" || //file related events (except delete- nothing to animate)
                               stepData.codeEvent.type === "Rename File" ||                                
                               stepData.codeEvent.type === "Move File") { 

                        //if this is a relevant character AND we are moving forward (animating in reverse is not so important)
                        if(stepData.codeEvent.relevant && direction === "forward") {

                            //TODO see if people prefer to have a caret- the problem is it may not be at the last insert in the file
                            //remove the caret from the screen
                            removeCaretCursor();

                            //make the correct tab active
                            makePlaybackTabActive(stepData.codeEvent.fileId);

                            //highlight the file in the file system view
                            addActiveFileStyling(stepData.codeEvent.fileId);
                        }

                    } else if (stepData.codeEvent.type === "Create Directory" || //dir related events (except delete- nothing to animate) 
                               stepData.codeEvent.type === "Rename Directory" ||                               
                               stepData.codeEvent.type === "Move Directory") { 

                        //if this is a relevant character AND we are moving forward (animating in reverse is not so important)
                        if(stepData.codeEvent.relevant && direction === "forward") {

                            //TODO see if people prefer to have a caret- the problem is it may not be at the last insert in the file
                            //remove the caret from the screen
                            removeCaretCursor();

                            //highlight the dir in the file system view  
                            addActiveDirectoryStyling(stepData.codeEvent.directoryId);                          
                        }
                    }

                    //update the elements of the UI that are
                    //affected by a code event (slider, timestamp, devs)
                    updateEventInfoUI(stepData.codeEvent);    

                } else { //the user is trying to move beyond the bounds of the relevant events

                    //if moving in the forward direction 
                    if(direction === "forward") {

                        //next, I handle if this is the last relevant event AND there are still some more non-relevant events after it
                        //the non-relevant events should be played back to see the final state of the code
                        if(playbackData.relevantEventIndex === playbackData.numberOfRelevantEvents &&
                            playbackData.codeEventsIndex < playbackData.codeEvents.length - 1) {
                        
                            //remove the blinking caret because the new events added next will throw them off
                            removeCaretCursor();

                            //go through the rest of the events until the end
                            while(playbackData.codeEventsIndex < playbackData.codeEvents.length) {
                                
                                //get the next code event in sequence
                                var currentEvent = playbackData.codeEvents[playbackData.codeEventsIndex];
                                
                                //store it as part of the step data
                                stepData.codeEvent = currentEvent;

                                //display the event as if it were happening in the forward direction
                                handleEventForward(stepData);
                                                                
                                //move the current event index forward to handle the next one
                                playbackData.codeEventsIndex++;                                                                    
                            }

                            //set the index back to the last valid event index
                            playbackData.codeEventsIndex--;

                            //update the elements of the UI that are
                            //affected by a code event (slider, timestamp, devs)
                            updateEventInfoUI(stepData.codeEvent);
                        }
                    }                    
                }
            }

            /*
             * Looks at the requested number of steps to move and returns an exact number of steps to move
             * based on the direction of the step and whether there are enough events to move in that direction.
             */
            function getExactNumberOfRelevantStepsFromReqest(direction, numRelevantStepsRequested) {
                
                //default the exact number of steps to move to be the requested number
                var exactNumberOfRelevantSteps = numRelevantStepsRequested;

                //handle improper step requests if going forward in a playback
                if(direction === "forward") {
                    
                    //if the user wants to go to the very end of the playback (special value Number.MAX_SAFE_INTEGER) OR 
                    //the number of relevant steps is too great to playback                    
                    if(numRelevantStepsRequested === Number.MAX_SAFE_INTEGER || (playbackData.relevantEventIndex + numRelevantStepsRequested) >= playbackData.numberOfRelevantEvents) { 

                        //scale back the number of steps to go to the end
                        exactNumberOfRelevantSteps = playbackData.numberOfRelevantEvents - playbackData.relevantEventIndex;
                    }

                } else if(direction === "backward") { //backward through a playback

                    //if the number of steps is too great to playback backwards
                    if(numRelevantStepsRequested > playbackData.relevantEventIndex) {

                        //scale back the number of steps to go back to the beginning
                        exactNumberOfRelevantSteps = playbackData.relevantEventIndex;
                    }
                }

                return exactNumberOfRelevantSteps;
            }

            /*
             * Handle events in the forward direction. This function has three main responsibilities:
             * - adding or removing code on insert/delete
             * - adding/removing/updating elements in the file system view of the playback
             * - making file tabs visible or invisible (grayed) based on file create/delete events and renaming file tabs for file renames
             */
            function handleEventForward(stepData) {

                //check the event type
                if(stepData.codeEvent.type === "Insert") {

                    //get the hidden element for this code event and store it in the stepData
                    stepData.codeElement = document.querySelector("#" + stepData.codeEvent.id);

                    //if the line number or column is missing search for them manually (this can happen on certain downloads and merges)
                    lineNumberColumnCheck(stepData.codeEvent);

                    //show the code on the screen 
                    makeCodeVisible(stepData);
                    
                } else if(stepData.codeEvent.type === "Delete") {

                    //get the visible element to hide as a result of this delete and store it in the stepData
                    stepData.codeElement = document.querySelector("#" + stepData.codeEvent.previousNeighborId);

                    //if the line number or column is missing search for them manually (this can happen on certain downloads and merges)
                    lineNumberColumnCheck(stepData.codeEvent);

                    //hide the code on the screen 
                    makeCodeInvisible(stepData);

                } else if(stepData.codeEvent.type === "Create File") {

                    //add a new entry in the tree file system UI
                    addFileToPlaybackViewOfFileSystem(stepData.codeEvent.initialName, stepData.codeEvent.fileId, stepData.codeEvent.parentDirectoryId);

                    //at a minimum, make the file tab visible (not grayed out). If the event is relevant, step() will make it the active tab 
                    makePlaybackTabVisible(stepData.codeEvent.fileId);

                } else if(stepData.codeEvent.type === "Create Directory") {

                    //add a new entry in the tree file system UI
                    addDirectoryToPlaybackViewOfFileSystem(stepData.codeEvent.initialName, stepData.codeEvent.directoryId, stepData.codeEvent.parentDirectoryId);

                } else if(stepData.codeEvent.type === "Rename File") {

                    //update the tab link to hold the new file name (get the anchor inside the linklist item)
                    var playbackWindowLinkListItemAnchor = document.querySelector("#playbackWindowLinkListItem-" + stepData.codeEvent.fileId + " a");
                    playbackWindowLinkListItemAnchor.innerHTML = stepData.codeEvent.newFileName;

                    //update the entry in the tree file system UI
                    renameFileInPlaybackViewOfFileSystem(stepData.codeEvent.newFileName, stepData.codeEvent.fileId);

                } else if(stepData.codeEvent.type === "Rename Directory") {

                    //update the entry in the tree file system UI
                    renameDirectoryInPlaybackViewOfFileSystem(stepData.codeEvent.newDirectoryName, stepData.codeEvent.directoryId);

                } else if(stepData.codeEvent.type === "Move File") {

                    //update the entry in the tree file system UI
                    moveFileInPlaybackViewOfFileSystem(stepData.codeEvent.fileId, stepData.codeEvent.newParentDirectoryId);

                } else if(stepData.codeEvent.type === "Move Directory") {

                    //update the entry in the tree file system UI
                    moveDirectoryInPlaybackViewOfFileSystem(stepData.codeEvent.directoryId, stepData.codeEvent.newParentDirectoryId);

                } else if(stepData.codeEvent.type === "Delete File") {

                    //hide the tab so that it appears to be removed
                    makePlaybackTabInvisible(stepData.codeEvent.fileId)                        

                    //remove the entry in the tree file system UI
                    hideFileInPlaybackViewOfFileSystem(stepData.codeEvent.fileId);

                } else if(stepData.codeEvent.type === "Delete Directory") {

                    //hide all of the playback window tabs that were under the directory
                    //recurse through the directories and call makeTabInvisible for each file
                    makePlaybackTabsInADirectoryInvisible(stepData.codeEvent.directoryId);

                    //remove the entry in the tree file system UI
                    hideDirectoryInPlaybackViewOfFileSystem(stepData.codeEvent.directoryId);

                } else { //something is not right

                    console.log("ERROR: event does not have the correct type");
                    return;
                }
            }

            /*
             * Handle events in the reverse direction. This function has three main responsibilities:
             * - adding or removing code on insert/delete
             * - adding/removing/updating elements in the file system view of the playback
             * - making file tabs visible or invisible (grayed) based on file create/delete events and renaming file tabs for file renames
             */

            function handleEventBackward(stepData) {

                //check the event type
                if(stepData.codeEvent.type === "Insert") {

                    //we want to hide inserts when going in reverse
                    //get the visible element to hide as a result of this insert and store it in the stepData
                    stepData.codeElement = document.querySelector("#" + stepData.codeEvent.id);

                    //hide the code on the screen 
                    makeCodeInvisible(stepData);

                } else if(stepData.codeEvent.type === "Delete") {

                    //we want to show deletes when going in reverse
                    //get the hidden element to show as a result of this delete and store it in the stepData
                    stepData.codeElement = document.querySelector("#" + stepData.codeEvent.previousNeighborId);

                    //show the code on the screen 
                    makeCodeVisible(stepData);

                } else if(stepData.codeEvent.type === "Create File") {

                    //we want to hide new files when going in reverse
                    //hide the tab so that it appears to be removed
                    makePlaybackTabInvisible(stepData.codeEvent.fileId)                        

                    //remove the entry in the tree file system UI
                    hideFileInPlaybackViewOfFileSystem(stepData.codeEvent.fileId);

                } else if(stepData.codeEvent.type === "Create Directory") {

                    //we want to hide new dirs when going in reverse
                    //hide all of the playback window tabs that were under the directory
                    //recurse through the directories and call makeTabInvisible for each file
                    makePlaybackTabsInADirectoryInvisible(stepData.codeEvent.directoryId);

                    //remove the entry in the tree file system UI
                    hideDirectoryInPlaybackViewOfFileSystem(stepData.codeEvent.directoryId);

                } else if(stepData.codeEvent.type === "Rename File") {

                    //we want to show the old name of the file when going in reverse
                    //update the link to hold the OLD file name (get the anchor inside the linklist item)
                    var playbackWindowLinkListItem = document.querySelector("#playbackWindowLinkListItem-" + stepData.codeEvent.fileId + " a");
                    playbackWindowLinkListItem.innerHTML = stepData.codeEvent.oldFileName;

                    //update the entry in the tree file system UI to the old name
                    renameFileInPlaybackViewOfFileSystem(stepData.codeEvent.oldFileName, stepData.codeEvent.fileId);

                } else if(stepData.codeEvent.type === "Rename Directory") {

                    //we want to show the old name when going in reverse
                    //update the entry in the tree file system UI to the old name
                    renameDirectoryInPlaybackViewOfFileSystem(stepData.codeEvent.oldDirectoryName, stepData.codeEvent.directoryId);

                } else if(stepData.codeEvent.type === "Move File") {

                    //we want to update to the old parent when going in reverse
                    //update the entry in the tree file system UI to the old location
                    moveFileInPlaybackViewOfFileSystem(stepData.codeEvent.fileId, stepData.codeEvent.oldParentDirectoryId);

                } else if(stepData.codeEvent.type === "Move Directory") {

                    //we want to update to the old parent when going in reverse
                    //update the entry in the tree file system UI to the old location
                    moveDirectoryInPlaybackViewOfFileSystem(stepData.codeEvent.directoryId, stepData.codeEvent.oldParentDirectoryId);

                } else if(stepData.codeEvent.type === "Delete File") {

                    //we want to show a deleted file when going in reverse
                    //add a new entry in the tree file system UI
                    addFileToPlaybackViewOfFileSystem(stepData.codeEvent.initialName, stepData.codeEvent.fileId, stepData.codeEvent.parentDirectoryId);

                    //at a minimum, make the file tab visible (not grayed out). If the event is relevant step() will make it the active tab 
                    makePlaybackTabVisible(stepData.codeEvent.fileId);

                } else if(stepData.codeEvent.type === "Delete Directory") {

                    //we want to show a deleted dir when going in reverse
                    //add a new entry in the tree file system UI
                    addDirectoryToPlaybackViewOfFileSystem(stepData.codeEvent.initialName, stepData.codeEvent.directoryId, stepData.codeEvent.parentDirectoryId);

                } else { //something is not right

                    console.log("ERROR: event does not have the correct type");
                    return;
                }             
            }

            
            /*
             * Makes an element visible on the screen. Relatively new inserts will be highlighted
             * until the next play/pause cycle and a brief highlight will appear to guide the
             * reader's eye to new code (this is removed after a short time). 
             */
            function makeCodeVisible(stepData) {

                //make the span visible by removing the class that hides code on the screen
                stepData.codeElement.classList.remove("codeNotVisible");

                //if a new line was added, add the line number
                addLineNumberIfNecessary(stepData.codeElement, stepData.codeEvent.fileId);

                //if this is a relevant character
                if(stepData.codeEvent.relevant) {

                    //add a style for relevant characters
                    stepData.codeElement.classList.add("relevantCode");

                    //if a change highlight is needed (usually in forward direction only)
                    if(shouldHighlightChanges()) {

                        //highlight the new insert
                        addRecentInsertHighlight(stepData);
                    }

                    //if there is any delay between characters we will highlight the insert
                    if(playbackData.delay > 0) {

                        //for brief insert highlighting (class will be removed with a timer below)
                        stepData.codeElement.classList.add("briefInsertHighlight");

                        //set a timer to remove the .briefInsertHighlight class from the element
                        window.setTimeout(function(codeElement) {

                            //find the recent insert and remove the class
                            codeElement.classList.remove("briefInsertHighlight");
                        }, playbackData.highlightDelay, stepData.codeElement); //highlight delay and the element to remove the class from                        
                    }

                } else { //code is not relevant

                    //remove the class from the code element (it may have been set from a previous playback)
                    stepData.codeElement.classList.remove("relevantCode");                
                } 
            }

            /*
             * Makes an element invisible on the screen. Its previous visible sibling will get marked to display 
             * where the delete occurred. The text will stay on the screen for a short time and then be removed
             * so the user can see what is being deleted.
             */
            function makeCodeInvisible(stepData)
            {
                //if this is a relevant character
                if(stepData.codeEvent.relevant) {

                    //for new delete highlighting (class will be removed with a timer below)
                    stepData.codeElement.classList.add("briefDeleteHighlight");
                    
                    //add the 'code not visible' to hide it
                    stepData.codeElement.classList.add("codeNotVisible");
                    
                    //if there is any delay between characters
                    if(playbackData.delay > 0) {
                        
                        //set a timer to remove the .briefDeleteHighlight class and to actually hide the event
                        window.setTimeout(function(codeElement, fileId){                            
                            
                            //remove the recent brief highlight class
                            codeElement.classList.remove("briefDeleteHighlight");

                            //if a new line was removed, remove the line number
                            removeLineNumberIfNecessary(codeElement, fileId);

                        }, playbackData.highlightDelay, stepData.codeElement, stepData.codeEvent.fileId); //highlight delay, the element to remove, and the id of the file where the delete is
                    
                    } else {

                        //if a new line was removed, remove the line number
                        removeLineNumberIfNecessary(stepData.codeElement, stepData.codeEvent.fileId);                        
                    }

                    //if a change highlight is needed (usually in forward direction only)
                    if(shouldHighlightChanges()) {

                        //highlight a delete
                        addRecentDeleteHighlight(stepData);
                    }
                    
                } else { //not a relevant step

                    //remove the class from the code element (it may have been set from a previous playback)
                    stepData.codeElement.classList.remove("relevantCode");
                    
                    //hide the element
                    stepData.codeElement.classList.add("codeNotVisible");

                    //if a new line was removed, remove the line number
                    removeLineNumberIfNecessary(stepData.codeElement, stepData.codeEvent.fileId);                
                } 
            }

            /*
             * Used to indicate if we should mark recent events for the user to see on the screen.
             * This happens if the user is moving forward, has chosen to highlight recent changes (in 
             * the options), and if we are past the intial state of the code (to skip any large starting
             * state of code)  
             */
            function shouldHighlightChanges() {

                //assume that we should not highlight recent changes
                var retVal = false;

                //if the playback is moving forward AND
                //the user wants to see the recent changes 
                if(playbackData.mostRecentDirection === "forward" &&
                   playbackData.showRecentsChanges) {

                    retVal = true; 
                }

                return retVal;
            }

            /*
             * Highlights a newly inserted character so the user knows what change has been made. It also higlights
             * a file name so the user knows which files have changed. 
             */ 
            function addRecentInsertHighlight(stepData) {

                //if the current event comes after the first event then it was not part of the initial state of the code
                if(stepData.codeEvent.timestamp > playbackData.codeEvents[0].timestamp) {

                    //highlight the new code character as being reletively new
                    stepData.codeElement.classList.add("recentInsert");
                }

                //highlight the file name where the change took place
                highlightChangedFileName(stepData.codeEvent.fileId);
            }

            /* 
             * Highlights a newly deleted character so the user knows what change has been made. It also higlights
             * a file name so the user knows which files have changed. 
             */ 
            function addRecentDeleteHighlight(stepData) {

                //attempt to get the previous visible element from the one that is being deleted        
                var deletesPreviousSibling = getLastVisibleSibling(stepData.codeElement);

                //if the previous sibling is a new line character
                if(deletesPreviousSibling.classList.contains("newLine")) {
                    
                    //get the line number gutter for this file
                    var fileGutter = document.querySelector("#lineNumberGutter-" + stepData.codeEvent.fileId);

                    //add the style to the line number element
                    fileGutter.children[stepData.codeEvent.lineNumber - 1].classList.add("recentDelete");

                } else { //a visible span with some code in it
                    
                    //mark the previous sibling as a recent delete (used to highlight where a delete happened on the screen)
                    deletesPreviousSibling.classList.add("recentDelete");
                }

                //highlight the file name where the change took place
                highlightChangedFileName(stepData.codeEvent.fileId);
            }

            /*
             * Gets the anchor associated with a file name and adds a class to highlight that a change has occured
             */
            function highlightChangedFileName(fileId) {

                //get the anchor that holds the file name in the group of tabs with filenames
                var changedPlaybackWindowLinkListItem = document.querySelector("#playbackWindowLinkListItem-" + fileId);
                var changedPlaybackWIndowAnchor = changedPlaybackWindowLinkListItem.children[0];
                
                //if the anchor is not already marked with the recentFileChange class
                if(!changedPlaybackWIndowAnchor.classList.contains("recentFileChange")) {

                    //highlight the file name
                    changedPlaybackWIndowAnchor.classList.add("recentFileChange");
                }
            }

            /*
             * Clears the recent insert and delete highlights that get added when
             * new events are handled during playback.
             */
            function clearPreviousEventHighlights() {

                //get all events that have recently been inserted and remove the recent insert class
                var previousEventHighlights = document.querySelector("#playbackWindows").getElementsByClassName("recentInsert");
                while (previousEventHighlights.length) {
                    previousEventHighlights[0].classList.remove("recentInsert");
                }

                //now do the same with the recent deletes
                previousEventHighlights = document.querySelector("#playbackWindows").getElementsByClassName("recentDelete");
                while (previousEventHighlights.length) {
                    previousEventHighlights[0].classList.remove("recentDelete");
                }

                //get all the file tab links that are highlighted and remove the recentFileChange class
                var allRecentlyChangedLinks = document.querySelector("#playbackWindowTabLinks").getElementsByClassName("recentFileChange");
                while (allRecentlyChangedLinks.length) {
                    allRecentlyChangedLinks[0].classList.remove("recentFileChange");
                }
            }
            
            /*
             * When passed in a code element this function will return the closest previous sibling that does NOT have the
             * codeNotVisible class. In other words, the closest previous sibling that is visible on the screen.
             */
            function getLastVisibleSibling(codeElement) {

                //attempt to get the previous element 
                var previousVisibleSibling = codeElement.previousSibling;

                //while the siblings are visible on the screen
                while(previousVisibleSibling.classList.contains("codeNotVisible") === true)
                {                    
                    //move to the next previous sibling
                    previousVisibleSibling = previousVisibleSibling.previousSibling;
                }

                return previousVisibleSibling;
            }

            /* 
             * used to add a visible cursor to the code. If the element to add the cursor to was inserted
             * we add a cursor to the right hand side of the element. If the element was just deleted then
             * we move backwards to find the previous visible element and add the cursor to its right hand 
             * side.
             */
            function displayCaretCursor(stepData, isInsert) {

                //remove the existing current caret cursor (if there is one)
                removeCaretCursor();

                //if the code element was just inserted
                if(isInsert) {

                    //if the inserted element is a new line put the cursor on the next line attached to the gutter line number
                    if(stepData.codeElement.classList.contains("newLine")) {

                        //get the line number gutter for this file
                        var fileGutter = document.querySelector("#lineNumberGutter-" + stepData.codeEvent.fileId);

                        //add the cursor to the line number element (the next line because of 0 based index)
                        fileGutter.children[stepData.codeEvent.lineNumber].classList.add("insertCaretCursor");

                    } else { //a non-newline character

                        //add the caret cursor class to the element (blink to the right)
                        stepData.codeElement.classList.add("insertCaretCursor");
                    }           
                    
                } else { //the code element has just been deleted
                    
                    //add the caret to the previous visible code character that is not a newline
                    
                    //get the element immeditately previous to the code element
                    var previousElement = getLastVisibleSibling(stepData.codeElement);

                    //if there is an element
                    if(previousElement) {
                        
                        //if it is a new line, put the cursor above on the previous line
                        if(previousElement.classList.contains("newLine")) {

                            //get the line number gutter for this file
                            var fileGutter = document.querySelector("#lineNumberGutter-" + stepData.codeEvent.fileId);

                            //add the cursor to the line number element
                            fileGutter.children[stepData.codeEvent.lineNumber - 1].classList.add("deleteCaretCursor");

                        } else { //a non-newline character

                            //add caret cursor to the previous element 
                            previousElement.classList.add("deleteCaretCursor");
                        }
                    }
                }
            }
            
            /* 
             * used to remove a visible cursor from the code 
             */
            function removeCaretCursor() {
                
                //get the existing current insert caret cursor
                var caretCursor = document.querySelector(".insertCaretCursor");

                //if there is a cursor on the screen
                if(caretCursor) {

                    //remove it
                    caretCursor.classList.remove("insertCaretCursor");
                }

                //now look for a delete caret cursor
                caretCursor = document.querySelector(".deleteCaretCursor");

                //if there is a cursor on the screen
                if(caretCursor) {

                    //remove it
                    caretCursor.classList.remove("deleteCaretCursor");
                }
            }

            /*
             * It is possible that the line number and column properties might have values of -1 (meaning we don't know what line
             * number and column the event occured on). A saved state playback that undoes all future events, for example. 
             * If an event is missing these then they will be calculated by manipulating the dom to find them. This is an 
             * expensive operation that should only be used when a line number and column can't be found any other way. The saved 
             * state playback that undoes events does not have access to an editor state so it can't easily determine these.
             */
            function lineNumberColumnCheck(codeEvent) {

                //only check inserts and deletes
                if(codeEvent.type === "Insert" || codeEvent.type === "Delete") {

                    //if the line number and column are missing
                    if(codeEvent.lineNumber === -1 && codeEvent.column === -1) {
                        
                        //holds elements around the code event
                        var codeElement;

                        //if it is an insert
                        if(codeEvent.type === "Insert") {

                            //grab the element being inserted
                            codeElement = document.querySelector("#" + codeEvent.id);

                        } else if(codeEvent.type === "Delete") { //its a delete

                            //grab the element being deleted
                            codeElement = document.querySelector("#" + codeEvent.previousNeighborId);
                        }
                        
                        //move the element back one to look for the br immediately before this event (in case we are removing a br 
                        //we want to find the one before it)
                        codeElement = codeElement.previousSibling;

                        //characters on the event's line (start at 1 since we moved back one element in the step above)
                        var numberOfColumnsBeforeFirstLinebreak = 1;
                        
                        //number of line breaks before the element
                        var numberOfLineBreaks = 1;
                        
                        //while there are still elements before the current element
                        while(codeElement) {

                            //if this is a visible code element AND NOT the invisible firstSpan element at the beginning of each playback window 
                            if(!codeElement.classList.contains("codeNotVisible") && !codeElement.classList.contains("firstSpan")) {
                                
                                //if we encounter a BR that is visible, this is where the previous line ends
                                if(codeElement.tagName.toLowerCase() === "br") {
                                    
                                    //get all of the visible brs in this playback window
                                    var visibleBRs = codeElement.parentElement.querySelectorAll("br:not(.codeNotVisible)");

                                    //go through all the visible brs
                                    for(var i = 0;i < visibleBRs.length;i++) {

                                        //get a br
                                        var visibleBR = visibleBRs[i];

                                        //increase the line count
                                        numberOfLineBreaks++;

                                        //if the br has the same id as the element's closest br
                                        if(visibleBR.getAttribute("id") === codeElement.getAttribute("id")) {

                                            //stop looking for a matching br
                                            break;
                                        } 
                                    }
                                    
                                    //stop looking for the first br before the code element
                                    break;

                                } else { //visible span

                                    //increase the number of elements in the line
                                    numberOfColumnsBeforeFirstLinebreak++;
                                }
                            }
                            
                            //go backwards through all of the siblings
                            codeElement = codeElement.previousSibling;
                        }

                        //store the line number and column in the event
                        codeEvent.lineNumber = numberOfLineBreaks;
                        codeEvent.column = numberOfColumnsBeforeFirstLinebreak;
                    }
                }
            }

            /*
             * This function updates some elements of the UI when an event is rendered:
             * - the event type
             * - info about file operations
             * - the event timestamp
             * - the developer group who made the event
             * - the slider position and text
             */
            function updateEventInfoUI(codeEvent) {

                //show how many relevant events we have displayed and how many are left
                var relevantEventCountDiv = document.querySelector("#relevantEventCountDiv");
                relevantEventCountDiv.innerHTML = playbackData.relevantEventIndex + "/" + playbackData.numberOfRelevantEvents;

                //show how many total events we have displayed and how many are left
                var totalEventCountDiv = document.querySelector("#totalEventCountDiv");
                totalEventCountDiv.innerHTML = (playbackData.codeEventsIndex  + 1) + "/" + playbackData.codeEvents.length;

                //holds event info
                var eventTypeString = codeEvent.type;
                
                //if this is an insert/delete print the character (useful for invisible characters)
                if(codeEvent.type === "Insert" || codeEvent.type === "Delete") {

                    //if it is a newline or a tab show the user some text
                    if(codeEvent.character === "\n") {

                        eventTypeString += ": '\\n' ";

                    } else if(codeEvent.character === "\r") {

                        eventTypeString += ": '\\r' ";

                    } else if(codeEvent.character === " ") {

                        eventTypeString += ": space ";

                    } else if(codeEvent.character === "\t") {

                        eventTypeString += ": tab ";

                    } else {

                        eventTypeString += ": '" + codeEvent.character + "'";
                    }
                    
                    //show the paste source (if this event was pasted)
                    if(codeEvent.pastedEventId === "other") {

                        eventTypeString += " (paste from outside source) ";

                    } else if(codeEvent.pastedEventId) {

                        eventTypeString += " (paste from this repo) ";
                    }
                }

                var eventTypeDiv = document.querySelector("#eventTypeDiv");
                eventTypeDiv.innerHTML = eventTypeString;

                //if there is a line number show it
                var eventInfoDiv = document.querySelector("#eventInfoDiv");

                eventInfoDiv.innerHTML = "";

                //if this is an event with a line and column number (inserts and deletes)
                if(codeEvent.lineNumber && codeEvent.column) {

                    //show the line number and column
                    eventInfoDiv.innerHTML += "Line: " + codeEvent.lineNumber + ", Col: " + codeEvent.column;

                } else { //event without a line number (file operation)

                    if(codeEvent.type === "Create File") {

                        //add the initial name of the file in the event info section
                        eventInfoDiv.innerHTML += "Initial name: " + codeEvent.initialName;

                    } else if(codeEvent.type === "Create Directory") {

                        //add the initial name of the directory in the event info section
                        eventInfoDiv.innerHTML += "Initial name: " + codeEvent.initialName;

                    } else if(codeEvent.type === "Rename File") {

                        //display the old name and the new name in the info section
                        eventInfoDiv.innerHTML += "Renaming from: '" + codeEvent.oldFileName + "' to '" + codeEvent.newFileName +"'";

                    } else if(codeEvent.type === "Rename Directory") {

                        //display the old name and the new name in the info section
                        eventInfoDiv.innerHTML += "Renaming from: '" + codeEvent.oldDirectoryName + "' to '" + codeEvent.newDirectoryName +"'";

                    } else if(codeEvent.type === "Move File") {

                        //display the old parent dir name and the new parent dir name in the info section
                        eventInfoDiv.innerHTML += "Moving '" + codeEvent.fileName +"' from: '" + codeEvent.oldParentDirectoryName + "' to '" + codeEvent.newParentDirectoryName +"'";

                    } else if(codeEvent.type === "Move Directory") {

                        //display the old parent dir name and the new parent dir name in the info section
                        eventInfoDiv.innerHTML += "Moving '" + codeEvent.directoryName +"' from: '" + codeEvent.oldParentDirectoryName + "' to '" + codeEvent.newParentDirectoryName +"'";

                    } else if(codeEvent.type === "Delete File") {

                        //add the name of the file to delete in the event info section
                        eventInfoDiv.innerHTML += "Deleting file: " + codeEvent.fileName;

                    } else if(codeEvent.type === "Delete Directory") {

                        //add the name of the file to delete in the event info section
                        eventInfoDiv.innerHTML += "Deleting directory: " + codeEvent.directoryName;

                    } else {

                        //empty the line number info
                        eventInfoDiv.innerHTML = "";
                    }
                }

                //show the timestamp
                document.querySelector("#timestampDiv").innerHTML = formatDateShortWithDayOfWeek(new Date(codeEvent.timestamp));

                //show the developers in the dev group
                showDevsInDevGroup(codeEvent);

                //update the progress bar
                var playbackProgressBar = document.querySelector("#playbackProgressBar");

                //update the slider based on how far along in the playback we are
                playbackProgressBar.setAttribute("style", "width:" +(playbackData.relevantEventIndex / playbackData.numberOfRelevantEvents) * 100.0 + "%");
            }

            /*
             * Changes the speed of the playback. The delta can be a positive or negative number
             */
            function changeSpeed(delta) {

                //amount to increase/decrease the delay between events
                playbackData.delay += delta;

                //if we ever get a less than a 25 ms delay
                if(playbackData.delay < 25) {

                    //make sure there is a playback speed of at least 25 ms
                    playbackData.delay = 25;
                }

                //get the speed controls and update the speed indicator
                var playbackSpeedDisplay = document.querySelector("#currentPlaybackSpeed");
                playbackSpeedDisplay.innerHTML = "<strong>" + playbackData.delay + " ms</strong> in between events";
            }

            //*****************************************************************************
            //                         Tab related code
            //                         ----------------
            // This section of code has to do with tabs for the code files
            //*****************************************************************************
            /*
             * Create a tab that holds a playback window and a line number gutter. This is called
             * when the page is being set up for each new create file event.
             */
            function createFilePlaybackTab(fileId, fileName) {

                //it is possible with 'undone' events in a complete history playback to have multiple create file events for 
                //the same file. There is no need to create a second playback window when this happens

                //look for an existing playback window with the fileId
                var existingPlaybackWindowTab = document.querySelector("#playbackWindowTab-" + fileId);

                //if there is not an exsiting one, create it
                if(!existingPlaybackWindowTab) {
                
                    //start by adding a clickable file name link
                    //get the container of link list items for the playback window tabs
                    var playbackWindowTabLinks = document.querySelector("#playbackWindowTabLinks");

                    //create an anchor for the tab
                    //<a href="#playbackWindowTab-fileId" data-toggle="tab" class="playbackWindowTabLink">file name</a>
                    var newLink = document.createElement("a");
                    newLink.setAttribute("href", "#playbackWindowTab-" + fileId);
                    newLink.setAttribute("data-toggle", "tab");
                    newLink.classList.add("playbackWindowTabLink");
                    newLink.innerHTML = fileName;

                    //create a list item to hold the anchor
                    //<li class="playbackWindowLinkListItem" id="playbackWindowLinkListItem-fileId">
                    var newPlaybackWindowLinkListItem = document.createElement("li");
                    newPlaybackWindowLinkListItem.classList.add("playbackWindowLinkListItem");
                    newPlaybackWindowLinkListItem.setAttribute("id", "playbackWindowLinkListItem-" + fileId);

                    //add the link to the list item
                    newPlaybackWindowLinkListItem.appendChild(newLink);
                    
                    //add the list item to the group of all tab links at the top of the playback windows
                    playbackWindowTabLinks.appendChild(newPlaybackWindowLinkListItem);


                    //next, the actual playback window

                    //create a div to hold a playback window
                    //get the container of all playback window divs
                    var playbackWindows = document.querySelector("#playbackWindows");

                    //create a new div for this file (line gutter and code)
                    //<div id="playbackWindowTab-fileId" class="playbackWindowTab tab-pane fade in">
                    var newPlaybackWindowTab = document.createElement("div");
                    newPlaybackWindowTab.setAttribute("id", "playbackWindowTab-" + fileId);
                    newPlaybackWindowTab.classList.add("playbackWindowTab");
                    newPlaybackWindowTab.classList.add("tab-pane");
                    newPlaybackWindowTab.classList.add("fade");
                    newPlaybackWindowTab.classList.add("in");


                    //create a line number gutter to go in the playbackWindowTab
                    //<div id="lineNumberGutter-fileId" class="lineNumberGutter"><div class='lineNum'></div></div>
                    var lineNumberGutter = document.createElement("div");
                    lineNumberGutter.setAttribute("id", "lineNumberGutter-" + fileId);
                    //add the first line number
                    lineNumberGutter.innerHTML= "<div class='lineNum'></div>";
                    lineNumberGutter.classList.add("lineNumberGutter");

                    //create a playback window
                    //<div id="playbackWindow-fileId" class="playbackWindow">
                    //  <span id="firstSpan-fileId" class="firstSpan"></span>
                    //  <span id="lastSpan-fileId" class="lastSpan">X</span>
                    //</div>
                    var playbackWindow = document.createElement("div");
                    playbackWindow.setAttribute("id", "playbackWindow-" + fileId);
                    playbackWindow.classList.add("playbackWindow");

                    //create a span object that all code events without a previous neighbor id
                    //will back up to (all 'first' code characters have a "none" previous neighbor)
                    var firstSpan = document.createElement("span");
                    firstSpan.setAttribute("id", "firstSpan-" + fileId);
                    firstSpan.classList.add("firstSpan");

                    //create a last span (always hidden) to have a non-empty playback window
                    var lastSpan = document.createElement("span");
                    lastSpan.setAttribute("id", "lastSpan-" + fileId);
                    lastSpan.appendChild(document.createTextNode("X"));
                    lastSpan.classList.add("lastSpan");

                    //add the first and last span
                    playbackWindow.appendChild(firstSpan);
                    playbackWindow.appendChild(lastSpan);

                    //add the elements to the tab
                    newPlaybackWindowTab.appendChild(lineNumberGutter);
                    newPlaybackWindowTab.appendChild(playbackWindow);

                    //add the tab to all the others
                    playbackWindows.appendChild(newPlaybackWindowTab);

                    //add a class to give the tab a hidden style
                    newLink.classList.add("playbackTabNotVisible");

                }//else- the playback wiondow tab already exists, no need to create it again            
            }

            /*
             * Makes a playback window tab active
             */
            function makePlaybackTabActive(fileId) {

                //Link
                //look for an active playback tab link
                var currentlyActiveTabLink = document.querySelector(".playbackWindowLinkListItem.active");

                //if there is no active link OR if the currently active file is different than the passed in one, we need to change the active tab
                if(currentlyActiveTabLink === null || currentlyActiveTabLink.getAttribute("id") !== "playbackWindowLinkListItem-" + fileId) {

                    //if there is an active tab, deactivate it
                    if(currentlyActiveTabLink) {

                        //make the old active tab link inactive
                        currentlyActiveTabLink.classList.remove("active");
                    }

                    //get the link list item to highlight
                    var newTabLinkListItem = document.querySelector("#playbackWindowLinkListItem-" + fileId)

                    //the anchor that allows a user to change tabs is the first child of the list item
                    var newTabAnchor = newTabLinkListItem.children[0];

                    //make the link list item visible by removing the class that hides it
                    newTabAnchor.classList.remove("playbackTabNotVisible");

                    //make the new active tab link active
                    newTabLinkListItem.classList.add("active");


                    //Playback Tab
                    //look for a current active tab
                    var currentlyActivePlayback = document.querySelector(".playbackWindowTab.active");

                    //if there is an active tab
                    if(currentlyActivePlayback) {

                        //make it inactive
                        currentlyActivePlayback.classList.remove("active");
                        currentlyActivePlayback.classList.remove("in");
                    }

                    //get the new tab to activate
                    var newPlaybackWindowTab = document.querySelector("#playbackWindowTab-" + fileId);

                    //make the new tab active
                    newPlaybackWindowTab.classList.add("active");
                    newPlaybackWindowTab.classList.add("in");

                    //store the new active file id
                    playbackData.activeFileId = fileId;

                } //else- the passed in file id is already the active file
            }

            /*
             * Makes a playback window tab visible but not active
             */
            function makePlaybackTabVisible(fileId) {

                //Link
                //get the link list item to highlight
                var tabLinkListItem = document.querySelector("#playbackWindowLinkListItem-" + fileId)

                //the anchor that allows a user to change tabs is the first child of the list item
                var tabAnchor = tabLinkListItem.children[0];

                //make the link list item visible by removing the class that hides it
                tabAnchor.classList.remove("playbackTabNotVisible");
            }

            /*
             * Makes the tab visibilty hidden
             */
            function makePlaybackTabInvisible(fileId) {

                //Link
                //look for a playback tab link with the given file id
                var tabLinkListItem = document.querySelector("#playbackWindowLinkListItem-" + fileId);

                //if there is a link
                if(tabLinkListItem) {

                    //get the anchor (it is the only child of the link list tiem)
                    var tabLinkAnchor = tabLinkListItem.children[0];

                    //make the tab link inactive
                    tabLinkAnchor.classList.add("playbackTabNotVisible");

                    //make the list item not active
                    tabLinkListItem.classList.remove("active");
                }
            }

            /*
             * Go through all of the files in a directory and make their tabs invisible
             */
            function makePlaybackTabsInADirectoryInvisible(directoryId) {

                //go through all of the subdirectories
                for(var dirId in playbackData.allDirs) {
                    if(playbackData.allDirs.hasOwnProperty(dirId)) {

                        //if a directory is unde the current one
                        if(playbackData.allDirs[dirId].parentId === directoryId) {

                            //recurse into the subdirectory
                            makePlaybackTabsInADirectoryInvisible(playbackData.allDirs[dirId].id);
                        }
                    }
                }

                //make all of the files in this directory inactive
                for(var fileId in playbackData.allFiles) {
                    if(playbackData.allFiles.hasOwnProperty(fileId)) {

                        //if a file has this dir as a parent
                        if(playbackData.allFiles[fileId].parentId === directoryId) {

                            //make the tab invisible
                            makePlaybackTabInvisible(playbackData.allFiles[fileId].id);
                        }
                    }
                }
            }

            //*****************************************************************************
            //                Current view of fs during playback related code
            //                -----------------------------------------------
            // This code has to do with manipulating the view of the file system during a
            // playback. This UI element allows a user to see what the fs looked like when
            // the current event happened.
            //*****************************************************************************
            
            //The parentElement is a ul of either list items (li) for each file/dir name or an unordered list (ul)
            //with the contents of a subdirectory. A subdirectory's contents (ul) always comes immediately after the 
            //li with the name. For this sample file system: 
            //testDir
            // -- dir
            // ---- dir2
            // ------ test2.txt
            // ---- test.txt

            //we would see this dom structure:
            //<ul id="playbackViewOfFileSystem" class="playbackViewFileOrDirList">
            //    <!-- /testDir -->
            //    <li id="playbackDirView-dirId-0" class="playbackDirView">
            //        <span class="playbackDirNameLabel">testDir</span>
            //        <ul class="playbackViewFileOrDirList">
            //            <!-- /testDir/dir -->
            //            <li id="playbackDirView-dirId-1" class="playbackDirView">
            //                <span class="playbackDirNameLabel">dir</span>
            //                <ul class="playbackViewFileOrDirList">
            //                    <!-- /testDir/dir/dir2 -->
            //                    <li id="playbackDirView-dirId-2" class="playbackDirView">
            //                        <span class="playbackDirNameLabel">dir2</span>
            //                        <ul class="playbackViewFileOrDirList">
            //                            <!-- /testDir/dir/dir2/test2.txt -->
            //                            <li id="playbackViewFile-fileId-0" class="playbackFileView">
            //                                <a class="fileLink">
            //                                    <span>test2.txt</span>
            //                                </a>
            //                            </li>
            //                        </ul>
            //                    </li>
            //                    <!-- /testDir/dir/test.txt -->
            //                    <li id="playbackViewFile-fileId-1" class="playbackFileView">
            //                        <a class="fileLink">
            //                            <span>test.txt</span>
            //                         </a>
            //                    </li>
            //                </ul>
            //            </li>
            //        </ul>
            //    </li>
            //</ul>

            /*
             * Adds an entry in the playback view of the filesystem if there isn't already an entry (there may be
             * an entry that is hidden because the playback moved in reverse). If we attempt to add a hidden, present
             * file we remove the hidden class to make it appear to be newly created.
             */
            function addFileToPlaybackViewOfFileSystem(fileName, fileId, parentDirectoryId) {

                //look for an existing file list item
                var fileLI = document.querySelector("#playbackViewFile-" + fileId);

                //if there is an existing list item it is because we previously hid it by going backwards
                if(fileLI) {

                    //show the file again
                    showFileInPlaybackViewOfFileSystem(fileId);

                } else { //this is a brand new file

                    //every file has a parent directory, get the parent dir and the ul that holds the contents
                    var parentOfFile = document.querySelector("#playbackViewDir-" + parentDirectoryId).children[2];
                    
                    //add a file icon
                    var fileIcon = document.createElement("span");
                    fileIcon.innerHTML = "-";

                    //create a span to display the file name
                    var fileNameSpan = document.createElement("span");
                    fileNameSpan.innerHTML = fileName;

                    //create a link to make the tab for this file active
                    var fileAnchor = document.createElement("a");
                    fileAnchor.classList.add("fileLink");
                    fileAnchor.addEventListener("click", function(e) {
                        
                        //make the selected file tab active
                        makePlaybackTabActive(fileId);
                    });

                    //add the icon and file name to the anchor
                    fileAnchor.appendChild(fileIcon);
                    fileAnchor.appendChild(fileNameSpan);

                    //add the anchor to a list item
                    fileLI = document.createElement("li");
                    fileLI.setAttribute("id", "playbackViewFile-" + fileId);
                    fileLI.classList.add("playbackFileView");
                    fileLI.appendChild(fileAnchor);

                    //add the file to the correct list
                    parentOfFile.appendChild(fileLI);

                    //<li id="playbackViewFile-fileId-0" class="playbackFileView">
                    //    <a class="fileLink">
                    //       <span>file name</span>
                    //    </a>
                    //</li>
                }
            }

            /*
             * Adds an entry in the playback view of the filesystem if there isn't already an entry (there may be
             * an entry that is hidden because the playback moved in reverse). If we attempt to add a hidden, present
             * dir we remove the hidden class to make it appear to be newly created.
             */
            function addDirectoryToPlaybackViewOfFileSystem(directoryName, directoryId, parentDirectoryId) {

                //attempt to get the list item for the directory we are trying to add
                var dirLI = document.querySelector("#playbackViewDir-" + directoryId);

                //if it exists it means that it has been hidden because we moved backwards
                if(dirLI) {

                    //show the directory again
                    showDirectoryInPlaybackViewOfFileSystem(directoryId);

                } else { //the directory entry does not exist, we will create it

                    //the parent directory to add the new directory under
                    var parentElement;

                    //if there is a non-empty parent id (it is not the root of the filesystem)
                    if(parentDirectoryId) {

                        //get the li that represents the directory in the existing tree and then get its third child a ul that holds the contents of the dir
                        parentElement = document.querySelector("#playbackViewDir-" + parentDirectoryId).children[2];

                    } else { //empty parent id

                        //use the topmost ul
                        parentElement = document.querySelector("#playbackViewOfFileSystem");
                    }

                    //create a directory icon
                    var dirIcon = document.createElement("span");
                    dirIcon.innerHTML = "+";

                    //create a span to hold the dir name
                    var dirNameSpan = document.createElement("span");
                    dirNameSpan.innerHTML = directoryName;
                    dirNameSpan.classList.add("playbackDirNameLabel");

                    //add a new empty unordered list to hold the contents of the directory
                    var newList = document.createElement("ul");
                    newList.classList.add("playbackViewFileOrDirList");

                    //create a li to hold the icon, dir name, and ul for the contents
                    var dirLI = document.createElement("li");
                    dirLI.setAttribute("id", "playbackViewDir-" + directoryId);
                    dirLI.classList.add("playbackDirView");
                    
                    //add the sub-elements
                    dirLI.appendChild(dirIcon);
                    dirLI.appendChild(dirNameSpan);
                    dirLI.appendChild(newList);
                    
                    //add the list items to the parent
                    parentElement.appendChild(dirLI);

                    //<li id="playbackDirView-dirId-0" class="playbackDirView">
                    //    <span class="playbackDirNameLabel">dir name</span>
                    //    <ul class="playbackViewFileOrDirList"></ul>
                    //</li>
                }
            }

            /*
             * Renames a file in the playback view of the file system
             */
            function renameFileInPlaybackViewOfFileSystem(newFileName, fileId) {

                //get the list item for the file
                var fileLi = document.querySelector("#playbackViewFile-" + fileId);

                //<li id="playbackViewFile-fileId-0" class="playbackFileView">
                //    <a class="fileLink">
                //       <span>file name</span>
                //    </a>
                //</li>

                //every file li has an anchor and an icon and a span as children. The span holds the file name
                fileLi.children[0].children[1].innerHTML = newFileName;
            }

            /*
             * Renames a dir in the playback view of the file system
             */
            function renameDirectoryInPlaybackViewOfFileSystem(directoryName, directoryId) {

                //get the list item that represents the contents of the dir
                var dirLi = document.querySelector("#playbackViewDir-" + directoryId);

                //<li id="playbackDirView-dirId-0" class="playbackDirView">
                //    <span class="playbackDirNameLabel">dir name</span>
                //    <ul class="playbackViewFileOrDirList"></ul>
                //</li>

                //second child of li (a span with the dir name)
                dirLi.children[1].innerHTML = directoryName;
            }

            /*
             * Moves a file in the playback view of the file system
             */
            function moveFileInPlaybackViewOfFileSystem(fileId, newParentDirectoryId) {

                //get the list item for the file
                var fileLi = document.querySelector("#playbackViewFile-" + fileId);

                //<li id="playbackDirView-dirId-0" class="playbackDirView">
                //    <span class="playbackDirNameLabel">dir name</span>
                //    <ul class="playbackViewFileOrDirList">
                //        <li id="playbackViewFile-fileId-0" class="playbackFileView">
                //            <a class="fileLink">
                //                <span>file name</span>
                //            </a>
                //        </li>
                //    </ul>
                //</li>
                
                //remove the file li from the parent
                fileLi.parentElement.removeChild(fileLi);

                //get the new parent
                var newParent = document.querySelector("#playbackViewDir-" + newParentDirectoryId).children[2];

                //add the file li to the new parent
                newParent.appendChild(fileLi);
            }

            /*
             * Moves a dir in the playback view of the file system
             */
            function moveDirectoryInPlaybackViewOfFileSystem(directoryId, newParentDirectoryId) {

                //get the list item for the directory
                var dirLi = document.querySelector("#playbackViewDir-" + directoryId);

                //<li id="playbackDirView-dirId-0" class="playbackDirView">
                //    <span class="playbackDirNameLabel">dir name 0</span>
                //    <ul class="playbackViewFileOrDirList">
                //        <li id="playbackDirView-dirId-1" class="playbackDirView">
                //            <span class="playbackDirNameLabel">dir name 1</span>
                //            <ul class="playbackViewFileOrDirList">
                //            </ul>
                //        </li>
                //    </ul>
                //</li>

                //remove the directory from the parent
                dirLi.parentElement.removeChild(dirLi);

                //get the new parent from the new dir's ul's parent
                var newParent = document.querySelector("#playbackViewDir-" + newParentDirectoryId).children[2];

                //add the file li to the new parent
                newParent.appendChild(dirLi);
            }

            /*
             * Used to hide but not remove a file in the playback view of the file system that has
             * previously been added.
             */
            function hideFileInPlaybackViewOfFileSystem(fileId) {

                //get the list item for the file
                var fileLi = document.querySelector("#playbackViewFile-" + fileId);

                //<li id="playbackViewFile-fileId-0" class="playbackFileView">
                //    <a class="fileLink">
                //       <span>file name</span>
                //    </a>
                //</li>
                
                //add a class to mark it as hidden
                fileLi.classList.add("hiddenFile");
            }

            /*
             * Used to hide but not remove a directory in the playback view of the file system that has
             * previously been added.
             */
            function hideDirectoryInPlaybackViewOfFileSystem(directoryId) {

                //get the list item for the directory
                var dirLi = document.querySelector("#playbackViewDir-" + directoryId);
                
                //<li id="playbackDirView-dirId-0" class="playbackDirView">
                //    <span class="playbackDirNameLabel">dir name</span>
                //    <ul class="playbackViewFileOrDirList"></ul>
                //</li>

                //add a class to mark it as hidden
                dirLi.classList.add("hiddenDirectory");

                //remove the styling for the currently active file/dir
                removeActiveFileOrDirectoryStyling();
            }

            /*
             * Used to show a file in the playback view of the file system that has previously been
             * added and then hidden because of moving backwards.
             */
            function showFileInPlaybackViewOfFileSystem(fileId) {

                //get the list item for the file
                var fileLi = document.querySelector("#playbackViewFile-" + fileId);

                //<li id="playbackViewFile-fileId-0" class="playbackFileView hiddenFile">
                //    <a class="fileLink">
                //       <span>file name</span>
                //    </a>
                //</li>

                //remove the class that hides the file
                fileLi.classList.remove("hiddenFile");
            }

            /*
             * Used to show a directory in the playback view of the file system that has previously been
             * added and then hidden because of moving backwards.
             */
            function showDirectoryInPlaybackViewOfFileSystem(directoryId) {

                //get the list item for the directory
                var dirLi = document.querySelector("#playbackViewDir-" + directoryId);

                //<li id="playbackDirView-dirId-0" class="playbackDirView hiddenDirectory">
                //    <span class="playbackDirNameLabel">dir name</span>
                //    <ul class="playbackViewFileOrDirList"></ul>
                //</li>

                //remove the class that hides the directory
                dirLi.classList.remove("hiddenDirectory");
            }

            /*
             * Removes the activeFileOrDirectory class from any element that is active
             * in the playback view of the file system.
             */
            function removeActiveFileOrDirectoryStyling() {

                //look for the current active file or directory
                var currentActiveFileOrDirectory = document.querySelector(".activeFileOrDirectory");

                //if there is an active file or directory
                if(currentActiveFileOrDirectory) {

                    //remove the class that makes it active
                    currentActiveFileOrDirectory.classList.remove("activeFileOrDirectory");
                }
            }

            /*
             * Adds the activeFileOrDirectory class to a file that is active
             * in the playback view of the file system.
             */
            function addActiveFileStyling(fileId) {

                //look for the current active file or directory
                var currentActiveFileOrDirectory = document.querySelector(".activeFileOrDirectory");

                //if there is no active file or directory
                if(currentActiveFileOrDirectory === null) {

                    //get the list item for the file
                    var fileListItem = document.querySelector("#playbackViewFile-" + fileId);

                    //make the file active
                    fileListItem.classList.add("activeFileOrDirectory");

                } else { //there is an active file or directory

                    //if the active file/dir is different from the passed in file id
                    if(currentActiveFileOrDirectory.getAttribute("id") !== "playbackViewFile-" + fileId) {

                        //remove the current active file or directory
                        removeActiveFileOrDirectoryStyling();

                        //get the list item for the file
                        var fileListItem = document.querySelector("#playbackViewFile-" + fileId);

                        //make the file active
                        fileListItem.classList.add("activeFileOrDirectory");
                    }
                }
            }

            /*
             * Adds the activeFileOrDirectory class to a directory that is active
             * in the playback view of the file system.
             */
            function addActiveDirectoryStyling(dirId) {

                //these don't happen very often so just always remove the old and add the new
                
                //remove the current active file or directory
                removeActiveFileOrDirectoryStyling();

                //get the list item for the directory
                var dirLi = document.querySelector("#playbackViewDir-" + dirId);

                //make the directory active
                dirLi.classList.add("activeFileOrDirectory");
            }

            //*****************************************************************************
            //                          Version control related code
            //                          ----------------------------
            // This code has to do with creating downloadable snapshots of the history 
            // during a playback. These can be used to branch from any point. 
            //*****************************************************************************
            /*
             * This function saves the state of a playback where it is paused. The files/dirs, playbackData.json,
             * and editorState.json are wrapped up in a zip file. This file can be unzipped and a user can build
             * from the pause point in a storyteller editor.
             * 
             * There are three types of 'saves' that store different event info in playbackData.json:
             * - getPlaybackDataMinimumHistory: in this case only the code that is present on the screen at the pause 
             *     point is added to the playbackData.json file. All of the code that was added and then deleted up to
             *     the pause point is stripped and will not be in the zip.
             * - getPlaybackDataNoFutureEvents: in this case all of the code up to the pause point is added to the
             *     playbackData.json file but no events after the pause point will be present. All of the code on the
             *     screen and all of the inserts that were deleted up to the pause point will be part of the history. 
             * - getPlaybackDataFutureEventsUndone: in this case all of the code up to the pause point and beyod is
             *     added to the playbackData.json file. However, the events after the pause point are 'undone' using 
             *     the inverse of each event after the pause point. 
             */
            function saveStateOfPlaybackAtPausePoint(typeOfSave, saveComments) {
                
                //every saved playback is considered a new branch of the same repo
                //create a 5 digit branch id for the new repo
                var newBranchId = createRandomNumberBase62(5);

                //get all of the playback data (map of insert events on screen, allFiles, allDirs, allDevGroups, etc)
                var playbackDataOnScreenAtPausePoint = getAllPlaybackDataOnScreenAtPausePoint(saveComments);

                //get the current view of the file system (all files and dirs on the screen at the pause point)
                var rootfileSystemViewAtPausePoint = getCurrentStateOfFileSystem(playbackDataOnScreenAtPausePoint.allInsertEvents);

                //get the editor state info (pathIdMap, allInsertEventsByFile, autoGeneratedEventId, etc.)
                var editorStateJson = getEditorState(rootfileSystemViewAtPausePoint, playbackDataOnScreenAtPausePoint);
                
                //get the name of the root of the project
                var rootDirName = rootfileSystemViewAtPausePoint[0].dirName;

                //for creating a zip
                var zip = new JSZip();

                //create a saved representation of the files/dirs in the file system in the zip
                zipUpCurrentStateOfFiles(rootfileSystemViewAtPausePoint, zip);
                
                //create a representation of the playback data and add it to the zip
                zipUpPlaybackData(rootfileSystemViewAtPausePoint, rootDirName, editorStateJson, playbackDataOnScreenAtPausePoint, zip, typeOfSave, newBranchId);

                //create a representation of the editor state and add it to the zip
                zipUpEditorState(rootDirName, editorStateJson, zip);
                
                //build the zip and make it downloadable
                buildZip(rootDirName, zip);
            }

            /*
            * Creates a random number using base 62. The digits are 0-9, a-z, A-Z. The user specifies how many digits they would like
            * the number to be.
            */
            function createRandomNumberBase62(numDigits) {
                
                //a 'numDigits' digit random number (in base 62: 0-9,a-z,A-Z)
                var randomId = "";

                //the 62 digits that are available
                var digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
                
                //for each digit
                for(var i = 0;i < numDigits;i++) {
                    
                    //pick a random number between 0-61
                    var randPos = Math.floor(Math.random() * 62);

                    //add a random digit to the result
                    randomId += digits[randPos];
                }

                return randomId;
            }
            
            /*
             * This function scans the events in a playback by going through all the events from the first up to the point 
             * where it was paused (up to and including the event at index playbackData.codeEventsIndex) and collects 
             * data about the contribution up to that point. 
             * 
             * The data that is collected is:
             * - allInsertEvents: a map of all the insert events that are visible up to the point where the playback was paused
             * - allFiles: holds the files in the played back portion of the playback
             * - allDirs: holds the dirs in the played back portion of the playback
             * - allDeveloperGroups: holds the dev groups in the played back portion of the playback
             * - allDevelopers: holds the devs in the played back portion of the playback
             * - comments: holds the comments in the played back portion of the playback
             * - allInsertAndCreateComments: holds the comments associated with visible insert events in the played back portion of the playback
             * - allCreateFileEvents: holds all of the create file events up to the pause point
             * - allCreateDirEvents: holds all of the create dir events up to the pause point
             */
            function getAllPlaybackDataOnScreenAtPausePoint(saveComments) {

                //object with the playback data up to the pause point
                var playedEventInfo = {
                    allInsertEvents: {},            //holds all the insert events that are visible up to the point where the playback was paused
                    allCreateFileEvents: {},        //holds all of the create file events up to the pause point (used for perfect programmer playback)
                    allCreateDirEvents: {},         //holds all of the create dir events up to the pause point (used for perfect programmer playback)
                    allFiles: {},                   //holds the files in the played back portion of the playback
                    allDirs: {},                    //holds the dirs in the played back portion of the playback
                    allDeveloperGroups: {},         //holds the dev groups in the played back portion of the playback
                    allDevelopers: {},              //holds the devs in the played back portion of the playback
                    comments: {},                   //holds the comments in the played back portion of the playback
                    allInsertAndCreateComments: {}  //holds the comments associated with insert events in the played back portion of the playback (this is for minimal events playbacks so we don't store comments for events that are not there)
                }

                //depending on the type of playback we are storing the current dev group might not have made any contributions yet. We want to make sure the 
                //current dev group is present because when this project is opened we want to attribute any new events to the current dev group
                //add the current dev group and its members to the object
                addDeveloperGroupAndDevelopersToObject(playedEventInfo, playbackData.currentDevGroupId);


                //go through all of the events up to the pause point in the playback
                for(var i = 0;i <= playbackData.codeEventsIndex;i++) {

                    //the current event in the playback
                    var currentEvent = playbackData.codeEvents[i];


                    //if the event's dev group is not currently being stored
                    if(!playedEventInfo.allDeveloperGroups[currentEvent.createdByDevGroupId]) {
                        
                        //add the dev group and its members to the object
                        addDeveloperGroupAndDevelopersToObject(playedEventInfo, currentEvent.createdByDevGroupId);
                    }

                    //every event may also have a comment
                    //if there is a comment for this event 
                    if(saveComments && playbackData.comments[currentEvent.id]) {

                        //store the array of comments to the collection that will go in the zipped playback data
                        playedEventInfo.comments[currentEvent.id] = playbackData.comments[currentEvent.id];
                    } 
                    
                    //event specific checks
                    //if this is an insert
                    if(currentEvent.type === "Insert") {

                        //make a copy of the current event (some of these properties may be changed by the code that uses this)
                        var minimalInsertEvent = {
                            id: currentEvent.id,
                            timestamp: currentEvent.timestamp,
                            type: currentEvent.type,
                            character: currentEvent.character,
                            previousNeighborId: currentEvent.previousNeighborId,
                            createdByDevGroupId: currentEvent.createdByDevGroupId,
                            lineNumber: currentEvent.lineNumber,
                            column: currentEvent.column,
                            fileId: currentEvent.fileId,
                        };

                        //get the span on the screen for this event
                        var codeSpan = document.querySelector("#" + minimalInsertEvent.id);

                        //if this insert is still on the screen
                        if(codeSpan.classList.contains("codeChar") && !codeSpan.classList.contains("codeNotVisible")) {

                            //store the insert event keyed by the event id and store the event
                            playedEventInfo.allInsertEvents[minimalInsertEvent.id] = minimalInsertEvent;

                            //if there is a comment for this insert event 
                            if(saveComments && playbackData.comments[minimalInsertEvent.id]) {

                                //store the array of comments to the collection that will go in the zipped playback data
                                playedEventInfo.allInsertAndCreateComments[minimalInsertEvent.id] = playbackData.comments[minimalInsertEvent.id];
                            }
                        }
                        
                    } else if(currentEvent.type === "Create File") { //create file

                        //make a copy of the current event (some of these properties may be changed by the code that uses this)
                        var minimalCreateFileEvent = {
                            id: currentEvent.id,
                            timestamp: currentEvent.timestamp,
                            type: currentEvent.type,
                            initialName: currentEvent.initialName,
                            fileId: currentEvent.fileId,
                            parentDirectoryId: currentEvent.parentDirectoryId,
                            createdByDevGroupId: currentEvent.createdByDevGroupId
                        };

                        //if this file has not been recorded
                        if(!playedEventInfo.allFiles[minimalCreateFileEvent.fileId]) {

                            //create a file entry for this new file using the event info
                            var newFile = {
                                id: currentEvent.fileId,
                                parentId: currentEvent.parentDirectoryId,
                                currentName: currentEvent.initialName,
                                isDeleted: false
                            };

                            //store the file
                            playedEventInfo.allFiles[minimalCreateFileEvent.fileId] = newFile;
                        }

                        //store the create file event
                        playedEventInfo.allCreateFileEvents[minimalCreateFileEvent.fileId] = minimalCreateFileEvent;

                        //if there is a comment for this create file event 
                        if(saveComments && playbackData.comments[minimalCreateFileEvent.id]) {

                            //store the array of comments to the collection that will go in the zipped playback data
                            playedEventInfo.allInsertAndCreateComments[minimalCreateFileEvent.id] = playbackData.comments[minimalCreateFileEvent.id];
                        }
                        
                    } else if(currentEvent.type === "Create Directory") { //create dir

                        //make a copy of the current event (some of these properties may be changed by the code that uses this)
                        var minimalCreateDirEvent = {
                            id: currentEvent.id,
                            timestamp: currentEvent.timestamp,
                            type: currentEvent.type,
                            initialName: currentEvent.initialName,
                            directoryId: currentEvent.directoryId,
                            parentDirectoryId: currentEvent.parentDirectoryId,
                            createdByDevGroupId: currentEvent.createdByDevGroupId
                        };

                        //if this dir has not been recorded
                        if(!playedEventInfo.allDirs[minimalCreateDirEvent.directoryId]) {

                            //create a file entry for this new file using the event info
                            var newDirectory = {
                                id: currentEvent.directoryId,
                                parentId: currentEvent.parentDirectoryId,
                                currentName: currentEvent.initialName,
                                isDeleted: false
                            };

                            //store the dir id
                            playedEventInfo.allDirs[minimalCreateDirEvent.directoryId] = newDirectory;
                        }

                        //store the create dir event
                        playedEventInfo.allCreateDirEvents[minimalCreateDirEvent.directoryId] = minimalCreateDirEvent;          

                        //if there is a comment for this create dir event 
                        if(saveComments && playbackData.comments[minimalCreateDirEvent.id]) {

                            //store the array of comments to the collection that will go in the zipped playback data
                            playedEventInfo.allInsertAndCreateComments[minimalCreateDirEvent.id] = playbackData.comments[minimalCreateDirEvent.id];
                        }              
                    }
                }

                return playedEventInfo;
            } 
            
            /*
             * Adds a developer group to an object if it isn't already present. It will also add each developer in the group to the object.
             */
            function addDeveloperGroupAndDevelopersToObject(playedEventInfo, devGroupId) {
                
                //get the dev group based on the id
                var devGroup = playbackData.allDeveloperGroups[devGroupId];

                //if the dev group was found
                if(devGroup) {

                    //store the dev group
                    playedEventInfo.allDeveloperGroups[devGroupId] = devGroup;

                    //get the memberIds in the dev group
                    var memberIdsInADevGroup = devGroup.memberIds;

                    //go through all of the memberIds 
                    for(var i = 0;i < memberIdsInADevGroup.length;i++) {

                        //get a member id from the dev group
                        var devIdInADevGroup = memberIdsInADevGroup[i];

                        //store the dev
                        playedEventInfo.allDevelopers[devIdInADevGroup] = playbackData.allDevelopers[devIdInADevGroup];
                    }

                }//else- dev group was not found
            }

            /*
             * This function gets the current state of the files and dirs in a playback. An array
             * of directory objects is returned that holds the single root dir. A dir object looks
             * like this: 
             * 
             * var currentDir = {
             *     dirId: dirId,       //id of the dir
             *     dirName: dirName,   //name of the dir
             *     dirPath: dirPath,   //path of the dir
             *     parentDirectoryId: "",    //id of the parent dir
             *     subDirs: [],        //list of all sub dirs (gets filled in after the recursive call)
             *     files: [],          //list of all files in the dir (gets filled in after the recursive call)
             * };
             * 
             * The array subDirs holds more child sub-directories. The array files holds the files in a dir. A
             * file object looks like this:
             *  var file = {
             *      fileId: fileId,          //id of the file
             *      fileName: fileName,      //name of the file
             *      filePath: filePath,      //path of the file
             *      parentDirectoryId: "",   //id of the parent dir
             *      insertsByPosition: [[]]  //all events in a file by position (a group of rows)
             * };
             */
            function getCurrentStateOfFileSystem(allInsertEventsOnTheScreen) {

                //get the html element that represents the active files/dirs that are in the 
                //current state of the playback (a ul with id playbackViewOfFileSystem)
                parentElement = document.querySelector("#playbackViewOfFileSystem");

                //contents of the dir that holds the root dir        
                var contentsWithRoot = [];

                //traverse the dom to get the state of the file system
                getCurrentStateOfFileSystemHelper(parentElement, "", contentsWithRoot, allInsertEventsOnTheScreen);

                //return the contents of the file system at this point
                return contentsWithRoot;
            }

            /*
             * Recursive helper that goes through the dom identifying files and dirs.
             */
            function getCurrentStateOfFileSystemHelper(parentElement, pathUpToParent, contents, allInsertEventsOnTheScreen) {

                //go through all of the children of the parent element (a ul with the contents of a dir)
                for(var i = 0;i < parentElement.children.length;i++) {

                    //the types we care about are playbackDirView and playbackFileView

                    //if the child li is a directory that is not hidden
                    if(parentElement.children[i].classList.contains("playbackDirView") && 
                       !parentElement.children[i].classList.contains("hiddenDirectory")) {  
                           
                        //every dir has an li in the playback view of the file system
                        var dirLi = parentElement.children[i];

                        //the dir name is the second child in the li
                        var dirName = dirLi.children[1].innerHTML;

                        //construct a relative path to the dir
                        var dirPath = pathUpToParent + "/" + dirName;
                        
                        //extract the dir id from the li
                        var dirId = dirLi.id.substr("playbackDirView-".length);

                        //build a dir object
                        var currentDir = {
                            dirId: dirId,           //id of the dir
                            dirName: dirName,       //name of the dir
                            dirPath: dirPath,       //path of the dir
                            parentDirectoryId: "",  //id of the parent
                            subDirs: [],            //list of all sub dirs (gets filled in after the recursive call)
                            files: [],              //list of all files in the dir (gets filled in after the recursive call)
                            contents: []            //list of all sub dirs and files (used to fill subDirs and files after the recursive call then deleted)
                        }; 

                        //add the dir object to the contents of the parent dir
                        contents.push(currentDir);

                        //every dir li's third child is a ul with the contents of the dir
                        var dirContentsUl = parentElement.children[i].children[2]; 

                        //recurse 
                        getCurrentStateOfFileSystemHelper(dirContentsUl, dirPath, currentDir.contents, allInsertEventsOnTheScreen);


                        //after the recursive call go through the contents of a directory and:
                        // - assign the parent dir id
                        // - move each file object to the 'files' array
                        // - move each sub dir object to the 'subDirs' array
                        //then remove the contents object altogether
                        //for every file/dir in contents
                        for(var j = 0;j < currentDir.contents.length;j++) {
                            
                            //if there is a 'dirId' property in the object then it is a directory
                            if(currentDir.contents[j]["dirId"]) {
                                
                                //get the dir object
                                var subDir = currentDir.contents[j];

                                //set the child's parent id to the current dir's id
                                subDir.parentDirectoryId = currentDir.dirId;

                                //move the sub dir to the current dir's subDirs array
                                currentDir.subDirs.push(subDir);

                            } else { //no dirId, it must be a file
                                
                                //get the file object
                                var file = currentDir.contents[j];

                                //set the child's parent id to the current dir's id
                                file.parentDirectoryId = currentDir.dirId;

                                //move the file to the current dir's files array
                                currentDir.files.push(file);
                            }
                        }

                        //get rid of the contents since they have all been moved to files and subDirs
                        delete currentDir.contents;

                    } else if(parentElement.children[i].classList.contains("playbackFileView") && //file name list item AND not hidden
                              !parentElement.children[i].classList.contains("hiddenFile")) {                                                    

                        //every file has an li in the playback view of the file system 
                        var fileLi = parentElement.children[i];

                        //the file name is inside an anchor and then the first child (a span with an icon (0) and a text name(1))
                        var fileName = fileLi.children[0].children[1].innerHTML;

                        //construct a relative path to the file
                        var filePath = pathUpToParent + "/" + fileName;

                        //the li has the id of the file in it, extract it and use it to get the id of the playback window
                        var fileId = fileLi.id.substr("playbackViewFile-".length);

                        //build a file object
                        var file = {
                            fileId: fileId,         //id of the file
                            fileName: fileName,     //name of the file
                            filePath: filePath,     //path of the file
                            parentDirectoryId: "",  //id of the parent dir
                            insertsByPosition: [[]] //all events in a file by position (a group of rows)
                        };
                        
                        //get the id of the playback window
                        var playbackWindowId = "playbackWindow-" + file.fileId;

                        //get the playback window associated with the file
                        var playbackWindow = document.querySelector("#" + playbackWindowId);

                        //holds the current row number
                        var row = 0;

                        //go through all the child elements (spans with code in them) in the playback window
                        for(var j = 0;j < playbackWindow.children.length;j++) {
                            
                            //a visible span that has a code character in it
                            var visibleCodeSpan = playbackWindow.children[j];

                            //if a child element is a code char (code, space, newline, or tab) AND
                            //is currently on the screen (not hidden)
                            if(visibleCodeSpan.classList.contains("codeChar") && !visibleCodeSpan.classList.contains("codeNotVisible")) {

                                //get the id of the span which matches the insert event's id
                                var eventId = visibleCodeSpan.getAttribute("id");

                                //use the event id to get the actual event from the map of visible events
                                var event = allInsertEventsOnTheScreen[eventId];

                                //store the event positionally in the correct row and column that it occupies on the screen
                                file.insertsByPosition[row].push(event);

	                            //if the code character is a newline
                                if(visibleCodeSpan.classList.contains("newLine")) {

                                    //moving to a new row
                                    row++;

                                    //add a new empty array for events
                                    file.insertsByPosition.push([]);
                                }
                            } 
                        }

                        //add it to the contents of the parent dir
                        contents.push(file);
                    }
                }
            }

            /*
             * This function gets the data necessary for the editorState.json file from the pause point. It uses
             * the view of the file system to create the pathToIdMap and the inserts by file map. Then it calculates
             * the auto generated numbers that are needed to assign ids.
             */
            function getEditorState(rootfileSystemViewAtPausePoint, playbackDataOnScreenAtPausePoint) {
                
                //editor state info needed for the editor to be able to work with the data in this zip file
                var editorStateJson = {
                    pathToIdMap: {},
                    allInsertEventsByFile: {},
                    autoGeneratedEventId: -1,
                    autoGeneratedFileId: -1,
                    autoGeneratedDirId: -1,
                    autoGeneratedDeveloperId: -1,
                    autoGeneratedDeveloperGroupId: -1,
                };

                //get the pathToIdMap data that goes in the editor state file
                getCurrentPathToIdMap(rootfileSystemViewAtPausePoint, editorStateJson);

                //get the insert events
                getAllInsertEventsByFile(rootfileSystemViewAtPausePoint, editorStateJson);
                
                //get the rest of the data in editorStateJson 
                getGeneratedValuesForEditorState(editorStateJson, playbackDataOnScreenAtPausePoint);

                return editorStateJson;
            }

            /*
             * This function gets the data for the pathToIdMap up to a point in a playback that will go in the editor state 
             */
            function getCurrentPathToIdMap(fileSystemViewAtPausePoint, editorStateJson) {

                //go through the contents of a dir
                for(var i = 0;i < fileSystemViewAtPausePoint.length;i++) {
                    
                    //get a directory
                    var dir = fileSystemViewAtPausePoint[i];

                    //strip the first part of the path, /rootOfProject, from the dir path
                    var alteredDirPath = stripRootFromPath(dir.dirPath);

                    //all dirs in pathToIdMap should end with a slash, if there is not one add it here
                    if(alteredDirPath[alteredDirPath.length - 1] !== "/") {

                        //add a trailing slash if needed
                        alteredDirPath = alteredDirPath + "/";
                    }

                    //store the path to id mapping
                    editorStateJson.pathToIdMap[alteredDirPath] = dir.dirId; 

                    //go through all the files in the dir
                    for(var j = 0;j < dir.files.length;j++) {
                        
                        //get a file from the dir
                        var file = dir.files[j];

                        //strip the first part of the path, /rootOfProject, from the file path
                        var alteredFilePath = stripRootFromPath(file.filePath);

                        //store the path to id mapping
                        editorStateJson.pathToIdMap[alteredFilePath] = file.fileId;
                    } 

                    //recurse
                    getCurrentPathToIdMap(dir.subDirs, editorStateJson);
                }
            }

            /*
             * Removes the root dir from a path. Stripping the root from the relative path is needed in the pathToIdMap.
             */
            function stripRootFromPath(path) {

                //get the position of the second path seperator in the path (first char should be a path separator, 
                //so start looking after the first char)
                var posOfSecondPathSeparator = path.indexOf("/", 1);

                //strip the first part of the path, /rootOfProject, from the dir path
                var alteredPath;
                
                //if there is no second path separator this is just the root
                if(posOfSecondPathSeparator === -1) {

                    //store just the path separator to indicate the root
                    alteredPath = "/";

                } else { //there is a second path separator

                    //get everything but the root
                    alteredPath = path.substr(posOfSecondPathSeparator);
                }

                return alteredPath;
            }

            /*
             * This function gets the data for the allInsertEventsByFile up to a point in a playback that will go in the editor state
             */
            function getAllInsertEventsByFile(fileSystemViewAtPausePoint, editorStateJson) {

                //go through the contents of a dir
                for(var i = 0;i < fileSystemViewAtPausePoint.length;i++) {
                    
                    //get a directory
                    var dir = fileSystemViewAtPausePoint[i];

                    //go through all the files in the dir
                    for(var j = 0;j < dir.files.length;j++) {
                        
                        //get a file from the dir
                        var file = dir.files[j];

                        //create a shadow 2D array of the file's file.insertsByPosition
                        var minimalInsertsByPosition = [];

                        //each file has its insert events, go through them
                        for(var row = 0;row < file.insertsByPosition.length;row++) {

                            //add an empty row
                            minimalInsertsByPosition.push([]);

                            //go through all of the full events in the row
                            for(var col = 0;col < file.insertsByPosition[row].length;col++) {
                                
                                //create a smaller version of the insert event (this matches what gets stored by the editor)
                                var minimalEvent = {
                                    id: file.insertsByPosition[row][col].id,
                                    character: file.insertsByPosition[row][col].character
                                };

                                //add it to the shadow array
                                minimalInsertsByPosition[row].push(minimalEvent);
                            }
                        }

                        //store the events for the file
                        editorStateJson.allInsertEventsByFile[file.fileId] = minimalInsertsByPosition;
                    } 
                    
                    //recurse
                    getAllInsertEventsByFile(dir.subDirs, editorStateJson)
                }
            }

            /*
             * This function looks at the playback data to get valid numbers for the autogenerated values in the editor:
             * - autoGeneratedEventId
             * - autoGeneratedFileId
             * - autoGeneratedDirId
             * - autoGeneratedDeveloperId
             * - autoGeneratedDeveloperGroupId
             */
            function getGeneratedValuesForEditorState(editorStateJson, playbackDataOnScreenAtPausePoint) {
                
                //autoGeneratedEventId
                //if no events have been played back
                if(playbackData.codeEventsIndex === -1) {

                    //set the next valid id to be 0
                    editorStateJson.autoGeneratedEventId = 0;
    
                } else { //there is at least one event played
    
                    //get the id of the last event played back
                    var lastPlaybackEvent = playbackData.codeEvents[playbackData.codeEventsIndex];
                    
                    //pick out the number at the end of the id (there is a 5 digit branch id before it)
                    var lastEventIntId = parseInt(lastPlaybackEvent.id.substr("ev_XXXXX_".length), 10);
                    
                    //add one for the next valid auto generated number
                    editorStateJson.autoGeneratedEventId = lastEventIntId + 1;
                }


                //autoGeneratedFileId
                //largest int part of an id
                var largestFileIntId = 0;

                //go through all of the files
                for(var fileId in playbackDataOnScreenAtPausePoint.allFiles) {
                    if(playbackDataOnScreenAtPausePoint.allFiles.hasOwnProperty(fileId)) {

                        //pick out the number at the end of the id
                        var fileIntId = parseInt(fileId.substr("fileId-".length), 10);

                        //if the latest id is the largest so far
                        if(fileIntId > largestFileIntId) {

                            //store it as the largest
                            largestFileIntId = fileIntId;
                        }
                    }
                }

                //add one for the next valid auto generated number
                editorStateJson.autoGeneratedFileId = largestFileIntId + 1;


                //autoGeneratedDirId
                //largest int part of an id
                var largestDirIntId = 0;

                //go through all of the dirs
                for(var dirId in playbackDataOnScreenAtPausePoint.allDirs) {
                    if(playbackDataOnScreenAtPausePoint.allDirs.hasOwnProperty(dirId)) {

                        //pick out the number at the end of the id
                        var dirIntId = parseInt(dirId.substr("dirId-".length), 10);

                        //if the latest id is the largest so far
                        if(dirIntId > largestDirIntId) {

                            //store it as the largest
                            largestDirIntId = dirIntId;
                        }
                    }
                }

                //add one for the next valid auto generated number
                editorStateJson.autoGeneratedDirId = largestDirIntId + 1;


                //autoGeneratedDeveloperId
                //largest int part of an id
                var largestDevIntId = 0;

                //go through all of the devs
                for(var devId in playbackDataOnScreenAtPausePoint.allDevelopers) {
                    if(playbackDataOnScreenAtPausePoint.allDevelopers.hasOwnProperty(devId)) {

                        //pick out the number at the end of the id
                        var devIntId = parseInt(devId.substr("devId-".length), 10);

                        //if the latest id is the largest so far
                        if(devIntId > largestDevIntId) {

                            //store it as the largest
                            largestDevIntId = devIntId;
                        }
                    }
                }
                
                //add one for the next valid auto generated number
                editorStateJson.autoGeneratedDeveloperId = largestDevIntId + 1;


                //autoGeneratedDeveloperGroupId
                //largest int part of an id
                var largestDevGroupIntId = 0;

                //go through all of the devs
                for(var devGroupId in playbackDataOnScreenAtPausePoint.allDeveloperGroups) {
                    if(playbackDataOnScreenAtPausePoint.allDeveloperGroups.hasOwnProperty(devGroupId)) {
                
                        //get the dev group
                        var devGroup = playbackDataOnScreenAtPausePoint.allDeveloperGroups[devGroupId];

                        //pick out the number at the end of the id
                        var devGroupIntId = parseInt(devGroup.id.substr("devGroupId-".length), 10);

                        //if the latest id is the largest so far
                        if(devGroupIntId > largestDevGroupIntId) {

                            //store it as the largest
                            largestDevGroupIntId = devGroupIntId;
                        }
                    }
                }

                //add one for the next valid auto generated number
                editorStateJson.autoGeneratedDeveloperGroupId = largestDevGroupIntId + 1;
            }

            /*
             * Saves the state of the files/dirs at a certain point in a zip. The file/dir contents are gathered 
             * and added to a zip with the same file structure as the playback view.
             */
            function zipUpCurrentStateOfFiles(fileSystemViewAtPausePoint, zip) {

                //go through the contents of a dir
                for(var i = 0;i < fileSystemViewAtPausePoint.length;i++) {
                    
                    //get a directory
                    var dir = fileSystemViewAtPausePoint[i];

                    //create the folder in the zip (if it doesn't already exist)
                    zip.folder(dir.dirPath);

                    //go through all the files in the dir
                    for(var j = 0;j < dir.files.length;j++) {
                        
                        //get a file from the dir
                        var file = dir.files[j];

                        //holds the text in the file at the current point in the playback
                        var text = "";

                        //each file has its insert events, go through them
                        for(var row = 0;row < file.insertsByPosition.length;row++) {
                            for(var col = 0;col < file.insertsByPosition[row].length;col++) {

                                //add the code character to the text
                                text += file.insertsByPosition[row][col].character;
                            }
                        }

                        //add the text to a zip file
                        zip.file(file.filePath, text);
                    }

                    //recurse
                    zipUpCurrentStateOfFiles(dir.subDirs, zip);
                }
            }

            /*
             * Records all of the playback data for the playbackData.json file and zips it up. A playback may be
             * paused at any point in the middle and the user is given three options for storing the playback data:
             * - minimal history: all history is forgotten except for the code on the screen
             * - no future events: all history up to the pause point is maintained but any history after the pause point is abandoned
             * - future events undone: all history is maintained even events after the pause point but those future events are undone
             * 
             * The choice the user makes decides how mucgh history will be stored in any future development. 
             */
            function zipUpPlaybackData(fileSystemViewAtPausePoint, rootDirName, editorStateJson, playbackDataOnScreenAtPausePoint, zip, typeOfSave, newBranchId) {
                
                //empty object to hold playback data
                var playbackDataJson = {
                    codeEvents: [],
                    allDevelopers: {}, 
                    allDeveloperGroups: {},
                    allFiles: {},
                    allDirs: {},
                    currentDevGroupId: null,
                    comments: {},
                    playbackDescription: {
                        title: playbackData.playbackDescription.title,
                        description: playbackData.playbackDescription.description
                    },
                    branchId: newBranchId
                }; 

                //if this is a minimum history request
                if(typeOfSave === "minimal") {

                    //fill the playback data with the state required at the pause point
                    //only events on the screen and no past history- perfect programmer
                    getPlaybackDataMinimumHistory(playbackDataJson, fileSystemViewAtPausePoint, playbackDataOnScreenAtPausePoint);

                } else if (typeOfSave === "upToPausePoint") { //no future events request

                    //fill the playback data with the state required at the pause point
                    //only events up to the pause point including any past mistakes/changes but nothing beyond the pause point 
                    getPlaybackDataNoFutureEvents(playbackDataJson, playbackDataOnScreenAtPausePoint);
    
                } else { //typeOfSave === "full" all events with future events undone
    
                    //fill the playback data with the state required at the pause point
                    //all the history before and after the pause point with the events afterwar undone by inverse events
                    //inverse of insert is a delete, inverse of a create file is a delete file, etc.
                    getPlaybackDataFutureEventsUndone(playbackDataJson, editorStateJson, newBranchId);
                }

                //create the hidden storyteller files and add them to the zip
                zip.file("/" + rootDirName + "/.storyteller/playbackData.json", JSON.stringify(playbackDataJson));
            }
            
            /*
             * Get the playback data with the minimal amount of history. This function gets the events for only
             * create file/dirs and inserts. All of the create dir events come first the create file events to build 
             * the file structure. Next, the events for each file are added.
             */
            function getPlaybackDataMinimumHistory(playbackDataJson, fileSystemViewAtPausePoint, playbackDataOnScreenAtPausePoint) {
                
                //playbackDataJson.codeEvents
                //create the create file/dir events for the files and dirs that exist
                var createDirEvents = [];
                getCreateDirEventsHelper(fileSystemViewAtPausePoint, createDirEvents, playbackDataOnScreenAtPausePoint.allCreateDirEvents);

                var createFileEvents = [];
                getCreateFileEventsHelper(fileSystemViewAtPausePoint, createDirEvents, playbackDataOnScreenAtPausePoint.allCreateFileEvents);

                //add the events on the screen and adjust their previous neighbor to be in order
                var insertEvents = [];
                getAllInsertEventsHelper(fileSystemViewAtPausePoint, insertEvents);

                //add all the events- create dirs, create files, and inserts to the playback object
                playbackDataJson.codeEvents = createDirEvents.concat(createFileEvents, insertEvents);

                //playbackDataJson.allDevelopers
                playbackDataJson.allDevelopers = playbackDataOnScreenAtPausePoint.allDevelopers;

                //playbackDataJson.allDeveloperGroups
                playbackDataJson.allDeveloperGroups = playbackDataOnScreenAtPausePoint.allDeveloperGroups;

                //playbackDataJson.allFiles
                playbackDataJson.allFiles = playbackDataOnScreenAtPausePoint.allFiles;
                
                //playbackDataJson.allDirs
                playbackDataJson.allDirs = playbackDataOnScreenAtPausePoint.allDirs;

                //playbackDataJson.currentDevGroupId
                playbackDataJson.currentDevGroupId = playbackData.currentDevGroupId;

                //playbackDataJson.comments    
                //only add the comments that are associated with the inserts/create file/create dir            
                playbackDataJson.comments = playbackDataOnScreenAtPausePoint.allInsertAndCreateComments;
            }
            
            /*
             * Gather all of the create dir events for the dirs that were present at the pause point.
             */
            function getCreateDirEventsHelper(fileSystemViewAtPausePoint, createDirEvents, allCreateDirEvents) {
                
                //go through the contents of a dir
                for(var i = 0;i < fileSystemViewAtPausePoint.length;i++) {
                    
                    //get a directory
                    var dir = fileSystemViewAtPausePoint[i];

                    //get the original create directory event
                    var createDirEvent = allCreateDirEvents[dir.dirId];

                    //rewrite the name and parent in case the dir moved or changed since creation 
                    createDirEvent.initialName = dir.dirName;
                    createDirEvent.parentDirectoryId = dir.parentDirectoryId;

                    //add the updated create dir event to the list
                    createDirEvents.push(createDirEvent);
                    
                    //recurse
                    getCreateDirEventsHelper(dir.subDirs, createDirEvents, allCreateDirEvents);
                }
            }

            /*
             * Gather all of the create file events for the files that were present at the pause point.
             */
            function getCreateFileEventsHelper(fileSystemViewAtPausePoint, createFileEvents, allCreateFileEvents) {
                
                //go through the contents of a dir
                for(var i = 0;i < fileSystemViewAtPausePoint.length;i++) {
                    
                    //get a directory
                    var dir = fileSystemViewAtPausePoint[i];

                    //go through all of the files in the directory
                    for(var j = 0;j < dir.files.length;j++) {

                        //get the file
                        var file = dir.files[j];

                        //get the original create file event
                        var createFileEvent = allCreateFileEvents[file.fileId];

                        //rewrite the name and parent in case the file moved or changed since creation 
                        createFileEvent.initialName = file.fileName;
                        createFileEvent.parentDirectoryId = file.parentDirectoryId;

                        //add the updated create file event to the list
                        createFileEvents.push(createFileEvent);
                    }
                    
                    //recurse
                    getCreateFileEventsHelper(dir.subDirs, createFileEvents, allCreateFileEvents);
                }
            }

            /*
             * Gather all of the insert events for the files that were present at the pause point. Each event will 
             * will get rewritten to back up to the event that is directly behind it on the screen. This will 
             * effectively erase all of the history in between the events on the screen.
             */
            function getAllInsertEventsHelper(fileSystemViewAtPausePoint, insertEvents) {
                
                //go through the contents of a dir
                for(var i = 0;i < fileSystemViewAtPausePoint.length;i++) {
                    
                    //get a directory
                    var dir = fileSystemViewAtPausePoint[i];

                    //go through all of the files in the directory
                    for(var j = 0;j < dir.files.length;j++) {

                        //get the file
                        var file = dir.files[j];

                        //holds the id of the previous neighbor (first in the file is "none")
                        var previousNeighborId = "none";

                        //go through all of the events in the file
                        for(var row = 0;row < file.insertsByPosition.length;row++) {
                            for(var col = 0;col < file.insertsByPosition[row].length;col++) {
                                
                                //get the event
                                var event = file.insertsByPosition[row][col];

                                //make each event on the screen refer to the one before it
                                event.previousNeighborId = previousNeighborId;

                                //update the location
                                event.lineNumber = row + 1;
                                event.column = col + 1;

                                //add the event to the list of all events
                                insertEvents.push(event);

                                //set the prev neighbor to this event's id
                                previousNeighborId = event.id; 
                            }
                        }                        
                    }
                    
                    //recurse
                    getAllInsertEventsHelper(dir.subDirs, insertEvents);
                }                
            }

            /*
             * Get all the events from the beginning up to the pause point. All events after the pause point
             * (and the history that goes with them) is gone forever.
             */
            function getPlaybackDataNoFutureEvents(playbackDataJson, playbackDataOnScreenAtPausePoint) {
                
                //playbackDataJson.codeEvents
                //grab all of the events up to the pause point
                playbackDataJson.codeEvents = playbackData.codeEvents.slice(0, playbackData.codeEventsIndex + 1);

                //playbackDataJson.allDevelopers
                playbackDataJson.allDevelopers = playbackDataOnScreenAtPausePoint.allDevelopers;

                //playbackDataJson.allDeveloperGroups
                playbackDataJson.allDeveloperGroups = playbackDataOnScreenAtPausePoint.allDeveloperGroups;

                //playbackDataJson.allFiles
                playbackDataJson.allFiles = playbackDataOnScreenAtPausePoint.allFiles;
                
                //playbackDataJson.allDirs
                playbackDataJson.allDirs = playbackDataOnScreenAtPausePoint.allDirs;

                //playbackDataJson.currentDevGroupId
                playbackDataJson.currentDevGroupId = playbackData.currentDevGroupId;

                //playbackDataJson.comments                
                //only comments up to the pause point
                playbackDataJson.comments = playbackDataOnScreenAtPausePoint.comments;
            }

            /*
             * This function gets all of the events in the playback but undoes each of the events after the pause
             * point. This keeps the history after the pause point but wipes it out in future playbacks in one 
             * big block.
             */
            function getPlaybackDataFutureEventsUndone(playbackDataJson, editorStateJson, newBranchId) {
                
                //playbackDataJson.codeEvents
                //undo all of the events from the end until the pause point
                var undoEvents = [];
                getUndoEvents(undoEvents, editorStateJson, newBranchId);

                //add the existing events from the playback and the undo events
                playbackDataJson.codeEvents = playbackData.codeEvents.concat(undoEvents);

                //playbackDataJson.allDevelopers
                playbackDataJson.allDevelopers = playbackData.allDevelopers;
                
                //playbackDataJson.allDeveloperGroups
                playbackDataJson.allDeveloperGroups = playbackData.allDeveloperGroups;
                
                //playbackDataJson.allFiles
                playbackDataJson.allFiles = playbackData.allFiles;
                
                //playbackDataJson.allDirs
                playbackDataJson.allDirs = playbackData.allDirs;

                //playbackData.currentDevGroupId
                playbackDataJson.currentDevGroupId = playbackData.currentDevGroupId;
                
                //playbackDataJson.comments
                //add all of the comments in the whole playback
                playbackDataJson.comments = playbackData.comments;                
            }

            /*
             * This function creates a series of events to undo or revert the code on the screen to a previous 
             * point. 
             * 
             * Each event has an inverse:
             * Insert ~ Delete
             * Create File ~ Delete File
             * Create Directory ~ Delete Directory
             * Move File ~ Move File
             * Move Directory ~ Move Directory
             * Rename File ~ Rename File
             * Rename Directory ~ Rename Directory
             * 
             * There is some complexity in this situation. All inserts after the pause point that are deleted after 
             * the pause point do not need to be undone because the inserts will naturally get removed from the deletes. 
             * The same is true of create and delete file/dir.
             * 
             * editorStateJson gets passed in because we are adding brand new events to the playbackData.json data 
             * and we need the autoGeneratedEventId to be updated to reflect the new events. The playbackData.json
             * file must be zipped before editorState.json because of this.
             */
            function getUndoEvents(undoEvents, editorStateJson, newBranchId) {
                
                //all the undo events will have the same timestamp
                var timestamp = new Date().getTime();

                //holds the full path of the files at the pause point keyed by their ids
                var idToPathMap = getIdToPathMap(editorStateJson.pathToIdMap);

                //get the last event so that we can create a new unique id
                var lastEvent = playbackData.codeEvents[playbackData.codeEvents.length - 1];

                //get the last event in the playback's id num and increase it
                editorStateJson.autoGeneratedEventId = parseInt(lastEvent.id.substr("ev_XXXXX_".length), 10) + 1;

                //holds the ids of the insert/delete events after the pause point
                var insertedAfterPausePoint = {};
                var deletedAfterPausePoint = {};

                var createdFilesAfterPausePoint = {};
                var deletedFilesAfterPausePoint = {};
                
                var createdDirsAfterPausePoint = {};
                var deletedDirsAfterPausePoint = {};

                //go through the events after the pause point to gather info about events after the pause point
                for(var i = playbackData.codeEventsIndex + 1;i < playbackData.codeEvents.length;i++) {
                
                    //grab the event after the pause point
                    var event = playbackData.codeEvents[i];

                    //if it is a insert
                    if(event.type === "Insert") {
                        
                        //record the id of the insert that is being added
                        insertedAfterPausePoint[event.id] = event.id;

                    } else if(event.type === "Delete") { //delete a character
                        
                        //record the id of the insert that the delete is getting rid of
                        deletedAfterPausePoint[event.previousNeighborId] = event.previousNeighborId;

                    } else if(event.type === "Create File") { //create a file
                        
                        //record the file id that it is getting created
                        createdFilesAfterPausePoint[event.fileId] = event.fileId;

                    } else if(event.type === "Delete File") { //delete a file
                        
                        //record the file id that it is getting rid of
                        deletedFilesAfterPausePoint[event.fileId] = event.fileId;

                    } else if(event.type === "Create Directory") { //create a dir
                        
                        //record the directory id that it is getting created
                        createdDirsAfterPausePoint[event.directoryId] = event.directoryId;

                    } else if(event.type === "Delete Directory") { //delete a dir
                        
                        //record the directory id that it is getting rid of
                        deletedDirsAfterPausePoint[event.directoryId] = event.directoryId;
                    }
                }

                //go through the events after the pause point in reverse to undo any events that aren't naturally 
                //undone by other events after the pause point
                for(var i = playbackData.codeEvents.length - 1;i > playbackData.codeEventsIndex;i--) {
                    
                    //grab the event to 'undo'
                    var event = playbackData.codeEvents[i];

                    //if it was inserted after the pause point AND it was NOT deleted after the pause point
                    if(event.type === "Insert" && deletedAfterPausePoint[event.id] === undefined) {

                        //the inverse of an insert is a delete
                        //fill in the rest of the event details
                        var inverseInsertEvent = {
                            id: "ev_" + newBranchId + "_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId,
                            type: "Delete",
                            character: event.character,
                            previousNeighborId: event.id,
                            lineNumber: -1, //don't know where the event is without an editor
                            column: -1,
                            fileId: event.fileId
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseInsertEvent);

                    //if it was deleted after the pause point AND it was NOT inserted after the pause point
                    } else if(event.type === "Delete" && insertedAfterPausePoint[event.previousNeighborId] === undefined) {

                        //the inverse of a delete is an insert
                        //fill in the rest of the event details
                        var inverseDeleteEvent = {
                            id: "ev_" + newBranchId + "_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId,
                            type: "Insert",
                            character: event.character,
                            previousNeighborId: event.previousNeighborId,
                            lineNumber: -1, //don't know where the event is without an editor
                            column: -1,
                            fileId: event.fileId
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseDeleteEvent);

                    } else if(event.type === "Create File" && deletedFilesAfterPausePoint[event.fileId] === undefined) {

                        //the inverse of a create file is a delete file
                        //fill in the rest of the event details
                        var inverseCreateFileEvent = {
                            id: "ev_" + newBranchId + "_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Delete File",
                            fileId: event.fileId,
                            fileName: event.initialName, 
                            parentDirectoryId: event.parentDirectoryId
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseCreateFileEvent);

                    } else if(event.type === "Delete File" && createdFilesAfterPausePoint[event.fileId] === undefined) {

                        //the inverse of a delete file is a create file
                        //fill in the rest of the event details
                        var inverseDeleteFileEvent = {
                            id: "ev_" + newBranchId + "_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Create File",
                            initialName: event.fileName, 
                            fileId: event.fileId,                            
                            parentDirectoryId: event.parentDirectoryId
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseDeleteFileEvent);

                    } else if(event.type === "Create Directory" && deletedDirsAfterPausePoint[event.directoryId] === undefined) {

                        //the inverse of a create dir is a delete dir
                        //fill in the rest of the event details
                        var inverseCreateDirectoryEvent = {
                            id: "ev_" + newBranchId + "_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Delete Directory",
                            directoryId: event.directoryId,
                            directoryName: event.initialName,
                            parentDirectoryId: event.parentDirectoryId
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseCreateDirectoryEvent);

                    } else if(event.type === "Delete Directory" && createdDirsAfterPausePoint[event.directoryId] === undefined) {

                        //the inverse of a delete dir is a create dir
                        //fill in the rest of the event details
                        var inverseDeleteDirectoryEvent = {
                            id: "ev_" + newBranchId + "_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Create Directory",
                            initialName: event.directoryName, 
                            directoryId: event.directoryId,                            
                            parentDirectoryId: event.parentDirectoryId
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseDeleteDirectoryEvent);

                    } else if(event.type === "Move File") {

                        //the inverse of a move file is another move file
                        //fill in the rest of the event details
                        var inverseMoveFileEvent = {
                            id: "ev_" + newBranchId + "_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Move File",
                            fileId: event.fileId,
                            fileName: event.fileName,
                            newParentDirectoryId: event.oldParentDirectoryId,
                            oldParentDirectoryId: event.newParentDirectoryId,
                            newParentDirectoryName: event.oldParentDirectoryName, 
                            oldParentDirectoryName: event.newParentDirectoryName
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseMoveFileEvent);

                    } else if(event.type === "Move Directory") {

                        //the inverse of a move dir is another move dir
                        //fill in the rest of the event details
                        var inverseMoveDirectoryEvent = {
                            id: "ev_" + newBranchId + "_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Move Directory",
                            directoryId: event.directoryId,
                            directoryName: event.directoryName, 
                            newParentDirectoryId: event.oldParentDirectoryId,
                            oldParentDirectoryId: event.newParentDirectoryId,
                            newParentDirectoryName: event.oldParentDirectoryName,
                            oldParentDirectoryName: event.newParentDirectoryName
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseMoveDirectoryEvent);

                    } else if(event.type === "Rename File") {

                        //the inverse of a rename file is another rename file
                        //fill in the rest of the event details
                        var inverseRenameFileEvent = {
                            id: "ev_" + newBranchId + "_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Rename File",
                            fileId: event.fileId,
                            newFileName: event.oldFileName, 
                            oldFileName: event.newFileName                            
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseRenameFileEvent);

                    } else if(event.type === "Rename Directory") {

                        //the inverse of a rename dir is another rename dir
                        //fill in the rest of the event details
                        var inverseRenameDirectoryEvent = {
                            id: "ev_" + newBranchId + "_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Rename Directory",
                            directoryId: event.directoryId,
                            newDirectoryName: event.oldDirectoryName,
                            oldDirectoryName: event.newDirectoryName
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseRenameDirectoryEvent);
                    }
                }
            }

            /*
             * This function takes a map and inverts the key/value pairs
             */
            function getIdToPathMap(pathToIdMap) {

                //holds the paths of the files keyed by their id
                var idToPathMap = {};

                //go through each path 
                for (var path in pathToIdMap) {
                    if (pathToIdMap.hasOwnProperty(path)) {

                        //get the id of the entry
                        var id = pathToIdMap[path];

                        //store the path keyed by the id
                        idToPathMap[id] = path;
                    }
                }

                return idToPathMap;
            }

            /*
             * Adds the editor state json file to the zip so that someone can begin editing after unzipping.
             */
            function zipUpEditorState(rootDirName, editorStateJson, zip) {
                
                //create the hidden storyteller files and add them to the zip
                zip.file("/" + rootDirName + "/.storyteller/editorState.json", JSON.stringify(editorStateJson));
            }

            /*
             * Finalizes the zip and starts the download process.
             */
            function buildZip(zipFileName, zip) {

                //get the current date/time
                var fileCreationDate = new Date();

                //append the date/time in iso format and add a zip extension
                zipFileName = zipFileName + "-" + fileCreationDate.toISOString() + ".zip";

                //create a blob representation of the zip
                zip.folder("/").generateAsync({type:"blob"}).then(function (blobbedZip) {

                    //create a temp invisible anchor and add it to the page
                    var a = document.createElement("a");
                    document.body.appendChild(a);
                    a.style = "display: none";

                    //create a downloadable blob
                    var blob = new Blob([blobbedZip], {type: "application/zip"});

                    //create a url that holds the zip
                    url = window.URL.createObjectURL(blob);

                    //assign the new with zip data url to the anchor
                    a.href = url;

                    //add a name to the zip
                    a.download = zipFileName;

                    //simulate a click of the button
                    a.click();

                    //clean up the resources for the url
                    window.URL.revokeObjectURL(url);
                    
                    //remove the anchor
                    a.remove();
                });
            }

            //*****************************************************************************
            //                  Version control merging related code
            //                  ------------------------------------
            // Merging in storyteller happens in the browser during playback. The user can
            // choose another branch of development to 'merge' into the current playback
            // by selecting a playback.json file from another repo. The playback will be 
            // altered to show the current code and the merged code. One can begin a merge 
            // at any point during a playback.
            //
            // If there is a line conflict between the two branches both versions of the 
            // code in two different branches will be shown with markers to identify which
            // branch the code came from. If the changes on the two branches happen in 
            // different parts of the file there will not be a conflict and the changes 
            // will be automatically merged.
            //
            // If the user likes how the merge turned out they can download the state of 
            // the playback and continue development on it. If they don't like how the
            // merge turned out they can ignore the playback since no changes to the files
            // happen. They can just refresh their browswer and see the current state of
            // the files.
            //*****************************************************************************

            /*
             * Controls the whole merge operation. Combines non-event data (files, devs, etc) and event 
             * data (inserts, deletes, etc.) into a new playback. The user can review the new playback 
             * with both branches of development and choose to download it as a new repo. Development 
             * can continue based off of this new repo.
             */
            function storytellerMerge(playbackDataBranch2) {

                //get the events in the current playback up to the pause point
                var branch1CodeEvents = playbackData.codeEvents.slice(0, playbackData.codeEventsIndex + 1);

                //get the code events from the branch we are merging in
                var branch2CodeEvents = playbackDataBranch2.codeEvents;

                //get all of the events that are in both branches
                var commonEvents = getCommonEvents(branch1CodeEvents, branch2CodeEvents);
                
                //get the events specific to each branch (slice out the common events at the beginning of both from each branch)
                var branch1OnlyEvents = branch1CodeEvents.slice(commonEvents.length);
                var branch2OnlyEvents = branch2CodeEvents.slice(commonEvents.length);
                
                //combine the events from the two branches into one set that can be played back
                var combinedEvents = combineEventPlaybackData(commonEvents, branch1OnlyEvents, branch2OnlyEvents);

                //combine the merged in branch to this playback's data
                combinedNonEventData = combineNonEventPlaybackData(branch1CodeEvents, playbackData, playbackDataBranch2);

                //update this playback so the user can view what the merge looks like
                playbackData.codeEvents = combinedEvents;
                playbackData.allDeveloperGroups = combinedNonEventData.allDeveloperGroups;
                playbackData.allDevelopers = combinedNonEventData.allDevelopers;
                playbackData.allFiles = combinedNonEventData.allFiles;
                playbackData.allDirs = combinedNonEventData.allDirs;
                playbackData.comments = combinedNonEventData.comments;

                //reset this playback to display the changes
                getPlaybackWindowsReadyForAnimation(true);

                //TODO
                //move to the end of the playback so they can see the final result                
                //disable anything in the browser that may cause data to be sent back to the browser (comments and title/description changes)
                //handle file operations that conflict
            }        

            /*
             * Get all of the events that are present in both branches. All common events will be at the beginning of
             * each collection of events so as soon as one different event is found we know that the common events have
             * ended.
             */
            function getCommonEvents(playbackDataEventsBranch1, playbackDataEventsBranch2) {

                //holds all of the events that are common to both brances
                var commonEvents = [];

                //go through all of the events (one branch may be shorter than the other)
                for(var i = 0;i < playbackDataEventsBranch1.length && i < playbackDataEventsBranch2.length;i++) {

                    //if the two events are the same
                    if(playbackDataEventsBranch1[i].id === playbackDataEventsBranch2[i].id) {

                        //add this to the common events collection
                        commonEvents.push(playbackDataEventsBranch1[i]);

                    } else { //the two events differ for the first time

                        //stop looking for common events
                        break;
                    }
                }

                return commonEvents;
            }

            /*
             * This function combines the playback data (events) from two separate branches of development. The basic
             * output of this operation is a group of events that can be played back to show the development of the
             * first branch, the conflicts that arise when both branches affect the same line(s) of code, and the 
             * development of the second branch:
             * 
             * all common events + non-common branch 1 events + conflict marker events + non-common branch 2 events 
             * 
             * These events are then added to the current playback so the user can view how the system merged the 
             * two branches together. If the user is happy with the merge they can download a copy of the repo.
             * Line conflicts are identified and need to be resolved by the user. This happens in the new repo.
             * 
             * The algorithm is as follows:
             * - get the final state of the common events as if they were animated in a playback. This is the
             *   final state of all of the files where the two branches diverge. The events are in the order they
             *   appeared on the screen at the branch point 
             * - go through the non-common events in branch 1 and branch 2 and indicate how they affect the common
             *   events. If a branch 1 or 2 insert event comes after a common event or deletes a common event the 
             *   common event is marked with a 'branch 1' or 'branch 2' label.
             * - line conflicts are identified when a branch 1 AND a branch 2 event occur on the same line in the
             *   common events. When both branches affect the same common line we need to have a developer resolve 
             *   the changes.
             *   -- we collect the line(s) of common events that are affected by the conflict along with some 
             *      surrounding code if it contains some changes from either branch.
             *   (If one branch affects a line but the other branch does not we do not consider that a conflict
             *   that needs to be resolved manually)
             * - we build up some conflict marker events that will get added to the collection of events that will 
             *   make up a new playback. These events include markers to identify where any line conflicts occurred
             *   along with a copy of some common events. The second branch needs the same common events as a 
             *   starting point that branch 1 had. So, copies of the common events are added back and branch 2
             *   events are updated to affect the copies.
             * - the events are combined from branch 1, the conflict marker events, and the non-common events from
             *   branch 2 (the common events from branch 2 will have already been played back from the first branch)
             * - some comments are added to summarize what happened in the merge
             */
            function combineEventPlaybackData(commonEvents, branch1OnlyEvents, branch2OnlyEvents) {
                
                //create an object to hold all of the common insert events at the branch point for each common file
                var commonInsertEventsAtBranchPoint = {};

                //get an ordered collection of insert events as if they were played back up to the branch point
                //this structure holds the state of the code at the last point the two branches share in common
                getInsertEventsAtFinalPositions(commonEvents, commonInsertEventsAtBranchPoint, "common", true);


                //identify where branch 1 and 2 interact with the common events to find potential conflicts
                //mark common events that have a branch event that backs up to it (either insert or delete)
                markCommonEventsFromBranchEvents(branch1OnlyEvents, "branch1", commonInsertEventsAtBranchPoint);
                markCommonEventsFromBranchEvents(branch2OnlyEvents, "branch2", commonInsertEventsAtBranchPoint);                
                printAffectedFiles(commonInsertEventsAtBranchPoint);//debug


                //identify lines in the common code where both branches have events that affect the same line
                //and collect information about the conflicts
                var allConflicts = getConflicts(commonInsertEventsAtBranchPoint);
                

                //add the non-common events from branch 1 to get a complete set of inserts at the end of branch 1
                //this is used to get the conflict markers relative to the final state of branch 1
                getInsertEventsAtFinalPositions(branch1OnlyEvents, commonInsertEventsAtBranchPoint, "branch1", false);

                //an object that holds the ids of events that were copied from the common events and used to resolve conflicts
                //the events in branch 2 will need to refer to these copies rather than the original common events
                var copiedEventIdMap = {};

                //get the conflict marker events (markers where the conflicts begin and end along with copies of the common events
                //that are needed for branch 2's events to work correctly)
                var conflictMarkerEvents = getConflictMarkerEvents(allConflicts, commonInsertEventsAtBranchPoint, copiedEventIdMap);

                //make the branch 2 events refer to the copies of common events that were created in the last step instead of the originals
                updateBranchEventsToReferToCopies(copiedEventIdMap, branch2OnlyEvents);


                //collect the events to add to a new playback
                var allEventsInNewRepo = [];
                
                //add the common events
                for(var i = 0;i <commonEvents.length;i++) {
                    allEventsInNewRepo.push(commonEvents[i]);
                }

                //add the branch 1 events
                for(var i = 0;i <branch1OnlyEvents.length;i++) {
                    allEventsInNewRepo.push(branch1OnlyEvents[i]);
                }

                //next add the conflict marker events
                for(var i = 0;i <conflictMarkerEvents.length;i++) {
                    allEventsInNewRepo.push(conflictMarkerEvents[i]);
                }

                //finally, add the events (not the common ones) from branch2
                for(var i = 0;i <branch2OnlyEvents.length;i++) {
                    allEventsInNewRepo.push(branch2OnlyEvents[i]);
                }

                //TODO add comments to the events to describe what has happened in the merge

                return allEventsInNewRepo;
            }

            /*
             * This function will get all of the insert events at a point in time in the order they appear on the screen. 
             * 'Create file' events will create a new collection for each file. An 'insert' event will be added after its
             * previous neighbor. A 'delete' event will either remove the insert referred to by its previous neighbor or
             * mark the previous neighbor as deleted depending on the parameter passed in. A branch name will be added
             * to each node specifying where the event came from (common, branch 1, branch 2, merge algo)
             * 
             * A Linked list is created to hold the insert events in order. A hash map is used to quickly find where to
             * insert and remove linked list nodes.
             *
             * The parameter allInsertEventsByFile holds the linked lists of events by file (the fileId is the key in this 
             * object, a linked list/map is the value).
             * 
             * The parameter removeDeletedNodes specifies whether to remove nodes from the linked list/map that are deleted 
             * by delete events. If this is false, the nodes are left in the linked list but marked as deleted. 
             */
            function getInsertEventsAtFinalPositions(allEvents, allInsertEventsByFile, sourceOfEvent, removeDeletedNodes) {
                
                //reference to the current event that will affect the list
                var currentEvent;

                //go through all of the events
                for(var i = 0;i < allEvents.length;i++) {
                    
                    //get the next event
                    currentEvent = allEvents[i];

                    //insert the current event in the linked list
                    insertEventInLinkedListMap(currentEvent, allInsertEventsByFile, sourceOfEvent, removeDeletedNodes);
                }

                return allInsertEventsByFile;
            }
            
            /*
             * This function will take an event and use it to alter the representation of the files. A 'Create File' event
             * will add a new entry for a file. An 'Insert' event will result in a new node being added to a linked list.
             * The new node will be placed after the node specified by the event's previous neighbor id. A 'Delete' event
             * will cause a node to be removed based on the event's previous neighbor id or the previous neighbor will be
             * marked and the node will remain. This recreates a file that is played back.
             * 
             * In order to make this an efficient operation a hash map is used in addition to a linked list to find nodes
             * by their previous neighbor id. Every time a new node is added to the linked list an entry is made in the hash
             * map that holds a reference to the node with that event's id as the key. When a node is removed the hash map
             * is adjusted by removing the key/value pair for that node. 
             */
            function insertEventInLinkedListMap(currentEvent, allInsertEventsByFile, sourceOfEvent, removeDeletedNodes) {

                //if the current event is a create file event
                if(currentEvent.type === "Create File") {
                    
                    //create a dummy node so that all first characters in a file can refer back to a node
                    var firstNode = {
                        event: null,                    //no real event
                        next: null,                     //link to the next node
                        previous: null,                 //link to the previous node
                        createdByBranch: sourceOfEvent  //the branch that is responsible for creating this insert event
                    };

                    //create the empty linked list for a specified file
                    allInsertEventsByFile[currentEvent.fileId] = {                        
                        head: firstNode,                //reference to the first node in the file
                        tail: firstNode,                //reference to the last node in the file
                        nodeMap: {"none": firstNode},   //used to identify nodes in the linked list ("none" is the prev neighbor id for all first characters in a file)
                        numNodes: 1,                    //the number of nodes stored in the node map
                        createdByBranch: sourceOfEvent  //the branch that is responsible for creating this file
                    };

                } else if(currentEvent.type === "Insert") { //insert event

                    //get the list of insert events for the file this event is in
                    var allInsertsInAFile = allInsertEventsByFile[currentEvent.fileId];

                    //create a new node
                    var newNode = {
                        event: currentEvent,            //the insert event
                        next: null,                     //link to the next node
                        previous: null,                 //link to the previous node
                        createdByBranch: sourceOfEvent  //the branch that is responsible for creating this insert event
                    };

                    //if this insert event is the first character in a file (it has a 'none' previous neighbor id)
                    if(currentEvent.previousNeighborId === "none") {

                        //set the new node's next to be the dummy head's next
                        newNode.next = allInsertsInAFile.head.next;
                        
                        //set the new node's previous to the dummy node
                        newNode.previous = allInsertsInAFile.head;

                        //if there is a node past the dummy node
                        if(allInsertsInAFile.head.next) {

                            //set the previous of the node after the dummy node to this new node
                            allInsertsInAFile.head.next.previous = newNode;
                        
                        } else { //there are no nodes other than the dummy head node

                            //make the new node the tail
                            allInsertsInAFile.tail = newNode;
                        }

                        //make the dummy node's next point to the new node
                        allInsertsInAFile.head.next = newNode;

                    } else if(currentEvent.previousNeighborId === allInsertsInAFile.tail.event.id) { //this is an insert at the end of the file

                        //set the new node's previous to be the current tail
                        newNode.previous = allInsertsInAFile.tail;

                        //set the old tail's next to this new node
                        allInsertsInAFile.tail.next = newNode;
                        
                        //add the tail node to the list
                        allInsertsInAFile.tail = newNode;

                    } else { //this is an insert somewhere in the middle of the file

                        //use the event's previous neighbor id to find the node in the linked list that this event refers to
                        var previousNode = allInsertsInAFile.nodeMap[currentEvent.previousNeighborId];

                        //get the next node 
                        var nextNode = previousNode.next;

                        //set the new node's next and previous
                        newNode.next = nextNode;
                        newNode.previous = previousNode;

                        //update the surrounding nodes
                        previousNode.next = newNode;

                        //if there is a next node (an empty file will only have a dummy node)
                        if(nextNode) {

                            //adjust the next node's previous
                            nextNode.previous = newNode;
                        }
                    }
                    
                    //store a reference to the new node that can be looked up by event id
                    allInsertsInAFile.nodeMap[currentEvent.id] = newNode;

                    //increase the size of the list
                    allInsertsInAFile.numNodes++;
                
                } else if(currentEvent.type === "Delete") { //delete event

                    //get the list of insert events for the file this event is in
                    var allInsertsInAFile = allInsertEventsByFile[currentEvent.fileId];
                
                    //get the node that holds the insert event that is deleted
                    var deletedNode = allInsertsInAFile.nodeMap[currentEvent.previousNeighborId];

                    //if the user wants to remove the nodes from the linked list/map
                    if(removeDeletedNodes) {

                        //if the deleted node is the last one in the list (the dummy head will never be removed by an event)
                        if (deletedNode === allInsertsInAFile.tail) { 
                            
                            //make the tail point to the second to last node
                            allInsertsInAFile.tail = deletedNode.previous;
                            
                            //set the new tails's next to null (it is the new end of the list)
                            allInsertsInAFile.tail.next = null;

                        } else { //this is a node in the middle of the list

                            //rearrange the nodes on either side of the deleted node
                            deletedNode.previous.next = deletedNode.next;
                            deletedNode.next.previous = deletedNode.previous;
                        }

                        //decrease the size of the list
                        allInsertsInAFile.numNodes--;

                        //delete the node from the map of all nodes
                        delete allInsertsInAFile.nodeMap[currentEvent.previousNeighborId];
                    
                    } else { //the user would like the deleted node to stay but be marked as deleted

                        //mark the branch that deleted this event
                        deletedNode["deletedBy"] = sourceOfEvent;
                    }

                } //else- an event type that will not affect the final group of insert events
            }

            /*
             * This function takes a collection of events from one of the branches and if the branch event inserts
             * after a common event or deletes a common event then the common event is marked as being affected.
             * This is used later to see if both branches affect events on the same line of common events. If so,
             * we have a conflict that will need to be resolved by a human. 
             */
            function markCommonEventsFromBranchEvents(events, branchName, commonInsertEventsAtBranchPoint) {
                
                //go through all of the events in the branch
                for(var i = 0;i < events.length;i++) {
                    
                    //get the next branch event
                    branchEvent = events[i];

                    //get the inserts for the event's file
                    var allCommonInsertsInAFile = commonInsertEventsAtBranchPoint[branchEvent.fileId];

                    //if this is a file in the common set of files (not a new file to this branch)
                    if(allCommonInsertsInAFile) {

                        //get the linked list node that the insert backs up to
                        var affectedCommonNode = allCommonInsertsInAFile.nodeMap[branchEvent.previousNeighborId];

                        //if there is a node that means the event backs up to a common event
                        if(affectedCommonNode) {

                            //we only care about insert and delete events that may cause a conflict
                            if(branchEvent.type === "Insert") { //insert event
                                
                                //add a member that says the branch contributed an insert event to the common event
                                affectedCommonNode[branchName + "Insert"] = true;

                            } else if(branchEvent.type === "Delete") { //delete event

                                //add a member that says the branch contributed a delete event to the common event
                                affectedCommonNode[branchName + "Delete"] = true;
                        
                            } //else- this is not an event that will cause a conflict

                        } //else- this event backs up to a newer branch event

                    } //else- this is not a common file, it is specific to one of the branches
                }
            }

            /*
             * Helper to help debugging the state of the common events after the branch events have been marked
             */
            function printAffectedFiles(commonInsertEventsAtBranchPoint) {

                //text from the file with +/- for insert and delete and 1/2 for either branch
                var text = "";

                //go through all of the common files
                for (var fileId in commonInsertEventsAtBranchPoint) {
                    if (commonInsertEventsAtBranchPoint.hasOwnProperty(fileId)) {
                        
                        text += "\n**** " + fileId + " ****\n"

                        //get the ordered inserts for the event's file
                        var allCommonInsertsInAFile = commonInsertEventsAtBranchPoint[fileId];

                        //get the start of the text (bypass the dummy node)
                        var node = allCommonInsertsInAFile.head;

                        //while there are more nodes to process
                        while(node) {
                            
                            //if there is an event in the node (there is a dummy node at the beginning of every file)
                            if(node.event) {

                                //if it is a non-printable carriage return
                                if(node.event.character === "\r") {

                                    //add some text for the carriage return
                                    text += "\\r";    

                                } else if(node.event.character === "\n") { //non-printable newline

                                    //add a visible newline and then a real newline
                                    text += "\\n";    

                                } else { //a printable character

                                    //add the character to the output
                                    text += node.event.character;
                                } 

                            } else { //first node

                                //add a marker to indicate the beginning
                                text += "*";
                            }

                            //if a branch affected the node add one or more markers
                            if(node.branch1Insert) {
                                text += "(+1)"
                            }
                            if(node.branch1Delete) {
                                text += "(-1)"
                            }

                            if(node.branch2Insert) {
                                text += "(+2)"
                            }
                            if(node.branch2Delete) {
                                text += "(-2)"
                            }
                            
                            //if the character was a newline
                            if(node.event && node.event.character === "\n") { 

                                //add a visible newline and then a real newline
                                text += "\n";    
                            }
                            
                            //move on to the next node
                            node = node.next;
                        }
                    }
                }

                //display the text
                console.log(text);
            }

            /*
             * When both branches make a change on the same common line of code then a human must resolve which events are valid 
             * and which are not. This function finds lines of the common code that both branches have affected (either with inserts
             * or deletes). Once a conflict line has been found on a line all of the common events that are on that line are 
             * collected (and eventually copied) so that branch 2 has the same common code to work from. 
             *
             * If there are any changes to the lines above or below a conflict line from branch 1 and branch 2 those lines are collected 
             * too so that groups of lines that have changed can be considered together. Doing this attempts to collect groups of changes 
             * to lines in order to minimize the number of conflict markers. It would be inconvenient, for example, if several lines
             * of deletes had their own conflict markers for each line. We are trying to group changes to contiguous lines because
             * they may be related.
             * 
             * The conflict events are defined as the events in between the start and end of the conflict lines along with any contiguous
             * lines directly above or below a conflict line that has been affected by either one of the two branches. 
             */
            function getConflicts(commonInsertEventsAtBranchPoint) {
                
                //holds information about each line conflict in all of the files
                var allLineConflictsByFile = {};

                //go through all of the common files
                for (var fileId in commonInsertEventsAtBranchPoint) {
                    if (commonInsertEventsAtBranchPoint.hasOwnProperty(fileId)) {
                        
                        //every file starts with an empty array of line conflicts
                        allLineConflictsByFile[fileId] = [];

                        //get the ordered inserts for the event's file
                        var allCommonInsertsInAFile = commonInsertEventsAtBranchPoint[fileId];

                        //holds the events in a line(s) that are in conflict 
                        var commonConflictEvents = [];
                        
                        //a flag that says whether we need to make a conflict object or not
                        var createConflictObject = false;

                        //break the file into lines of nodes (with an extra empty unaffected line at the end)
                        var lines = breakFileIntoLines(allCommonInsertsInAFile.head);                        
                        
                        //go through all of the lines
                        for(var i = 0;i < lines.length;i++) {

                            //get the affect that the branches have on a line ("both", "branch 1", "branch 2", "neither")
                            var affectOnLine = checkLine(lines[i]);

                            //if at least one of the branches affected the line
                            if(affectOnLine === "branch 1" || affectOnLine === "branch 2" || affectOnLine === "both") {

                                //add the events from this line to the collection of events that will be considered in conflict
                                addConflictEventsFromLine(lines[i], commonConflictEvents);

                                //if both branches had an affect on the same line then there was a conflict on this line
                                if(affectOnLine === "both") {

                                    //record that we must create a conflict object on the next unaffected line
                                    createConflictObject = true;
                                }

                            } else { //neither branch affected this line

                                //if there was a conflict since the last unaffected line AND 
                                //there are some common events (on an empty file there will not be any)
                                if(createConflictObject && commonConflictEvents.length > 0) {

                                    //create the conflict
                                    var conflictInfo = {                                            
                                        events: commonConflictEvents //get all of the events on and around the conflict line
                                    };

                                    //add the conflict info for this file
                                    allLineConflictsByFile[fileId].push(conflictInfo);

                                    //reset for next time
                                    createConflictObject = false;
                                }

                                //clear the collection of events for the next time around
                                commonConflictEvents = [];                                
                            }
                        }
                    }
                }

                return allLineConflictsByFile;
            }

            /*
             * This takes a linked list of nodes with insert events and turns them into arrays of lines. Each line has one or more
             * nodes in them. The last node in each line (except the last line in the file) is a newline. We duplicate
             * this newline as the first node on the next line so that any branch event that is inserted after the common newline 
             * will be considered part of the next line instead of the current line. So, the first element of every array will either
             * be the dummy node at the beginning of the file or a duplicate newline from the previous line.
             * 
             * An extra line is added at the end so that a file always ends with an unaffected line. This makes identifying conflicts 
             * easier when the last line does not have a newline character at the end of it.
             */
            function breakFileIntoLines(node) {

                //a two dimensional collection of nodes broken up by line
                //create an array for the first line 
                var lines = [ [] ];

                //while there are more lines
                while(node) {

                    //add the node to the latest line 
                    lines[lines.length - 1].push(node);

                    //if we have come to the end of a line
                    if(node.event && node.event.character === "\n") {

                        //create a new line array with the last node in it (we consider each newline at the beginning and end of each line)
                        var nextLine = [node];

                        //add the new line 
                        lines.push(nextLine);
                    }

                    //move to the next node
                    node = node.next;
                }

                //add an empty, unaffected line at the end of the file to make handling the last line easier
                lines.push([]);

                return lines;
            }

            /*
             * Checks a line to see if either branch has affected it. The function returns "neither" if neither branch affects
             * the line. It returns "both" if both branches affect a line. It returns either "branch 1" or "branch 2" if only 
             * one branch affects a line.
             *
             * The last element is not checked to see if it has an insert affect because the first node in each line is either 
             * a dummy node or a duplicate of the previous line's newline. The last node in the line is not checked for an insert 
             * affect because we want those to count for the next line. This is why the newlines are duplicated on the each new 
             * line.
             */
            function checkLine(lineOfNodes) {

                //assume that neither branch affected this line
                var retVal = "neither";

                //if there are any nodes in the line (we added an extra empty line at the end of the file)
                if(lineOfNodes.length > 0) {

                    //used to determine whether a line has a conflict
                    var affectOnABranch = {
                        branch1Affected: false,
                        branch2Affected: false
                    };

                    //we check the first node for its insert affect only (the first node of each line is either the 
                    //dummy node or a duplicate of the previous line's newline we handle those deletes at the end of
                    //the previous line)
                    getInsertAffectOnLine(lineOfNodes[0], affectOnABranch);

                    //go through the second to the second to last element
                    for(var i = 1;i < lineOfNodes.length - 1;i++) {

                        //we check all of the interior nodes for both insert and delete
                        getInsertAffectOnLine(lineOfNodes[i], affectOnABranch);
                        getDeleteAffectOnLine(lineOfNodes[i], affectOnABranch);
                    }

                    //if this is the last node in a file
                    if(lineOfNodes[lineOfNodes.length - 1].next === null) {
                        
                        //we check the last node in the file for an insert affect only
                        getInsertAffectOnLine(lineOfNodes[lineOfNodes.length - 1], affectOnABranch);                    
                    
                    } //else- not the last node in the last line in the file, we don't check these for insert affect

                    //we check the last node for delete only
                    getDeleteAffectOnLine(lineOfNodes[lineOfNodes.length - 1], affectOnABranch);
                    
                    //now evaluate based on what happened in the line
                    if(affectOnABranch.branch1Affected && affectOnABranch.branch2Affected) {
                        retVal = "both";
                    } else if(affectOnABranch.branch1Affected) {
                        retVal = "branch 1";
                    } else if(affectOnABranch.branch2Affected) {
                        retVal = "branch 2";
                    } //else- default of "neither"
                }

                return retVal;
            }

            /*
             * Checks whether a branch event was inserted after a common event
             */
            function getInsertAffectOnLine(node, affectOnABranch) {
                
                //if branch 1 affected this common node with an insert
                if(node.branch1Insert) {
                    
                    //mark the node
                    affectOnABranch.branch1Affected = true;
                }

                //if branch 2 affected this common node with an insert
                if(node.branch2Insert) {
                    
                    //mark the node
                    affectOnABranch.branch2Affected = true;
                }
            }

            /*
             * Checks whether a branch event deleted a common event
             */
            function getDeleteAffectOnLine(node, affectOnABranch) {
                
                //if branch 1 affected this common node with a delete
                if(node.branch1Delete) {
                    
                    //mark the node
                    affectOnABranch.branch1Affected = true;
                }

                //if branch 2 affected this common node with a delete
                if(node.branch2Delete) {
                    
                    //mark the node
                    affectOnABranch.branch2Affected = true;
                }
            }

            /*
             * Copis the events from the nodes in a line skipping the first node since it is either a dummy node or a duplicate
             * of the previous line's newline.
             */
            function addConflictEventsFromLine(lineOfNodes, commonConflictEvents) {

                //the first element on each line is a duplicate of the last node on the previous line (or a dummy node if its 
                //the first line) so always ignore the first element and collect the events from the rest of the line
                for(var i = 1;i < lineOfNodes.length;i++) {

                    //add the event from the node
                    commonConflictEvents.push(lineOfNodes[i].event);
                }
            }

            /*
             * This generates new events to be added to a playback. The events mark where the conflict lines begin and end and also
             * are copies of the common code so that the second branch events can work from a known starting state.
             *
             * There are two important points for each conflict:
             * - the start of the line where there is a conflict 
             * - the end of the line where there is a conflict 
             * A conflict marker will be added before the start of the conflict line to identify where branch 1's state begins.
             * A conflict marker will be added after the conflict line to mark where branch 1's version ends and branch 2 begins.
             * Copies of the common events will be added after the second conflict marker which holds copies of the common events.
             * A final conflict marker will come after the copies of the events to mark where branch 2's state ends.
             * The events from branch 2 will be altered so that if they refer to one of the events that was copied they will now
             * refer to those copies instead of the original common events. This will make the second branch work from the copies
             * and the user can see how the second branch affected the common code.
             * 
             * Afterwards the user will see branch 1's final state along with branch 2's final state. The user can then resolve
             * the conflicts manually.
             *
             * An array of all of the conflict events is passed in. The final state of branch 1 is also passed in so that the markers
             * can be added to the correct positions of the code that will be on the screen at that point. A map of copied events is
             * passed in so that they can be updated in branch 2 later.
             */
            function getConflictMarkerEvents(allConflicts, branch1EventsAtEnd, copiedEventIdMap) {

                //create a new branch for these conflict marker events
                var newBranchId = createRandomNumberBase62(5);

                //sequence number
                var uniqueId = 0;

                //get the timestamp of the merge- all conflict marker events will have the same timestamp
                var timestamp = new Date().getTime();

                //holds all of the new resolution events 
                var allConflictMarkerEvents = [];

                //go through all of the conflicts by file
                for (var fileId in allConflicts) {
                    if (allConflicts.hasOwnProperty(fileId)) {

                        //get the conflict data for a file
                        var setOfConflictsByFile = allConflicts[fileId];

                        //if there are any conflicts for this file (there may be some branch 1 created files in this object that will not have any conflicts)
                        if(setOfConflictsByFile) {

                            //go through all of the individual conflicts in this file
                            for(var i = 0;i < setOfConflictsByFile.length;i++) {

                                //text to insert to identify where the two branches start and stop
                                var branch1BeginIdentifyingtext = "<=~b1~=>\r\n";//"<== Branch 1 begins ==>\r\n";
                                var branch2BeginIdentifyingtext = "<=~b2~=>\r\n";//"<== Branch 1 ends, Branch 2 begins ==>\r\n";
                                var branch2EndIdentifyingtext = "<=~~=>";//"<== Branch changes end ==>";

                                //get a conflict object
                                var conflict = setOfConflictsByFile[i];

                                //holds the nodes in branch 1 where the conflicts will go
                                var startOfConflictNodeFromBranch1;
                                var endOfConflictNodeFromBranch1;

                                //get the start and end events for this conflict (the event objects are from the common collection not branch 1)
                                var firstConflictEvent = conflict.events[0];
                                var lastConflictEvent = conflict.events[conflict.events.length - 1];
                                
                                //search for the beginning of the line in branch 1 (the conflict events are from the common code- there may be
                                //some branch 1 events that have been added. We want to get to the beginning of the line)
                                var searchNode = branch1EventsAtEnd[fileId].nodeMap[firstConflictEvent.id];

                                //while we haven't reached the beginning of the file
                                while(searchNode) {

                                    //record the latest node relative to the start of the conflict
                                    startOfConflictNodeFromBranch1 = searchNode;

                                    //if we have reached the beginning of the file OR the last common newline that has not been deleted
                                    if(searchNode.previous === null || (searchNode.event.character === "\n" && searchNode.createdByBranch === "common" && !searchNode.deletedBy)) {
                                        
                                        //stop looking
                                        break;
                                    }

                                    //move to the previous node
                                    searchNode = searchNode.previous;
                                }                                
                                
                                //search for the end of the line in branch 1 (the conflict events are from the common code- there may be
                                //some branch 1 events that have been added. We want to get to the end of the line)
                                searchNode = branch1EventsAtEnd[fileId].nodeMap[lastConflictEvent.id];

                                //while we haven't reached the end of the file
                                while(searchNode) {

                                    //record the latest node relative to the end of the conflict
                                    endOfConflictNodeFromBranch1 = searchNode;

                                    //if we have reached the end of the file OR the last common newline that has not been deleted
                                    if(searchNode.next === null || (searchNode.event.character === "\n" && searchNode.createdByBranch === "common" && !searchNode.deletedBy)) {
                                        break;
                                    }

                                    //move to the next node
                                    searchNode = searchNode.next;
                                }
                                                                                                
                                //add some events that id where the conflict starts in branch 1
                                //go through the each character and create an event for it
                                for(var j = 0;j < branch1BeginIdentifyingtext.length;j++) {
                                    
                                    //get a character to display
                                    var eventCharacter = branch1BeginIdentifyingtext[j];

                                    //create a code event
                                    var newEvent = {
                                        id: "ev_" + newBranchId + "_" + uniqueId++, //generate a unique id
                                        timestamp: timestamp, //use the same timestamp
                                        type: "Insert", //inserting new text
                                        character: eventCharacter, //the character from the string above
                                        previousNeighborId: null, //set below based on the node
                                        createdByDevGroupId: playbackData.currentDevGroupId, //dev group
                                        lineNumber: -1, //we don't know the exact line number/column where this event will land yet- use defaults
                                        column: -1,
                                        fileId: fileId, 
                                        pastedEventId: null //this is not a copy of an existing event
                                    };

                                    //if this is the first character in the string
                                    if(j === 0) {

                                        //if the node in branch 1 has an event (the dummy node at the head of every list does not have one)
                                        if(startOfConflictNodeFromBranch1.event) {

                                            //use the previous node's event id for the previous neighbor
                                            newEvent.previousNeighborId = startOfConflictNodeFromBranch1.event.id;

                                        } else { //the node does not have an event (first character in a file)

                                            //the first character in a file always has a previous neighbor of 'none'
                                            newEvent.previousNeighborId = "none";
                                        }

                                    } else { //this is beyond the first character in the string

                                        //make the prev neighbor the last new event that we created
                                        newEvent.previousNeighborId = allConflictMarkerEvents[allConflictMarkerEvents.length - 1].id;
                                    }

                                    //add the new resolution event into the collection of branch1 events so that future conflicts can refer to these new events 
                                    insertEventInLinkedListMap(newEvent, branch1EventsAtEnd, "merge algo", false);

                                    //add the new event
                                    allConflictMarkerEvents.push(newEvent);
                                }


                                //add some events that id where the conflict ends in branch 1 and starts in branch 2

                                //if the last character is not a newline (happens when a change happens on the last line of a file without a newline)
                                if(endOfConflictNodeFromBranch1.event.character !== "\n") {

                                    //add a newline to the beginning of the text
                                    branch2BeginIdentifyingtext = "\r\n" + branch2BeginIdentifyingtext;
                                }
                                
                                //go through the each character and create an event for it
                                for(var j = 0;j < branch2BeginIdentifyingtext.length;j++) {

                                    //get a character to display
                                    var eventCharacter = branch2BeginIdentifyingtext[j];

                                    //create a code event
                                    var newEvent = {
                                        id: "ev_" + newBranchId + "_" + uniqueId++, //generate a unique id
                                        timestamp: timestamp, //use the same timestamp
                                        type: "Insert", //inserting new text
                                        character: eventCharacter, //the character from the string above
                                        previousNeighborId: null, //set below
                                        createdByDevGroupId: playbackData.currentDevGroupId, //dev group
                                        lineNumber: -1, //we don't know the exact line number/column where this event will land yet- use defaults
                                        column: -1,
                                        fileId: fileId,
                                        pastedEventId: null //this is not a copy of an existing event
                                    };

                                    //if this is the first character in the string
                                    if(j === 0) {

                                        //make the prev neighbor the end of the conflict event from branch 1
                                        newEvent.previousNeighborId = endOfConflictNodeFromBranch1.event.id;
                                    
                                    } else { //not the first character in the string

                                        //make the prev neighbor the last new event that we created
                                        newEvent.previousNeighborId = allConflictMarkerEvents[allConflictMarkerEvents.length - 1].id;
                                    }

                                    //add the new resolution event into the collection of branch1 events so that future conflicts can refer to these new events 
                                    insertEventInLinkedListMap(newEvent, branch1EventsAtEnd, "merge algo", false);

                                    //add the new event
                                    allConflictMarkerEvents.push(newEvent);
                                }


                                //now make copies of the common events so that the second branch can work from a consistent starting state when the branch occurred
                                for(var j = 0;j < conflict.events.length;j++) {

                                    //copy the common event
                                    var copyOfEvent = Object.assign({}, conflict.events[j]); 
                                    
                                    //update the copied event
                                    copyOfEvent.id = "ev_" + newBranchId + "_" + uniqueId++; //generate a unique id
                                    copyOfEvent.timestamp = timestamp; //use the same timestamp
                                    copyOfEvent.previousNeighborId = allConflictMarkerEvents[allConflictMarkerEvents.length - 1].id; //make the prev neighbor the last new event that we created
                                    copyOfEvent.lineNumber = -1; //we don't know the exact line number/column where this event will land yet- use defaults
                                    copyOfEvent.column = -1;
                                    copyOfEvent.pastedEventId = conflict.events[j].id; //mark this new event as a copy of another (the common event)

                                    //add the new resolution event into the collection of branch1 events so that future conflicts can refer to these new events 
                                    insertEventInLinkedListMap(copyOfEvent, branch1EventsAtEnd, "merge algo", false);

                                    //add the new event
                                    allConflictMarkerEvents.push(copyOfEvent);

                                    //store the id of the original event and the new copy's new id (these will be changed in all of the branch 2 
                                    //events so that they refer to the copies not the originals)  
                                    copiedEventIdMap[conflict.events[j].id] = copyOfEvent.id;                                    
                                }
                                

                                //add some events that id where the conflicts end

                                //if the last character is not a newline (happens when a change happens on the last line of a file)
                                if(allConflictMarkerEvents[allConflictMarkerEvents.length - 1].character !== "\n") {

                                    //add a newline to the beginning of the text
                                    branch2EndIdentifyingtext = "\r\n" + branch2EndIdentifyingtext;

                                } else {

                                    //add a newline to the end of the text
                                    branch2EndIdentifyingtext = branch2EndIdentifyingtext + "\r\n";
                                    
                                }

                                //go through the each character and create an event for it
                                for(var j = 0;j < branch2EndIdentifyingtext.length;j++) {

                                    //get a character to display
                                    var eventCharacter = branch2EndIdentifyingtext[j];

                                    //create a code event
                                    var newEvent = {
                                        id: "ev_" + newBranchId + "_" + uniqueId++, //generate a unique id
                                        timestamp: timestamp, //use the same timestamp
                                        type: "Insert", //inserting new text
                                        character: eventCharacter, //the character from the string above
                                        previousNeighborId: allConflictMarkerEvents[allConflictMarkerEvents.length - 1].id, //make the prev neighbor the last new event that we created
                                        createdByDevGroupId: playbackData.currentDevGroupId, //dev group
                                        lineNumber: -1, //we don't know the exact line number/column where this event will land yet- use defaults
                                        column: -1,
                                        fileId: fileId,
                                        pastedEventId: null //this is not a copy of an existing event
                                    };

                                    //add the new resolution event into the collection of branch1 events so that future conflicts can refer to these new events 
                                    insertEventInLinkedListMap(newEvent, branch1EventsAtEnd, "merge algo", false);

                                    //add the new event
                                    allConflictMarkerEvents.push(newEvent);
                                }
                            }                            
                        }
                    }
                }

                return allConflictMarkerEvents;
            }

            /*
             * This function updates the events in branch 2 to refer to the new conflict marker copied events.
             * This includes insert and delete events from branch 2 that have a previous neighbor that was copied
             * and pasted event ids.
             */
            function updateBranchEventsToReferToCopies(copiedEventIdMap, branch2Events) {

                //go through all of the branch events
                for(var i = 0;i <branch2Events.length;i++) {

                    //get the branch event 
                    var branchEvent = branch2Events[i];
                    
                    //if the branch event is an insert or a delete
                    if(branchEvent.type === "Insert" || branchEvent.type === "Delete") {

                        //we can't guarantee that the line/column numbers are correct with all of the new code that was added 
                        //in the resoultion, clear them (with the special value -1)
                        branchEvent.lineNumber = -1;
                        branchEvent.column = -1;
                        
                        //if the branch event backs up to one of the copied common events
                        if(copiedEventIdMap[branchEvent.previousNeighborId]) {

                            //change the branch event's previous neighbor to the id of the copied event
                            branchEvent.previousNeighborId = copiedEventIdMap[branchEvent.previousNeighborId];
                        }

                        //if a branch event was pasted from one of the original events
                        if(branchEvent.pastedEventId && copiedEventIdMap[branchEvent.pastedEventId]) {

                            //update the paste parent id
                            branchEvent.pastedEventId = copiedEventIdMap[branchEvent.pastedEventId];
                        }
                    }
                }
            }

            /*
             * Combine all devs, dev groups, files, dirs, comments and ensure there are no conflicts between their ids
             */
            function combineNonEventPlaybackData(branch1CodeEvents, playbackDataBranch1, playbackDataBranch2) {

                //we may not be using all of the branch 1 events, get only the playback data through the used ones
                var combinedPlaybackData = getPlaybackDataThroughEvents(branch1CodeEvents, playbackDataBranch1);

                //combine branch 1 and branch 2 non-event playback data                
                //go through all of branch 2's developer groups 
                for(var devGroupId in playbackDataBranch2.allDeveloperGroups) {
                    if(playbackDataBranch2.allDeveloperGroups.hasOwnProperty(devGroupId)) {

                        //if the combined object does not have the data from branch 2
                        if(!combinedPlaybackData.allDeveloperGroups[devGroupId]) {

                            //add the dev group from branch 2
                            combinedPlaybackData.allDeveloperGroups[devGroupId] = playbackDataBranch2.allDeveloperGroups[devGroupId];
                        }
                    }
                }

                //go through all of branch 2's developers 
                for(var devId in playbackDataBranch2.allDevelopers) {
                    if(playbackDataBranch2.allDevelopers.hasOwnProperty(devId)) {

                        //if the combined object does not have the data from branch 2
                        if(!combinedPlaybackData.allDevelopers[devId]) {

                            //add the developer from branch 2
                            combinedPlaybackData.allDevelopers[devId] = playbackDataBranch2.allDevelopers[devId];
                        }
                    }
                }

                //go through all of branch 2's files
                for(var fileId in playbackDataBranch2.allFiles) {
                    if(playbackDataBranch2.allFiles.hasOwnProperty(fileId)) {

                        //if the combined object does not have the data from branch 2
                        if(!combinedPlaybackData.allFiles[fileId]) {

                            //add the file from branch 2
                            combinedPlaybackData.allFiles[fileId] = playbackDataBranch2.allFiles[fileId];
                        }
                    }
                }

                //go through all of branch 2's directories
                for(var dirId in playbackDataBranch2.allDirs) {
                    if(playbackDataBranch2.allDirs.hasOwnProperty(dirId)) {

                        //if the combined object does not have the data from branch 2
                        if(!combinedPlaybackData.allDirs[dirId]) {

                            //add the directory from branch 2
                            combinedPlaybackData.allDirs[dirId] = playbackDataBranch2.allDirs[dirId];
                        }
                    }
                }

                //go through all of branch 2's comments
                for(var eventId in playbackDataBranch2.comments) {
                    if(playbackDataBranch2.comments.hasOwnProperty(eventId)) {

                        //if the combined object does not have the data from branch 2
                        if(!combinedPlaybackData.comments[eventId]) {

                            //add the directory from branch 2
                            combinedPlaybackData.comments[eventId] = playbackDataBranch2.comments[eventId];
                        }
                    }
                }

                return combinedPlaybackData;
            }

            /*
             * Collects the developers, developer groups, files/directories, and comments for a group of events. 
             */
            function getPlaybackDataThroughEvents(events, originalPlaybackData) {

                //the playback data that is used in this playback 
                var newPlaybackData = {
                    allDevelopers: {},
                    allDeveloperGroups: {},
                    allFiles: {},
                    allDirs: {},
                    comments: {}
                };

                //go through all of the events 
                for(var i = 0;i < events.length;i++) {

                    //get an event
                    var event = events[i];

                    //if we haven't already stored this dev group
                    if(!newPlaybackData.allDeveloperGroups[event.createdByDevGroupId]) {
                        
                        //copy the dev group from the original
                        newPlaybackData.allDeveloperGroups[event.createdByDevGroupId] = originalPlaybackData.allDeveloperGroups[event.createdByDevGroupId];
                    }
                    
                    //now handle files and directories
                    //if this is a create file
                    if(event.type === "Create File") {

                        //create a new file object
                        var newFile = {
                            id: event.fileId,
                            parentId: event.parentDirectoryId,
                            currentName: event.initialName,
                            isDeleted: false
                        };

                        //add the file to the object of all files
                        newPlaybackData.allFiles[event.fileId] = newFile;

                    } else if(event.type === "Delete File") {

                        //update the file in the collection of all files
                        newPlaybackData.allFiles[event.fileId].isDeleted = true;
                        
                    } else if(event.type === "Rename File") {
                                
                        //update the current name of the file in the collection of all files
                        newPlaybackData.allFiles[event.fileId].currentName = event.newFileName;

                    } else if(event.type === "Move File") {

                        //update the new parent of the file in the collection of all files
                        newPlaybackData.allFiles[event.fileId].parentId = event.newParentDirectoryId;
                        
                    } else if(event.type === "Create Directory") {
                        
                        //create a new directory object
                        var newDirectory = {
                            id: event.directoryId,
                            parentId: event.parentDirectoryId,
                            currentName: event.initialName,
                            isDeleted: false
                        };

                        //add the directory to the object of all directories
                        newPlaybackData.allDirs[event.directoryId] = newDirectory;

                    } else if(event.type === "Delete Directory") {

                        //recursively delete all sub-dir and files
                        deleteDirectoryInAllDirs(event.directoryId, newPlaybackData);
                        
                    } else if(event.type === "Rename Directory") {
                        
                        //update the current name of the dir in the collection of all dirs
                        newPlaybackData.allDirs[event.directoryId].currentName = event.newDirectoryName;

                    } else if(event.type === "Move Directory") {

                        //update the new parent of the dir in the collection of all dirs
                        newPlaybackData.allDirs[event.directoryId].parentId = event.newParentDirectoryId;
                    } 

                    //handle comments
                    //if this event was a comment point in the original playback data
                    if(originalPlaybackData.comments[event.id]) {

                        //add the comment to the playback data
                        newPlaybackData.comments[event.id] = originalPlaybackData.comments[event.id];
                    }
                }

                //go through all of the dev groups in the branch 
                for(var devGroupId in newPlaybackData.allDeveloperGroups) {
                    if(newPlaybackData.allDeveloperGroups.hasOwnProperty(devGroupId)) {

                        //get the dev group
                        var devGroup = newPlaybackData.allDeveloperGroups[devGroupId];

                        //go through the member ids for this group
                        for(var i = 0;i < devGroup.memberIds.length;i++) {

                            //get the member id
                            var memberId = devGroup.memberIds[i];

                            //if we have not added the developer yet
                            if(!newPlaybackData.allDevelopers[memberId]) {
                                
                                //add the developer to the branch data
                                newPlaybackData.allDevelopers[memberId] = originalPlaybackData.allDevelopers[memberId];
                            }
                        }
                    }
                }

                return newPlaybackData;
            }

            /*
             * Helper to recursively delete files and directories when a directory is deleted.
             */
            function deleteDirectoryInAllDirs(deletedDirId, newPlaybackData) {
                
                //go through all of the dirs 
                for(var dirId in newPlaybackData.allDirs) {
                    if(newPlaybackData.allDirs.hasOwnProperty(dirId)) {

                        //if a dir has the deleted dir as a parent AND
                        //it has not already been deleted
                        if(newPlaybackData.allDirs[dirId].parentId === deletedDirId &&
                           newPlaybackData.allDirs[dirId].isDeleted === false) {
                            
                            //delete the sub-dir in the deleted directory
                            deleteDirectoryInAllDirs(dirId, newPlaybackData);
                        }
                    }
                }

                //go through all of the files 
                for(var fileId in newPlaybackData.allFiles) {
                    if(newPlaybackData.allFiles.hasOwnProperty(fileId)) {
                        
                        //if a file has the deleted dir as a parent AND
                        //it has not already been deleted
                        if(newPlaybackData.allFiles[fileId].parentId === deletedDirId &&
                           newPlaybackData.allFiles[fileId].isDeleted === false) {
                            
                            //update the file in the collection of all files
                            newPlaybackData.allFiles[fileId].isDeleted = true;
                        }
                    }
                }

                //update the dir in the collection of all files
                newPlaybackData.allDirs[deletedDirId].isDeleted = true;
            }


            //*****************************************************************************
            //                    Line number/highlighting related code
            //                    -------------------------------------
            // This code has to do with showing and hiding line numbers
            //*****************************************************************************
            /*
             * Adds a line number if the passed in element is a newline. It doesn't matter what the value of the line number 
             * is since they are increasing automatically. This is called when making code visible.
             */
            function addLineNumberIfNecessary(codeElement, fileId) {

                //if we are displaying a new newline character, add a new line number
                if(codeElement.tagName.toLowerCase() === "br") {

                    //get the gutter
                    var lineNumberGutter = document.querySelector("#lineNumberGutter-" + fileId);

                    //create a div with the lineNum class
                    var newLineNumberSpan = document.createElement("div");
                    newLineNumberSpan.classList.add("lineNum");

                    //add a new line number to the end of the gutter
                    lineNumberGutter.appendChild(newLineNumberSpan);
                }
            }

            /*
             * Removes a line number if the passed in element is a newline. It doesn't matter that we remove the line number div 
             * where the event happened since they are constantly increasing. This is called when making code invisible.
             */
            function removeLineNumberIfNecessary(codeElement, fileId) {

                //if we are hiding a newline, remove a new line number
                if(codeElement.tagName.toLowerCase() === "br") {

                    //get the line number gutter and remove a line number
                    //(any one if fine, removing last is probably quickest)
                    var lineNumberGutter = document.querySelector("#lineNumberGutter-" + fileId);
                    lineNumberGutter.removeChild(lineNumberGutter.lastChild);
                }
            }

            /*
             * Highlights a given line number.
             */
            function highlightLine(lineNumber, fileId) {

                //get the line number gutter for a file
                var lineNumberGutter = document.querySelector("#lineNumberGutter-" + fileId);

                //if the latest event happened on a different line than the last one OR in a different file
                if(playbackData.activeLineNumber !== lineNumber || playbackData.activeFileId !== fileId) {

                    //remove the previously highlighted line in the current file
                    var allCurrentLines = document.querySelectorAll("#lineNumberGutter-" + fileId + " .currentLine");
                    for(var i = 0;i < allCurrentLines.length;i++) {
                        allCurrentLines[i].classList.remove("currentLine");
                    }

                    //store the new active line number
                    playbackData.activeLineNumber = lineNumber;                    

                    //add a style to highlight the active line
                    lineNumberGutter.children[lineNumber - 1].classList.add("currentLine");
                }
            }
            //*****************************************************************************
            //                         Scrolling related code
            //                         ----------------------
            // This code has to do with scrolling to the active code event during a playback
            //*****************************************************************************
            /*
             * Handle the situation when a piece of code is off of the playback window. This
             * function will scroll (vertically and horizontally) to make sure the code element
             * can be seen on the screen.
             * 
             * Handles scrolling by looking at the height of the #playbackWindows
             * div which owns the scroll bars. Find the distance from the top of the
             * #playbackWindows div where the code element is and if the code element is off
             * the #playbackWindows div it scrolls down.
             * 
             * Similar for horizontal scroll, look for a position near the character and scroll there
             *
             * all <br>'s seem to have an offsetTop of 0, this requires us to not scroll
             * for <br>'s otherwise we would bounce up and down at every line break.
             */
            function handleScroll(codeElement) {

                //if the element is not a BR
                if(codeElement.tagName.toLowerCase() !== "br") {
                
                    //get the playback container (the parent of the playback windows, playback tabs and the owner of the scroll bars)
                    var scrollablePlaybackContainer = document.querySelector("#playbackWindows");

                    //get the height of the owner of the scrollbars, #playbackWindows
                    var parentNodeClientHeight = scrollablePlaybackContainer.clientHeight;

                    //get the width of the parent to this code element, a playbackWindow
                    var parentNodeClientWidth = codeElement.parentNode.clientWidth;

                    //get the distance from the top edge of the parent 
                    //get the amount of pixels that the element is underneath the scrollablePlaybackContainer's height
                    var verticalDiff = codeElement.offsetTop - parentNodeClientHeight;
                    
                    //get the distance from the left edge of the parent
                    //get the amount of pixels that the element is to the right of the playback window's width
                    var horizontalDiff = codeElement.offsetLeft - parentNodeClientWidth;
 
                    //create a vertical scroll position that will place the character in the middle of the screen
                    var targetScrollTop = verticalDiff + (parentNodeClientHeight / 2);

                    //create a horizontal scroll position that will place some space after the character if it is at the end of a line
                    var targetScrollLeft = horizontalDiff + 100;
                    
                    //object that says where to scroll to
                    var properties = {
                        scrollTop: targetScrollTop, 
                        scrollLeft: targetScrollLeft
                    };

                    //make the scrollablePlaybackContainer scroll to the difference plus a little extra
                    $(scrollablePlaybackContainer).animate(properties, playbackData.delay, "linear");
                
                } //else- can't scroll to a BR (TODO can we scroll to a line number div??)
            }
            
            //*****************************************************************************
            //                         Filter related code
            //                         ----------------------
            // This code has to do with filtering code events to find the relevant ones for
            // playback. There is a filter function that filters by time, developer group
            // id, and file. There is another filter function that filters by the selected
            // text on the screen.
            //*****************************************************************************
            /*
             * Filters the events of a playback by time, dev group id, and by file.
             */
            function filterPlayback(filterInfo) {

                //event info for filtering
                var currentEvent;

                //set the number of relevant events back to 0
                playbackData.numberOfRelevantEvents = 0;

                //holds the positions and ids of all of the comment points
                var posOfComments = [];

                //holds the ids of all the selected events
                var relevantSelectedEventIds = {};

                //holds the ids of the source of relevant events that were pasted
                var relevantEventsPasteParentIds = {};

                //if the user wants to see the selected text
                if(filterInfo.showSelectedText) {
                    
                    //get all of the ids of the selected text and code that is related to it
                    relevantSelectedEventIds = getRelevantSelectedInsertEventIds();
                }

                //go through all of the code events in reverse order (reverse is for copy/paste handling)
                for(var i = playbackData.codeEvents.length - 1;i >= 0;i--) {  

                    //grab the current event
                    currentEvent = playbackData.codeEvents[i];

                    //if the current event satisfies the filters OR 
                    //if the event is the source of a paste of a relevant event 
                    if(doesEventSatisfyFilter(currentEvent, filterInfo, relevantSelectedEventIds) || 
                       relevantEventsPasteParentIds[currentEvent.id]) {
                        
                        //mark the event as relevant
                        currentEvent.relevant = true;

                        //increase the number of relevant events
                        playbackData.numberOfRelevantEvents++;

                        //if the user wants to see cut/copy/pastes
                        if(filterInfo.showRelevantCutCopyPastes) {

                            //if this event was pasted from another insert event in this repo
                            if(currentEvent.pastedEventId && currentEvent.pastedEventId !== "other") {

                                //add the id of the event where this relevant event was pasted from
                                relevantEventsPasteParentIds[currentEvent.pastedEventId] = currentEvent.pastedEventId;
                            }
                        }

                        //if there is a comment at this event (there may be multiple comments but we only need to know the index of the event)
                        if(playbackData.comments[currentEvent.id]) {

                            //store the index of the event and the id of the event where the comment will be displayed
                            posOfComments.push({"pos": playbackData.numberOfRelevantEvents - 1, eventId: currentEvent.id});
                        }

                    } else { //the event is not relevant and not a pasted copy of a relevant event

                        //mark the event as NOT relevant
                        currentEvent.relevant = false;
                    }
                }

                //since we went through the events in reverse or the positions are backwards, this loop straightens them out
                for(var i = 0;i < posOfComments.length;i++) {

                    //reverse the order of the positions based on the number of relevant events
                    posOfComments[i].pos = playbackData.numberOfRelevantEvents - 1 - posOfComments[i].pos;
                }

                //add a marker to show where each comment it
                setCommentMarkers(posOfComments, playbackData.numberOfRelevantEvents);
            }

            /*
             * This function takes an event an info about the selected filters and determines if the event is relevant.
             * It checks for a selected text filter and for the other filters (time, dev group, file/dir).
             */
            function doesEventSatisfyFilter(currentEvent, filterInfo, relevantSelectedEventIds) {
                
                //whether the current event is relevant or not
                var retVal;

                //if this event has a permanent relevance state 
                if(currentEvent.permanentRelevance === "never relevant") {
                        
                        retVal = false;

                } else { //there is no permanent state it will be determined by the filters
                    
                    //assume that it is not relevant and check the filters below
                    retVal = false;

                    //if this is a selected text filter
                    if(filterInfo.showSelectedText) {

                        //if the user also wants to involve the other filters (time, dev group, file)
                        if(filterInfo.showSelectedTextWithOtherFilters) {

                            //if the current event is in the list of selected events AND 
                            //the current events satisfies the other filters
                            if(relevantSelectedEventIds[currentEvent.id] &&
                            doesEventSatisfyTimeDevFileDirFilters(currentEvent, filterInfo)) {

                                //this is a relevant event
                                retVal = true;                           
                            }

                        } else { //selected text with no filters
                            
                            //if the current event is in the list of selected events
                            if(relevantSelectedEventIds[currentEvent.id]) {

                                //this is a relevant event
                                retVal = true;
                            }
                        }

                    } else { //not a selected text filter 
                        
                        //if the event satisfies the time, dev, and file filters
                        if(doesEventSatisfyTimeDevFileDirFilters(currentEvent, filterInfo)) {

                            //this is a relevant event
                            retVal = true;
                        }
                    } 
                }
                return retVal;
            }
            
            /*
             * function that determines whether an event satisfies the user selected time, dev group, and file filters
             */
            function doesEventSatisfyTimeDevFileDirFilters(currentEvent, filterInfo) {

                //assume each event is not relevant
                var satisfyTimeFilter = false;
                var satisfyDevGroupFilter = false;
                var satisfyFileFilter = false;

                //if there is at least one time filter
                if(filterInfo.timeFilters.length > 0) {

                    //go through each of the time filters
                    for(var i = 0;i < filterInfo.timeFilters.length;i++) {
                        
                        //get each time filter
                        var timeFilter = filterInfo.timeFilters[i];

                        //if the current timestamp comes after the filter's start timestamp AND before the filter's end timestamp
                        if(currentEvent.timestamp >= timeFilter.startTimestamp && currentEvent.timestamp <= timeFilter.endTimestamp) {

                            //this event is within at least one of the time filter parameters
                            satisfyTimeFilter = true;

                            //break from the loop of timeFilters
                            break;
                        }
                    }
                }

                //if there is a dev group filter
                if(filterInfo.devGroupFilter) {

                    //if the event's dev group is in the array of selected dev group ids
                    if(filterInfo.devGroupFilter.devGroupIds.indexOf(currentEvent.createdByDevGroupId) !== -1) {

                        //event's dev group id is in the selected dev groups filter
                        satisfyDevGroupFilter = true;
                    }
                }

                //if there is a file/dir filter
                if(filterInfo.fileDirFilter) {

                    //some events have a fileId and some have a directoryId
                    if(currentEvent.type === "Insert" || currentEvent.type === "Delete" ||
                       currentEvent.type === "Create File" || currentEvent.type === "Rename File" ||
                       currentEvent.type === "Move File" || currentEvent.type === "Delete File") {
                        
                        //these events have a fileId

                        //if the event's file id is in the array of selected files
                        if(filterInfo.fileDirFilter.fileDirIds.indexOf(currentEvent.fileId) !== -1) {

                            //the user has wants to see it
                            satisfyFileFilter = true;
                        }

                    } else if (currentEvent.type === "Create Directory" || currentEvent.type === "Rename Directory" || 
                               currentEvent.type === "Move Directory" || currentEvent.type === "Delete Directory") {
                                
                        //these events have a directoryId

                        //if the event's directory id is NOT in the array of selected directories
                        if(filterInfo.fileDirFilter.fileDirIds.indexOf(currentEvent.directoryId) !== -1) {

                            //the user wants to see it
                            satisfyFileFilter = true;
                        }
                    }
                }

                //return true only if all of the filters are stisfied for this event
                return (satisfyTimeFilter === true && satisfyDevGroupFilter === true && satisfyFileFilter === true);
            }

            /*
             * Returns the ids of all of the selected code elements on the screen but also goes deeper.
             * For each of the selected code elements, if there are any events that at one time backed
             * up to a selected element but were then deleted, those are marked as relevant too. If any
             * events that backed up to those deleted elements and were deleted too, they are marked as
             * relevant too.
             *
             * In the dom, because of the way we add all of the code elements by previous neighbor id,
             * all events that ever backed up to an element are right in front of it along with the
             * events that ever backed up to those.
             *
             * So, we can go through the first selected element until the last selected element and we
             * should be able to see all the related history (events that were added and deleted but
             * backed up to one of the selected events)
             */
            function getRelevantSelectedInsertEventIds() {

                //get the ids of all of the currently selected code elements
                //there may be more than one range of selected code elements
                var selectedCodeIds = getSelectedRangeCodeIds(true);

                //hold the ids of the relevant elements in the history if the selected code
                var relevantIds = {};

                //go through each of the selected ranges
                for(var i = 0;i < selectedCodeIds.length;i++) {

                    //in the dom, because of the way we add all of the code elements by previous
                    //neighbor id, all events that ever backed up to an element are right in front
                    //of it along with the events that ever backed up to those.
                    //So, we can go through the first selected element until the last selected
                    //element and we should be able to see all the related history (events that
                    //were added and deleted but backed up to one of the selected events)

                    //get the first and last selected elements in each range
                    var firstSelectedEventId = selectedCodeIds[i][0];
                    var lastSelectedEventId = selectedCodeIds[i][1];

                    //get the first selected element in the dom
                    var relevantElement = document.querySelector("#" + firstSelectedEventId);

                    //while we have not reached the end of the selection
                    while(relevantElement) {

                        //get the id from the element
                        var relevantId = relevantElement.getAttribute("id");

                        //add the element's id to a set
                        relevantIds[relevantId] = relevantId;

                        //if we have reached the last selected element we are done recording relevant event ids
                        if(relevantId === lastSelectedEventId) {

                            //stop looking for relevant elements in the history
                            break;
                        }

                        //move to the next element
                        relevantElement = relevantElement.nextElementSibling;
                    }
                }

                //this holds the id of every insert event between the first and last selected 
                //element on the screen (in ranges). This includes code that may have been added and then
                //deleted
                return relevantIds;
            }

            /*
             * Marks all events as relevant (except those specifically marked as permanently
             * never relevant). 
             */
            function clearFiltering() {

                //go through all of the events
                for(var i = 0;i < playbackData.codeEvents.length;i++) {
                    
                    //if the event has a permanent relavance of "never relevant" 
                    if(playbackData.codeEvents[i].permanentRelevance === "never relevant") {

                        //mark the event as not relevant
                        playbackData.codeEvents[i].relevant = false;
                        
                    } else { //all other events marked as relevant by default

                        //mark the event as relevant
                        playbackData.codeEvents[i].relevant = true;
                    }
                }
            }

            //*****************************************************************************
            //                         File system related filtering
            //                         -----------------------------
            // This code has to do with setting up a selectable view of the file system
            // for file/directory filtering. All files and directories are selectable
            // even if they were deleted in the past.
            //*****************************************************************************            
            /*
             * Get the root directory in the file system.
             */
            function getRootDir() {

                //find the root dir of the project directory
                var rootDir = null;

                //go through all of the dirs
                for(var dirId in playbackData.allDirs) {
                    if(playbackData.allDirs.hasOwnProperty(dirId)) {

                        //the root dir has a null parent id
                        if(playbackData.allDirs[dirId].parentId === null) {

                            //store the root and stop looking for it
                            rootDir = playbackData.allDirs[dirId];

                            break;
                        }
                    }
                }

                return rootDir;
            }

            /*
             * Uses the file and directory info in the playback data to build a list of checkboxes
             * so the user can select which ones to include in playback.
             */
            function displayFileSystemForFiltering() {

                //find the root dir of the project directory
                var parentDir = getRootDir();                

                //get the ul that holds this view of the file system
                var parentElement = document.querySelector("#viewOfFileSystemForFiltering");

                //clear it out
                parentElement.innerHTML = "";

                //create the file system view
                createDirectoryInTreeForFiltering(parentDir, parentElement, false);
            }

            /*
             * Adds checkboxes (and file/dir names next to them) in a hierarchical list so the user
             * can filter by file/directory.
             */
            function createDirectoryInTreeForFiltering(dir, parentElement, hasBeenDeleted) {

                //create an id for the new checkbox and list item to hold it
                var newDirCheckBoxId = "fsFilterCheckBoxDirId_" + dir.id;
                var newDirListItemId = "fsFilterListItemDirId_" + dir.id;

                //create a check box and add it to the parent element
                var dirFilterCheckBox = document.createElement("input");
                dirFilterCheckBox.setAttribute("type", "checkbox");
                dirFilterCheckBox.setAttribute("name", "fsFilter");

                //hold the id of the directory to use when it is selected
                dirFilterCheckBox.setAttribute("value", dir.id);
                dirFilterCheckBox.setAttribute("id", newDirCheckBoxId);
                dirFilterCheckBox.setAttribute("checked", "");
                
                //a class that allows us to select directory checkboxes
                dirFilterCheckBox.classList.add("filterCheckBox");
                
                //add an event handler 
                dirFilterCheckBox.addEventListener("click", function(e){

                    //when the checkbox is checked, get a reference to the ul that is holding the dir
                    var dirUL = document.querySelector("#dirUL_" + dir.id);

                    //get all the children checkboxes in this list with the class dirFilterCheckBox
                    var allCheckBoxesBelowAnother = dirUL.querySelectorAll(".filterCheckBox");

                    //if there are any checkboxes underneath the selected one
                    if(allCheckBoxesBelowAnother) {

                        //set all of the checkboxes below the selected one to whether the selected one is checked or not
                        for(var i = 0;i < allCheckBoxesBelowAnother.length;i++) {

                            //all child checkboxes will have the same value
                            allCheckBoxesBelowAnother[i].checked = e.target.checked;
                        }
                    }
                });

                //add a directory icon
                var dirIcon = document.createElement("span");
                dirIcon.innerHTML = "+";
                dirIcon.classList.add("dirIcon");

                //create a label to select
                var dirNameLabel = document.createElement("label");
                dirNameLabel.setAttribute("for", newDirCheckBoxId);
                dirNameLabel.appendChild(dirIcon);
                dirNameLabel.appendChild(document.createTextNode(dir.currentName));

                //add the radio button and label to a list item
                var dirLI = document.createElement("li");
                dirLI.setAttribute("id", newDirListItemId);
                dirLI.appendChild(dirFilterCheckBox);
                dirLI.appendChild(dirNameLabel);

                //if the dir has been deleted we will highlight it wait a class
                if(dir.isDeleted) {
                    dirLI.classList.add("deletedFileOrDirectory");
                }

                //add the list item to the parent
                parentElement.appendChild(dirLI);

                //now handle subdirectories by adding them all underneath the parent element
                var subList = null;

                //go through all of the dir ids in the object of all directories
                for (var dirId in playbackData.allDirs) {
                    if (playbackData.allDirs.hasOwnProperty(dirId)) {

                        //if another directory has this one as its parent
                        if(playbackData.allDirs[dirId].parentId === dir.id) {

                            //if a new sub list has not already been created
                            if(subList === null) {

                                //add a new list and append it to the parent list
                                subList = document.createElement("ul");
                                subList.setAttribute("id", "dirUL_" + dir.id);
                                subList.classList.add("fileOrDirListForFiltering");
                                parentElement.appendChild(subList);
                            }

                            //recurse and add the subdirectory
                            createDirectoryInTreeForFiltering(playbackData.allDirs[dirId], subList, playbackData.allDirs[dirId].isDeleted);
                        }
                    }
                }

                //add any files in this directory to the tree
                //go through all of the file ids in the object of all files
                for (var fileId in playbackData.allFiles) {
                    if (playbackData.allFiles.hasOwnProperty(fileId)) {

                        //if a file's parent is this directory
                        if(playbackData.allFiles[fileId].parentId === dir.id) {

                            //if a new sub list has not already been created
                            if(subList === null) {

                                //add a new list and append it to the parent list
                                subList = document.createElement("ul");
                                subList.setAttribute("id", "dirUL_" + dir.id);
                                subList.classList.add("fileOrDirListForFiltering");
                                parentElement.appendChild(subList);
                            }

                            //add the file in the list
                            addUnderDirectoryForFiltering(playbackData.allFiles[fileId], subList, playbackData.allFiles[fileId].isDeleted)
                        }
                    }
                }
            }

            /*
             * Add file info to the structure that holds the entire file system for filtering.
             */
            function addUnderDirectoryForFiltering(file, parentElement, hasBeenDeleted) {

                //create an id for the file checkbox
                var newFileCheckBoxId = "fsFilterCheckBoxFileId_" + file.id;

                //create a checkbox and add it to the parent element
                var fileCheckBox = document.createElement("input");
                fileCheckBox.setAttribute("type", "checkbox");
                fileCheckBox.setAttribute("name", "fsFilter");

                //store the value of the file id so we can get it when it is selected
                fileCheckBox.setAttribute("value", file.id);
                fileCheckBox.setAttribute("id", newFileCheckBoxId);
                fileCheckBox.setAttribute("checked", "");
                
                //add a class so we can determine which file was selected
                fileCheckBox.classList.add("filterCheckBox");

                //add a file icon
                var fileIcon = document.createElement("span");
                fileIcon.innerHTML = "-";

                //create a label to select
                var fileNameLabel = document.createElement("label");
                fileNameLabel.setAttribute("for", newFileCheckBoxId);
                fileNameLabel.appendChild(fileIcon);
                fileNameLabel.appendChild(document.createTextNode(file.currentName));

                //add the checkbox and label to a list item
                var fileLI = document.createElement("li");
                fileLI.appendChild(fileCheckBox);
                fileLI.appendChild(fileNameLabel);

                //if the file has been deleted we will highlight it wait a class
                if(file.isDeleted) {
                    fileLI.classList.add("deletedFileOrDirectory");
                }

                //add the file to the correct list
                parentElement.appendChild(fileLI);
            }

            /*
            <ul id="playbackViewOfFileSystem" class="playbackViewFileOrDirList">
                <li>
                    <span class="playbackDirNameLabel">root</span>
                </li>
                <ul id="playbackViewDir-0" class="playbackViewFileOrDirList">
                    <li id="playbackViewFile-1">
                        <span>untitled.txt</span>
                    </li>
                </ul>
            </ul>
            */

            //*****************************************************************************
            //                         Selection related code
            //                         ----------------------
            // This code has to do with selecting lines and characters. The code allows
            // one to get the selected code characters from the playback window. There is a
            // function to get the selected code's text and the selected code's id's
            //*****************************************************************************
            function markSelectedCode() {

                //get the document's selected elements
                var selection = document.getSelection();

                //if the ctrl or cmd key is NOT pressed
                if(ctrlCmdPressed === false) {

                    //clear the previously selected code
                    clearSelectedCode();

                } //else- the ctrl or cmd key is pressed and the user wants muliple selections

                //if there are some selected elements in the dom
                if(selection.rangeCount > 0) {
                    
                    //go through each selection (there may be more than one)
                    for(var i = 0;i < selection.rangeCount;i++) {

                        //get a range
                        var range = selection.getRangeAt(i);
                        
                        //if there was actually one or more code characters selected
                        if(range.collapsed === false) {
                            
                            //get all the elements that have 'beginSelectedCode-' in the class name (one for each selection), 
                            //count them, and add 1 for the next id
                            var selectedCodeNumber = document.querySelectorAll("[class*=beginSelectedCode-]").length + 1;
                            
                            //a selected code span
                            var nextSelectedElement = range.startContainer.parentNode;

                            //if the element has the codeChar class then it is selectable
                            if(nextSelectedElement && nextSelectedElement.classList.contains("codeChar")) {

                                //mark it as the first selected text in a group
                                nextSelectedElement.classList.add("beginSelectedCode-" + selectedCodeNumber);
                                
                                //while there are more selected code spans
                                while(nextSelectedElement) {
                                    
                                    //if this is a currently visible code span
                                    if(nextSelectedElement.classList.contains("codeChar") && 
                                       nextSelectedElement.classList.contains("codeNotVisible") === false) {

                                        //mark it as selected text
                                        nextSelectedElement.classList.add("selectedCode");
                                    }

                                    //if this is the last selected code span
                                    if(nextSelectedElement === range.endContainer.parentNode) {

                                        //stop moving through the siblings
                                        break;
                                    }

                                    //if there are no more siblings beyond this one
                                    if(nextSelectedElement.nextSibling === null) {

                                        //get out of the loop with nextSelectedElement still refering to a valid element 
                                        break;
                                    }

                                    //move to the next neighbor
                                    nextSelectedElement = nextSelectedElement.nextSibling;
                                }

                                //mark it as the last selected text in a group
                                nextSelectedElement.classList.add("endSelectedCode-" + selectedCodeNumber);
                            }
                        }
                    }
                }
            }
            
            function clearSelectedCode() {

                //get all of the selected code
                var allSelectedCode = document.querySelectorAll(".selectedCode");

                //go through all the selected code
                for(var i = 0;i < allSelectedCode.length;i++) {

                    //remove the class that makes this selected code
                    allSelectedCode[i].classList.remove("selectedCode");
                }

                //get all of the beginning elements of selected code
                var allBeginningSelectedCode = document.querySelectorAll("[class*=beginSelectedCode-]");

                //go through all the beginning selected code elements
                for(var i = 0;i < allBeginningSelectedCode.length;i++) {

                    //go through all of the classes for this element
                    for(var j = 0;j < allBeginningSelectedCode[i].classList.length;j++) {
                        
                        //when we find one that starts with beginSelectedCode-
                        if(allBeginningSelectedCode[i].classList.item(j).startsWith("beginSelectedCode-")) {
                            
                            //remove this class regardles of which number comes after beginSelectedCode-
                            allBeginningSelectedCode[i].classList.remove(allBeginningSelectedCode[i].classList.item(j));
                        }
                    }
                }

                //get all of the ending elements of selected code
                var allEndingSelectedCode = document.querySelectorAll("[class*=endSelectedCode-]");

                //go through all the ending selected code elements
                for(var i = 0;i < allEndingSelectedCode.length;i++) {

                    //go through all of the classes for this element
                    for(var j = 0;j < allEndingSelectedCode[i].classList.length;j++) {
                        
                        //when we find one that starts with endSelectedCode-
                        if(allEndingSelectedCode[i].classList.item(j).startsWith("endSelectedCode-")) {
                            
                            //remove this class regardles of which number comes after endSelectedCode-
                            allEndingSelectedCode[i].classList.remove(allEndingSelectedCode[i].classList.item(j));
                        }
                    }
                }
            }

            /*
             * This function gets all of the selected code character elements and returns
             * a string with all of the unadorned text.
             */
            function getSelectedCodeText() {

                //just the text of the selected elements
                var codeText = "";

                //holds all of the selected code characters
                var allSelectedCodeCharacters = document.querySelectorAll(".selectedCode");

                //go through all the selected elements
                for(var i = 0;i < allSelectedCodeCharacters.length;i++) {

                    //if the selected item is a newline character
                    if(allSelectedCodeCharacters[i].classList.contains("newLine")) {

                        //add a newline
                        codeText += "\n";

                    } else { //non-newline code

                        //add the text to the return string
                        codeText += allSelectedCodeCharacters[i].textContent;
                    }
                }

                return codeText;
            }

            /*
             * This function gets all of the selected code character elements and returns
             * their ids.
             */
            function getSelectedCodeIds() {

                //all the ids of the selected elements
                var codeIds = [];

                //holds all of the selected code characters
                var allSelectedCodeCharacters = document.querySelectorAll(".selectedCode");

                //go through the selected elements
                for(var i = 0;i < allSelectedCodeCharacters.length;i++) {

                    //add the ids of the elements to the return array
                    codeIds.push(allSelectedCodeCharacters[i].getAttribute("id"));
                }

                return codeIds;
            }

            /*
             * This function gets the ids of the first and last element in all of the selected ranges.
             */
            function getSelectedRangeCodeIds() {

                //all the ids of the selected elements
                var codeIds = [];
                var selectedRangeNumber = 1;
                
                //get the beginning and end of each range
                var selectedCodeRangeBegin = document.querySelector(".beginSelectedCode-" + selectedRangeNumber);
                var selectedCodeRangeEnd = document.querySelector(".endSelectedCode-" + selectedRangeNumber);

                while(selectedCodeRangeBegin) {
                    
                    //add the starting and ending id of each range
                    codeIds.push([selectedCodeRangeBegin.getAttribute("id"), selectedCodeRangeEnd.getAttribute("id")]);
                    
                    //add one to look for the next range
                    selectedRangeNumber++;

                    //see if there is another range
                    selectedCodeRangeBegin = document.querySelector(".beginSelectedCode-" + selectedRangeNumber);
                    selectedCodeRangeEnd = document.querySelector(".endSelectedCode-" + selectedRangeNumber);
                }

                return codeIds;
            }

            //*****************************************************************************
            //                         Date/time related code
            //                         ---------------------
            // This code has to do with formatting dates and times
            //*****************************************************************************
            /*
             * Get a date string DAYOFWEEK, MM/DD/YY HH:MM:SS
             */
            function formatDateShortWithDayOfWeek(dateTime) {

                //date formatting options
                var options = {
                    weekday: 'short',
                    year: '2-digit',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                };

                //use the options
                return dateTime.toLocaleString('en-US', options);
            }

            /*
             * Get a date string MM/DD/YY HH:MM:SS
             */
            function formatDateShort(dateTime) {

                //date formatting options
                var options = {
                    year: '2-digit',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                };

                //use the options
                return dateTime.toLocaleString('en-US', options);
            }

            //*****************************************************************************
            //                         Dev/dev group related code
            //                         ---------------------
            // This code has to do with working with devs and dev groups
            //*****************************************************************************
            /*
             * Get all of the dev's info based on a dev group id
             */
            function getDevelopersInDevGroup(devGroupId) {

                //holds all of the developers in the dev group with the passed in id
                var allDevsInGroup = [];

                //get the dev group
                var devGroup = playbackData.allDeveloperGroups[devGroupId];

                //if the dev group was found
                if(devGroup) {

                    //go through all of the member ids of the matched dev group
                    for(var i = 0;i < devGroup.memberIds.length;i++) {

                        //use the hash of all devs (keyed by their id) to retrieve a dev based on the group's member ids
                        var dev = playbackData.allDevelopers[devGroup.memberIds[i]];

                        //add the found member
                        allDevsInGroup.push(dev);
                    }
                }//else- no dev group with that id was found, return an empty array

                return allDevsInGroup;
            }

            /*
             * This function returns an array of all developer groups in the system. The format for the
             * elements in the array looks like this:
             * [
             *   {devGroupId: 123, memberIds: [ {id: 1, firstName: "Mark", lastName: "Mahoney", email: "mmahoney@carthage.edu"} ]}
             *   {devGroupId: 234, memberIds: [ {id: 2, firstName: "Laura", lastName: "Mahoney", email: "laura#mail.com"}, {id: 1, firstName: "Mark", lastName: "Mahoney", email: "mmahoney@carthage.edu"} ]},
             * ]
             */
            function getAllDevelopersInEachGroup() {

                //holds all the dev groups and all of their members
                var allDevGroups = [];

                //go through all of the dev groups in the system
                for(var devGroupId in playbackData.allDeveloperGroups) {
                    if(playbackData.allDeveloperGroups.hasOwnProperty(devGroupId)) {

                        var existingDevGroup = playbackData.allDeveloperGroups[devGroupId];

                        //create an object to hold the dev group info
                        var devGroup = {
                            devGroupId: existingDevGroup.id,
                            members: []
                        };

                        //go through all of the member ids of the matched dev group
                        for(var i = 0;i < existingDevGroup.memberIds.length;i++) {

                            //use the hash of all devs (keyed by their id) to retrieve a dev based on the group's member ids
                            var dev = playbackData.allDevelopers[existingDevGroup.memberIds[i]];

                            //add the dev to the groups list of members
                            devGroup.members.push(dev);
                        }

                        //sort the members by their names
                        sortArrayOfDevsByName(devGroup.members);

                        //add the group
                        allDevGroups.push(devGroup)
                    }
                }

                //sort the dev groups by number of members
                allDevGroups.sort(function(devGroup1, devGroup2) {
                    return devGroup1.members.length - devGroup2.members.length;
                });

                return allDevGroups;
            }

            /*
             * Sort a passed in array of developers by their names. Sort by last name, if two
             * devs have the same last name then sort by their first names.
             */
            function sortArrayOfDevsByName(devs) {

                //sort the dev array by name
                devs.sort(function (dev1, dev2) {

                    //if the developers' last names are the same
                    if(dev1.lastName.toLowerCase() === dev2.lastName.toLowerCase()) {

                        //sort by their first names
                        if(dev1.firstName.toLowerCase() < dev2.firstName.toLowerCase()) {

                            return -1;

                        } else if (dev1.firstName.toLowerCase() > dev2.firstName.toLowerCase()) {

                            return 1;

                        } else {

                            return 0;
                        }

                    } else { //last names are different

                        //sort by last name
                        if(dev1.lastName.toLowerCase() < dev2.lastName.toLowerCase()) {

                            return -1;

                        } else if(dev1.lastName.toLowerCase() > dev2.lastName.toLowerCase()) {

                            return 1;

                        } else {

                            return 0;
                        }
                    }
                });
            }

            /*
             * Displays all of the dev groups and their members to select for filtering
             */
            function displayAllDevGroupMembersForFiltering() {

                //get the element that holds all of the developer groups
                var devGroupFilter = document.querySelector("#devGroupFilter");

                //clear the contents of the div
                devGroupFilter.innerHTML = "";

                //get all the dev groups and their members
                var allGroups = getAllDevelopersInEachGroup();

                //go through each developer group
                for(var i = 0;i < allGroups.length;i++) {

                    //create a checkbox
                    var devCheckbox = document.createElement("input");
                    devCheckbox.setAttribute("type", "checkbox");
                    devCheckbox.setAttribute("name", "devGroupSelect");
                    devCheckbox.setAttribute("value", allGroups[i].devGroupId);
                    devCheckbox.setAttribute("checked", "");
                    devCheckbox.classList.add("devGroupSelectCheckbox");

                    //create a label and add the checkbox and a dev name
                    var devLabel = document.createElement("label");
                    devLabel.appendChild(devCheckbox);

                    //store the names of all the devs in the group
                    var devName = document.createElement("span");

                    //go through all of the members in the group
                    for(var j = 0;j < allGroups[i].members.length;j++) {

                        //add a dev group member name
                        devName.innerHTML += " " + allGroups[i].members[j].firstName + " " + allGroups[i].members[j].lastName + " (" + allGroups[i].members[j].email + ")";

                        //if there are more add a comma
                        if(j < allGroups[i].members.length - 1) {

                            devName.innerHTML += ", ";
                        }
                        //else- last one nothing needed
                    }

                    //add the names to the label
                    devLabel.appendChild(devName);

                    //add the label to the div of all developers and a newline
                    devGroupFilter.appendChild(devLabel);
                    devGroupFilter.appendChild(document.createElement("br"));
                }
            }

            /*
             * Checks to see if the latest event was created by a dev group that is different than
             * the last event's dev group and if so updates the dev info images to display who is
             * responsible for this character of code.
             */
            function showDevsInDevGroup(codeEvent) {

                //if the latest code character was created by a dev group that is different than
                //the current dev group (current dev group is the last one responsible for an event)
                if(playbackData.latestPlaybackEventDevGroupId !== codeEvent.createdByDevGroupId) {

                    //get the info about all of the dev's in the new dev group who made the latest change
                    var devs = getDevelopersInDevGroup(codeEvent.createdByDevGroupId);

                    //get the element to fill with dev info
                    var eventDevInfo = document.querySelector("#eventDevInfo");

                    //clear out the old dev info
                    eventDevInfo.innerHTML = "";

                    //go through each of the developers
                    for(var j = 0;j < devs.length;j++) {

                        //add some dev info to the page
                        eventDevInfo.appendChild(getDevElement(devs[j], 50));
                    }

                    //store the new dev group id as the latest one
                    playbackData.latestPlaybackEventDevGroupId = codeEvent.createdByDevGroupId;
                }
                //else- this code character was made by the same dev group that was responsible for the last one
            }

            /*
             * Creates an element with devloper info in it. Creates an image with a gravatar and
             * contact info.
             */
            function getDevElement(dev, sizeOfImage) {

                //add the name and the link to a span
                var devSpan = document.createElement("span");

                //hash the developer's email
                var emailHash = md5(dev.email.trim().toLowerCase());

                //create the img and add attributes for a bootstrap popover
                var devAvatar = document.createElement("img");

                //ask for sizeOfImageXsizeOfImage pixel images and identicons if the dev doesn't have a gravatar
                devAvatar.setAttribute("src", "http://www.gravatar.com/avatar/" + emailHash + "?s=" + sizeOfImage + "&d=identicon");
                devAvatar.setAttribute("data-toggle", "popover");
                devAvatar.setAttribute("data-placement", "top");
                devAvatar.setAttribute("data-html", "true");
                devAvatar.setAttribute("data-trigger", "hover click focus");
                devAvatar.setAttribute("data-title", dev.firstName + " " + dev.lastName + "'s Contact Info");
                devAvatar.setAttribute("data-content", "<strong>" + dev.firstName + " " + dev.lastName + "</strong><br><a href='mailto:" + dev.email + "'>" + dev.email + "</a>");
                devAvatar.classList.add("devImage");
                devAvatar.classList.add("img-thumbnail");

                //add the img
                devSpan.appendChild(devAvatar);

                //make the popups with additional info work correctly
                $(devAvatar).popover();

                return devSpan;
            }

            //*****************************************************************************
            //               Editing a playback in the browser related code                
            //               ----------------------------------------------                
            //*****************************************************************************
            //This function is used to identify a single code character where an insert will
            //take place. There is a UI element where the user can choose to insert before or 
            //after the selected character of code. A class will be added that adds a cursor-like
            //element to the selected code on either the left or right side. This function is
            //added as an event handler for all code on the screen at a pause point.
            function codeClickedForInsert(clickEvent) {

                //see if there is any previously clicked element (clickedForInsertBefore or clickedForInsertAfter)
                var previouslyClickedForInsert = document.querySelector("[class*=clickedForInsert]");

                //if there is a previously clicked element, clear it out
                if(previouslyClickedForInsert) {

                    //remove the the class that makes it clicked (it will be one of these two)
                    previouslyClickedForInsert.classList.remove("clickedForInsertBefore");
                    previouslyClickedForInsert.classList.remove("clickedForInsertAfter");
                }

                //this is the current clicked element
                var clickedCode = clickEvent.target;

                //this is a radio button that says whether the new text should come before 
                //or after the selected code element
                var newHistoryBeforeElement = document.querySelector("#newHistoryBeforeElement");

                //if the radio button is checked
                if(newHistoryBeforeElement.checked) {

                    //the new code will come before 
                    clickedCode.classList.add("clickedForInsertBefore");                

                } else { //the radio button is not checked so the other one must be checked
                        
                    //the new code will come after
                    clickedCode.classList.add("clickedForInsertAfter");                
                }
            }

            //This function adds an event handler for the code on screen at the pause point.
            //The event handler, codeClickedForInsert, is used to identify where to insert 
            //code at a pause point. 
            function makeIndividualCodeCharsSelectable() {

                //clear any past call to this function 
                makeIndividualCodeCharsUnselectable();

                //get all of the code elements that are visible on the screen in all the tabs
                var allVisibleCodeElements = document.querySelectorAll(".codeChar:not(.codeNotVisible)");

                //add an event handler to each code span to make them clickable
                for(var i = 0;i < allVisibleCodeElements.length;i++) {

                    //add a class so we can identify these later
                    allVisibleCodeElements[i].classList.add("temporarilyClickable");
                    
                    //make them temporarily clickable with a handler that will identify an insert position
                    allVisibleCodeElements[i].addEventListener("click", codeClickedForInsert);
                }
            }

            //This function removes the handler for each clickable code element and removes the
            //special class to identify selected elements.
            function makeIndividualCodeCharsUnselectable() {

                //get all of the clickable code spans                                    
                var allClickableCodeElements = document.querySelectorAll(".temporarilyClickable");

                //go through the clickable elements
                for(var i = 0;i < allClickableCodeElements.length;i++) {
                    
                    //remove the class that identifies them
                    allClickableCodeElements[i].classList.remove("temporarilyClickable");
                    
                    //remove the event handler
                    allClickableCodeElements[i].removeEventListener("click", codeClickedForInsert);
                }

                //remove any previously clicked UI (if there are any)
                var previouslyClickedForInsert = document.querySelector("[class*=clickedForInsert]");

                if(previouslyClickedForInsert) {
                    
                    //it will be one of these two
                    previouslyClickedForInsert.classList.remove("clickedForInsertBefore");
                    previouslyClickedForInsert.classList.remove("clickedForInsertAfter");
                }
            }

            //This function allows a developer to rewrite the history of a playback to insert
            //some new code at a pause point. The pause point represents the point in time during
            //the development process that the user wants to insert the new code.
            //This function is called in response to a UI interaction to begin the insertion 
            //process and rerun the playback to the pause point. The user will pause a playback, 
            //select exactly where the code should go (either before or after a selected code 
            //character), and write the text to be inserted. The playback events will be rewritten 
            //to insert the new text at the pause point. A replay of the playback will show the new 
            //code inserted at the pause point. The new events will have an accurate timestamp of 
            //when they were created (most likely very different from the events around it) and the 
            //event ids will be adjusted so that they are all sequential (as if the code was written 
            //in the order it is now played back).   
            function insertHistory() {

                //get the text to insert into the playback
                var newCode = document.querySelector("#insertNewHistoryText").value;

                //the span that comes before where the new code will be inserted. It will be used
                //as the previous neighbor for the new code block 
                var insertAfterSpan;

                //get the span where the insert will occur
                var previouslyClickedForInsert = document.querySelector("[class*=clickedForInsert]");

                //if there is some code to add and a previously clicked element
                if(newCode.length > 0 && previouslyClickedForInsert) {

                    //see if the insert comes before or after the clicked span
                    if(previouslyClickedForInsert.classList.contains("clickedForInsertBefore")) {
                        
                        //this is a visible span where new code will back up
                        insertAfterSpan = getPreviousVisibleSpan(previouslyClickedForInsert);

                    } else { //the class is 'clickedForInsertAfter'

                        //use the selected element as the previous neighbor
                        insertAfterSpan = previouslyClickedForInsert;
                    }

                    //clear the event handlers 
                    makeIndividualCodeCharsUnselectable();

                    //insert the new code after the selected span
                    var restartPlaybackAtIndex = editPlaybackHistoryInsert(newCode, insertAfterSpan);

                    //renumber all of the event ids so that the new history looks like it was written in sequence
                    renumberAllCodeEventIds(playbackData.branchId, new Set());

                    //redisplay the playback from the beginning
                    getPlaybackWindowsReadyForAnimation(true);

                    //move to where the playback will be with the new code
                    step("forward", restartPlaybackAtIndex + 1, false);                
                }
            }

            //This function will take in a code span and find the first previous code span that is
            //visible on the screen (or the default first span if there are no visible code spans).
            function getPreviousVisibleSpan(startingSpan) {
                
                //used to move through the previous elements to find a visible code character 
                var currentSpan = startingSpan.previousSibling;

                //move through the invisible code spans in reverse until we find one that is visible 
                //(or we get to the firstSpan which is not a codeChar)
                while(currentSpan.classList.contains("codeChar") === true && 
                      currentSpan.classList.contains("codeNotVisible") === true) {
                    
                    //get the previous element
                    currentSpan = currentSpan.previousSibling;
                }

                //this is a visible span where new code will back up
                return currentSpan;
            }

            //This function will alter the playback's code events to insert some new code. 
            //It creates new events and puts them in the playbackData's codeEvents array
            //after the codeEventIndex (the pause point of the playback). It then goes and looks 
            //for any insert events after the pause point whose previous neighbor is the 'insert
            //after' code span and updates their previous neighbor to be the last new event added. 
            //This makes it appear as if the new code was inserted when the other code at the pause 
            //point was inserted. The new events and events after the pause point have their line 
            //number and column cleared out since adding new text will change them (a playback can handle
            //this by calculating the correct values on the fly). The function returns a value 
            //for what the codeEventIndex should be with the new text. This can be used to put 
            //the playback in the same state after the insert. 
            function editPlaybackHistoryInsert(newCode, insertAfterSpan) {

                //this will hold all of the new events that are being inserted
                var newCodeEvents = [];

                //get the id of the event for a previous neighbor id
                var idOfInsertAfterSpan = insertAfterSpan.getAttribute("id");

                //set the initial value to the insert span's id (this will be updated when inserting
                //new insert events below)
                var previousNeighborIdOfInsertAfterSpan;

                //if the insert span is the first in the file
                if(idOfInsertAfterSpan.startsWith("firstSpan-")) {

                    //use the "none" id for the previous neighbor id
                    previousNeighborIdOfInsertAfterSpan = "none";

                } else { //not the first span in the file

                    //use the id of the insert span
                    previousNeighborIdOfInsertAfterSpan = idOfInsertAfterSpan;
                }

                //used for temporary ids of the new code
                var autoGeneratedEventId = 0;

                //get the file id where this new code will go
                var fileId = getFileIdFromCodeSpan(insertAfterSpan);

                //all events will share the same timestamp
                var timestamp = Date.now();

                //create an event for each new character entered
                for(var i = 0;i < newCode.length;i++) {

                    //create a code event
                    var newInsertTextEvent = {
                        id: "ev_" + playbackData.branchId + "_TEMP-EDIT-PLAYBACK_" + autoGeneratedEventId,
                        timestamp: timestamp,
                        type: "Insert",
                        character: newCode[i],
                        previousNeighborId: previousNeighborIdOfInsertAfterSpan,
                        createdByDevGroupId: playbackData.currentDevGroupId,
                        lineNumber: -1,
                        column: -1,
                        fileId: fileId,
                        pastedEventId: null
                    };

                    //increment for the next new event
                    autoGeneratedEventId++;

                    //add the new event to an array for use later
                    newCodeEvents.push(newInsertTextEvent);

                    //store the current event's id as the next previous neighbor
                    previousNeighborIdOfInsertAfterSpan = newInsertTextEvent.id;
                }

                //go through the events after the pause point
                for(var i = playbackData.codeEventsIndex + 1;i < playbackData.codeEvents.length;i++) {
                    
                    //get the event
                    var currentEvent = playbackData.codeEvents[i];

                    //adding new code may alter line numbers so set all to -1 after the pause point
                    currentEvent.lineNumber = -1;
                    currentEvent.column = -1;

                    //if it is an insert that has a previous neighbor of the insert span
                    if(currentEvent.type === "Insert" && 
                       currentEvent.previousNeighborId === idOfInsertAfterSpan) {

                        //adjust its previous neighbor to the the last new event created
                        currentEvent.previousNeighborId = previousNeighborIdOfInsertAfterSpan;
                    }
                }

                //add the new events back in playbackData's array of code events
                //go backwards so we can use the same insert point playbackData.codeEventsIndex
                for(var i = newCodeEvents.length - 1;i >= 0;i--) {

                    //add the new events into the playback data at the pause point
                    playbackData.codeEvents.splice(playbackData.codeEventsIndex + 1, 0, newCodeEvents[i])
                }

                //before resetting the playback, calculate where to replay to
                //the pause point plus the length of the new code
                var restartPlaybackAtIndex = playbackData.codeEventsIndex + newCodeEvents.length;

                //return the event index to playback to 
                return restartPlaybackAtIndex;
            }

            //This function coordinates the removal of some code from a playback. It looks for some selected text
            //and gathers all of the history related to that selected text. It removes those events from the
            //playbackData's codeEvents and then redisplays the playback.
            function deleteHistory() {

                //holds the ids of all of the files with some selected text to delete                                
                var allFileIdsWithSelectedText = new Set();

                //holds the element ids in between the beginning and ending of each of the selections (inclusive)
                var allElementIdsToDelete = new Set();

                //get all of the file ids and selected code to delete (this includes code that may not be
                //present on the screen yet because of how we build the dom)
                getSelectedTextToDelete(allFileIdsWithSelectedText, allElementIdsToDelete);

                //perform the delete of the selected characters
                var restartPlaybackAtIndex = editPlaybackHistoryDelete(allFileIdsWithSelectedText, allElementIdsToDelete);

                //renumber all of the event ids so that the new history looks like it was written in sequence
                renumberAllCodeEventIds(playbackData.branchId, allElementIdsToDelete);

                //redisplay the playback from the beginning
                getPlaybackWindowsReadyForAnimation(true);

                //move forward for each event not deleted before the old pause point
                step("forward", restartPlaybackAtIndex, false);
            }

            //This function will get all of the code elements in some selected text. This includes all inserts that ever
            //touch any of the characters selected on the screen (when creating the dom we put every code element right in
            //front of its previous neighbor- this is what we mean by a 'touch') 
            function getSelectedTextToDelete(allFileIdsWithSelectedText, allElementIdsToDelete) {

                //get the first and last elements in each selected range (there will be a 
                //beginSelectedCode-X and endSelectedCode-X for each selected range where X is a number)
                var allBeginSelectedCodeElements = document.querySelectorAll("[class*=beginSelectedCode-]");
                var allEndSelectedCodeElements = document.querySelectorAll("[class*=endSelectedCode-]");

                //go through the pairs of begins and ends
                for(var i = 0;i < allBeginSelectedCodeElements.length;i++) {
                    
                    //get the first and last element of the same selected range
                    var beginElement = allBeginSelectedCodeElements[i];
                    var endElement = allEndSelectedCodeElements[i];

                    //if there is both a beginning and ending element
                    if(beginElement && endElement) {

                        //get the file id where the selection is in
                        allFileIdsWithSelectedText.add(getFileIdFromCodeSpan(beginElement));
                        
                        //start at the beginning of a range
                        var currentElement = beginElement;

                        //until we are beyond the end of the range
                        while(currentElement !== endElement.nextSibling) {

                            //grab the element's id and add it to the set
                            allElementIdsToDelete.add(currentElement.getAttribute("id"));

                            //move on to the neighbor element
                            currentElement = currentElement.nextSibling;
                        }
                    }
                }
            }

            //This function gets a file id from a code span. It is used to find the file id of a 
            //selected bit of code.
            function getFileIdFromCodeSpan(element) {

                //get the playback window id from the code span's parent
                var playbackWindowId = element.parentNode.getAttribute("id");

                //strip off the beginning text that is added to make it a playback window id
                var fileId = playbackWindowId.substring("playbackWindow-".length);

                //return just the file id
                return fileId;
            }

            //This function removes events from the playbackData's code events array. Since some 
            //events that are not being removed may have previous neighbors that refer to the 
            //events being removed we need to update them. Any non-deleted insert event that 
            //has a previous neighbor that is being deleted will be adjusted to hold the last 
            //visible insert event that was closest to the deleted one that was on the screen 
            //when the insert was added. 
            function editPlaybackHistoryDelete(allFileIdsWithSelectedText, allElementIdsToDelete) {

                //if there is any selected text
                if(allElementIdsToDelete.size > 0) {

                    //this will hold the state of the files that we are deleting some history from while handling events
                    //this is needed to adjust previous neighbors when deleting sections of history from the playback
                    var allInsertEventsByFile = {};

                    //a new version of playbackData's codeEvents that does not contain any of the 
                    //selected text insert events being removed or any deletes of those insert events
                    var newCodeEvents = [];

                    //this is the index of the event to move back to after a delete
                    var restartPlaybackAtIndex = 0;

                    //go through all of the original code events in the playbackData
                    for(var i = 0;i < playbackData.codeEvents.length;i++)
                    {
                        //get the current event
                        var currentEvent = playbackData.codeEvents[i];                                            

                        //if the current event comes from a file with some selected text
                        if(allFileIdsWithSelectedText.has(currentEvent.fileId)) {

                            //build up the state of the files with some selected text to be deleted
                            //this is used to adjust some previous neighbors below
                            insertEventInLinkedListMap(currentEvent, allInsertEventsByFile, "not used", true);

                            //if the current event is an insert
                            if(currentEvent.type === "Insert") {

                                //since we are rewriting history in an edited file it is difficult to track 
                                //line/column numbers for each event. Set them all to -1 and they will be 
                                //calculated on the fly during playback
                                currentEvent.lineNumber = -1;
                                currentEvent.column = -1;
                                
                                //if the current insert event is NOT one of the events being deleted
                                if(allElementIdsToDelete.has(currentEvent.id) === false) {

                                    //if any event outside of the selected range backs up to one of the deleted events                                                        
                                    //(because of the way the dom is built up this should only happen to insert events 
                                    //that back up to the last element in a selected range. All other inserts that back 
                                    //up to a selected event will be caught in the allElementIdsToDelete set)
                                    if(allElementIdsToDelete.has(currentEvent.previousNeighborId)) {

                                        //get the linked list of the current state of this file
                                        var editorStateLinkedList = allInsertEventsByFile[currentEvent.fileId]
                                        
                                        //get the node that holds the previous neighbor event
                                        var deletedPreviousNeighborNode = editorStateLinkedList.nodeMap[currentEvent.previousNeighborId];
                                        //get the id of the previous neighbor or 'none' if it is the first character in a file
                                        var deletedPreviousNeighborId = deletedPreviousNeighborNode.event ? deletedPreviousNeighborNode.event.id : "none";
                                        
                                        //while the node is in the set that is being deleted
                                        while(allElementIdsToDelete.has(deletedPreviousNeighborId)) {

                                            //move to the previous insert event in the file at the current state
                                            //we are moving backwards from the previous neighbor looking for the first insert event 
                                            //that is not in the set of deleted inserts. This is the best choice for a new previous neighbor
                                            deletedPreviousNeighborNode = deletedPreviousNeighborNode.previous;
                                            //update the previous neighbor id
                                            deletedPreviousNeighborId = deletedPreviousNeighborNode.event ? deletedPreviousNeighborNode.event.id : "none";
                                        }
                                        
                                        //make the current event's previous neighbor one that is on the screen
                                        //this is guaranteed not to be in the deleted set and be on the screen
                                        currentEvent.previousNeighborId = deletedPreviousNeighborId;
                                    }

                                    //if this is before the current event index
                                    if(i <= playbackData.codeEventsIndex) {

                                        //add so when the playback is refreshed it will be at the same point
                                        restartPlaybackAtIndex++;
                                    }

                                    //add the event to the new list of events
                                    newCodeEvents.push(currentEvent);

                                } else { //else- it is one of the deleted events 
                                
                                    //don't store the event

                                    //delete any comments associated with this event
                                    deleteCommentsForADeletedEvent(currentEvent);
                                }  

                            } else if (currentEvent.type === "Delete") { //this is a delete

                                //since we are rewriting history it is difficult to track line/column numbers
                                //for each event. Set them all to -1 and they will be calculated on the fly
                                //during playback
                                currentEvent.lineNumber = -1;
                                currentEvent.column = -1;
                                
                                //if the current delete event is NOT deleting one of the events that is being deleted
                                if(allElementIdsToDelete.has(currentEvent.previousNeighborId) === false) {

                                    //if this is before the current event index
                                    if(i <= playbackData.codeEventsIndex) {

                                        //add so when the playback is refreshed it will be at the same point
                                        restartPlaybackAtIndex++;
                                    }
                                    
                                    //add it to the new list of events
                                    newCodeEvents.push(currentEvent);

                                } else { //else- this is a delete event for something that is being removed
                                
                                    //don't store the event

                                    //delete any comments associated with this event
                                    deleteCommentsForADeletedEvent(currentEvent);
                                }
                                
                            } else { //not an insert or delete, store all of these

                                    //if this is before the current event index
                                    if(i <= playbackData.codeEventsIndex) {

                                        //add so when the playback is refreshed it will be at the same point
                                        restartPlaybackAtIndex++;
                                    }

                                //add it to the new list of events
                                newCodeEvents.push(currentEvent);
                            }

                        } else { //the current event does not come from a file with a selection to delete

                            //if this is before the current event index
                            if(i <= playbackData.codeEventsIndex) {

                                //add so when the playback is refreshed it will be at the same point
                                restartPlaybackAtIndex++;
                            }

                            //add it to the new list of events
                            newCodeEvents.push(currentEvent);
                        }
                    }

                    //update all future events that refer back to these
                    playbackData.codeEvents = newCodeEvents;
                
                    //return the pause point after the delete
                    return restartPlaybackAtIndex;

                }//else- there are no elements to delete
            }

            //This function renumbers all of the event ids in the playbackData's codeEvents array. 
            //This is used after the history of the playback is edited during playback so that all
            //of the events have an ascending numeric id at the end of the id.
            function renumberAllCodeEventIds(branchId, allElementIdsToDelete) {

                //numeric part of an event if
                var autoGeneratedEventId = 0;

                //holds the mappinsgs from old ids to new ones. This is for getting previous
                //neighbors correct
                var oldIdToNewIdMap = new Map();

                //every insert event that is at the beginning of a file file has "none" as its previous neighbor 
                oldIdToNewIdMap.set("none", "none");

                //go through all of the events
                for(var i = 0;i < playbackData.codeEvents.length;i++) {

                    //get an event
                    var currentEvent = playbackData.codeEvents[i];

                    //create a new event id with the numeric part of the id going in order
                    var newEventId = "ev_" + branchId + "_" + autoGeneratedEventId;

                    //store the old to new mapping of the id 
                    oldIdToNewIdMap.set(currentEvent.id, newEventId);

                    //change the event to have a new id
                    currentEvent.id = newEventId;

                    //if this event has a previous neighbor
                    if(currentEvent.previousNeighborId) {

                        //update it to the new value 
                        currentEvent.previousNeighborId = oldIdToNewIdMap.get(currentEvent.previousNeighborId);
                    }

                    //increase the numeric part of the id for the next event
                    autoGeneratedEventId++;
                }

                //now update all of the comments, delete  
                updateSelectedIdsInComments(allElementIdsToDelete, oldIdToNewIdMap);
            }

            //This function removes any selectedIds (highlights) in a comment because
            //they have been deleted. It also updates all of the ids since some of them
            //might have changed
            function updateSelectedIdsInComments(allElementIdsToDelete, oldIdToNewIdMap) {

                var newCommentPositions = {};

                //go through all of the event ids that have a comment
                for(var eventId in playbackData.comments) {
                    if(playbackData.comments.hasOwnProperty(eventId)) {

                        //get the array of comments for the event id
                        var arrayOfComments = playbackData.comments[eventId];

                        //if the event where this comment is located has changed
                        if(eventId !== oldIdToNewIdMap.get(eventId)) {

                            //add the comments at the new id
                            newCommentPositions[oldIdToNewIdMap.get(eventId)] = arrayOfComments;
                            
                            //delete the comments identified by the old id
                            delete playbackData.comments[eventId];
                        }

                        //go through each comment
                        for(var j = 0;j < arrayOfComments.length;j++) {

                            //get the comment
                            var comment = arrayOfComments[j];

                            //if the comment's id has changed then update the displayCommentEvent
                            if(comment.displayCommentEvent.id !== oldIdToNewIdMap.get(comment.displayCommentEvent.id)) {
                                
                                //update the copy of the display comment event that is stored in the comment 
                                comment.displayCommentEvent.id = oldIdToNewIdMap.get(comment.displayCommentEvent.id);
                            }

                            //go through all of the selected code ids in a comment
                            for(var k = comment.selectedCodeIds.length - 1;k >= 0;k--) {
                                
                                //get the selected code id
                                var selectedCodeId = comment.selectedCodeIds[k];

                                //if the selected id is one of the event ids being deleted
                                if(allElementIdsToDelete.has(selectedCodeId)) {

                                    //remove it from the array
                                    comment.selectedCodeIds.splice(k, 1);
                                
                                } else { //it should stay as a selected id

                                    //if the selected id is one of the ids that has changed
                                    if(selectedCodeId !== oldIdToNewIdMap.get(selectedCodeId)) {
                                        
                                        //update it
                                        comment.selectedCodeIds[k] = oldIdToNewIdMap.get(selectedCodeId);
                                    }
                                }
                            }
                        }
                    }
                }

                //update the playback's events
                for(var eventId in newCommentPositions) {
                    if(newCommentPositions.hasOwnProperty(eventId)) {

                        //put the moved comments back in playbackData's comments object
                        playbackData.comments[eventId] = newCommentPositions[eventId];
                    }
                }
            }

            //This function coordinates the replacing of selected text in the playback window with
            //some text entered in the replace UI. It uses much of the functionality of the insert
            //and delete functions above.
            function replaceHistory() {

                //get the text to insert
                var newCode = document.querySelector("#replaceNewHistoryText").value;

                //if there is some code to add 
                if(newCode.length > 0) {

                    //first, insert all of the new code at the pause point
                    //get all of the beginnings of the selected text                
                    var allBeginSelectedCodeElements = document.querySelectorAll("[class*=beginSelectedCode-]");
                    var allEndSelectedCodeElements = document.querySelectorAll("[class*=endSelectedCode-]");

                    //go through the pairs of begins and ends
                    for(var i = 0;i < allBeginSelectedCodeElements.length;i++) {

                        //get the first and last element of the same selected range
                        var beginElement = allBeginSelectedCodeElements[i];
                        var endElement = allEndSelectedCodeElements[i];

                        //if there is both a beginning and ending element
                        if(beginElement && endElement) {                        

                            //get the visible element before each selection
                            var insertAfterSpan = getPreviousVisibleSpan(beginElement);

                            //insert the text before each deleted section of code
                            restartPlaybackAtIndex = editPlaybackHistoryInsert(newCode, insertAfterSpan);

                            //update the playback data's index to account for the new code 
                            playbackData.codeEventsIndex = restartPlaybackAtIndex;
                        }
                    }


                    //next, delete any selected text
                    //holds the ids of all of the files with some selected text to delete                                
                    var allFileIdsWithSelectedText = new Set();

                    //holds the element ids in between the beginning and ending of each of the selections (inclusive)
                    var allElementIdsToDelete = new Set();

                    //get all of the file ids and selected code to delete (this includes code that may not be
                    //present on the screen yet because of how we build the dom)
                    getSelectedTextToDelete(allFileIdsWithSelectedText, allElementIdsToDelete);

                    //perform the delete of the selected characters
                    var restartPlaybackAtIndex = editPlaybackHistoryDelete(allFileIdsWithSelectedText, allElementIdsToDelete);


                    //renumber all of the event ids so that the new history looks like it was written in sequence
                    renumberAllCodeEventIds(playbackData.branchId, allElementIdsToDelete);

                    //redisplay the playback from the beginning
                    getPlaybackWindowsReadyForAnimation(true);

                    //move to where the playback will be with the new code
                    step("forward", restartPlaybackAtIndex, false);
                }                
            }

            //This function removes any comments associated with a event that was deleted
            function deleteCommentsForADeletedEvent(event) {

                //if there is an array of comments for this event
                if(playbackData.comments[event.id]) {

                    //remove any images

                    //remove any videos

                    //delete the array of comments
                    delete playbackData.comments[event.id];
                }
            }

            //*****************************************************************************
            //                         Comment related code
            //                         --------------------
            //*****************************************************************************
            /*
             * Clear out the comment div and un-highlight previous comment text
             */
            function clearPreviousComment() {

                //get the container of code comments
                var allCodeCommentsContainer = document.querySelector("#allCodeCommentsContainer");

                //empty out the old comment info
                allCodeCommentsContainer.innerHTML = "--";
                
                //remove any previously highlighted code
                removeCommentCodeHighlights();

                //revoke any video comments
                revokeActualVideoComments(); 
            }

            /*
             * Display one or more comments for the passed in event id.
             */
            function displayComments(eventId, isScrollToTop) {

                //get the group of all comments for this event (there can be more than one)
                var commentsForAnEvent = playbackData.comments[eventId];

                if(commentsForAnEvent && commentsForAnEvent.length > 0) {

                    //clear the previous comment
                    clearPreviousComment();

                    //revoke any previous video comments before adding new ones
                    revokeActualVideoComments();                 

                    //get the div that holds the number of comments read
                    var commentsReadProgress = document.querySelector("#commentsReadProgress");
                    
                    //add a class saying that there are some comments that have not been clicked and read
                    commentsReadProgress.classList.add("someUnreadComments");

                    //update the text to show that another comment has been read
                    commentsReadProgress.innerHTML = "Comments read 0/" + commentsForAnEvent.length;

                    //get the container of code comments and clear out all of the old comment info and scroll to the top
                    var allCodeCommentsContainer = document.querySelector("#allCodeCommentsContainer");
                    allCodeCommentsContainer.innerHTML = "";

                    //make sure the playback comments tab is active to display the comment
                    makePlaybackCommentTabActive();

                    //go through each comment
                    for(var i = 0;i < commentsForAnEvent.length;i++) {

                        //get the current comment
                        var comment = commentsForAnEvent[i];

                        //build up the ui for the comment
                        buildCommentUI(comment, (i + 1), commentsForAnEvent.length);
                    }

                    //if there are any highlighted code characters make sure the playback tab is visible and the highlighted code is visible
                    focusOnHighlightedCommentCode(commentsForAnEvent[0]);

                    //if the comments should start at the top of the container
                    if(isScrollToTop) {

                        allCodeCommentsContainer.scrollTop = 0;

                    } else { //no need to scroll to the top
                        
                        allCodeCommentsContainer.scrollTop = allCodeCommentsContainer.scrollHeight;
                    }
                }
            }

            /*
             * This function makes sure that if there is any highlighted code in a comment that the highlighted code
             * is visible on the screen. It first makes sure the playback tab is active and then scrolls to the first
             * highlighted character. 
             */
            function focusOnHighlightedCommentCode(comment) {
                    
                //remove any previous highlights
                removeCommentCodeHighlights();

                //if there is at least one highlighted code
                if(comment.selectedCodeIds.length > 0) {
                    
                    //add the new highlights
                    addCommentCodeHighlights(comment);

                    //get the first highlighted code character
                    var firstHighlightedCodeCharacter = document.querySelector("#" + comment.selectedCodeIds[0]);

                    if(firstHighlightedCodeCharacter) {

                        //get the file that this code is in
                        var firstHighlightedCodeCharacterFileId = firstHighlightedCodeCharacter.parentElement.getAttribute("id").substr("playbackWindow-".length);

                        //make sure the tab is active
                        makePlaybackTabActive(firstHighlightedCodeCharacterFileId);

                        //move the cursor 
                        handleScroll(firstHighlightedCodeCharacter);
                    }
                }
            }

            /*
             * Highlights code associated with a comment
             */
            function addCommentCodeHighlights(comment) {
                
                //go through all of the code that is to be highlighted
                for(var i = 0;i < comment.selectedCodeIds.length;i++) {

                    //get the code on the screen
                    var code = document.querySelector("#" + comment.selectedCodeIds[i]);

                    //if the code element can be found
                    if(code) {

                        //highlight the code
                        code.classList.add("commentRelevant");

                    } else {
                        console.log("Bad selected code id: " + comment.selectedCodeIds[i]);
                        console.log(comment);
                    }
                }
            }

            /*
             * Makes any highlighted comment code un-highlighted
             */ 
            function removeCommentCodeHighlights() {
                
                //remove any existing previously highlighted elements
                var previouslyHighlightedCodeComments = document.querySelectorAll(".commentRelevant");

                //go through the highlighted code 
                for(var i = 0;i < previouslyHighlightedCodeComments.length;i++) {
                    
                    //remove the class that highlights comments on each element
                    previouslyHighlightedCodeComments[i].classList.remove("commentRelevant");
                }
            }

            /*
             * Converts any highlighted code into selected code
             */
            function convertHighlightedCodeToSelectedCode() {

                //turn all of the highlighted code from the comment into potential new highlighted 
                var allHighlightedCodeInCurrentComment = document.querySelectorAll(".commentRelevant");

                //go through each of the highlighted code characters
                for(var i = 0;i < allHighlightedCodeInCurrentComment.length;i++) {
                    
                    //get a character
                    var highlightedCode = allHighlightedCodeInCurrentComment[i];

                    //remove the current highlight 
                    highlightedCode.classList.remove("commentRelevant");

                    //add the new potential highlight
                    highlightedCode.classList.add("selectedCode");
                } 
            }

            /*
             * Make the tab that displays comments active.
             */
            function makePlaybackCommentTabActive() {

                //make the add new comment list item inactive
                var addNewCommentListItem = document.querySelector("#addNewCommentListItem");
                addNewCommentListItem.classList.remove("active");

                //make the playback comment list item active
                var playbackCommentsListItem = document.querySelector("#playbackCommentsListItem");
                playbackCommentsListItem.classList.add("active");

                //make the add new comment tab inactive
                var addNewCommentTab = document.querySelector("#addNewCommentTab");
                addNewCommentTab.classList.remove("active");
                addNewCommentTab.classList.remove("in");

                //make the playback comments tab active
                var playbackCommentsTab = document.querySelector("#playbackCommentsTab");
                playbackCommentsTab.classList.add("active");
                playbackCommentsTab.classList.add("in");
            }

            /*
             * Makes a comment active (if there is a previously active comment it will be made inactive)
             */
            function makeCommentActive(comment, newActiveCommentContainer) {

                //get the active comment (might be null if this is there has been no comments clicked yet)
                previouslyActiveCommentContainer = document.querySelector(".activeComment");
                
                //make the clicked comment active
                newActiveCommentContainer.classList.add("activeComment");
                
                //if there was a previously active comment container
                if(previouslyActiveCommentContainer) {

                    //remove the active style from the previously active container
                    previouslyActiveCommentContainer.classList.remove("activeComment");

                    //get the previous comment's position drop down list
                    var previousCommentPositionDropDownContainer = previouslyActiveCommentContainer.querySelector(".commentPositionDropDownContainer");

                    //get the previous comment's text area
                    var previousCodeCommentText = previouslyActiveCommentContainer.querySelector(".codeCommentText");

                    //get the previously active comment's edit buttons
                    var previousEditCommentButton = previouslyActiveCommentContainer.querySelector(".editCommentButton");
                    var previousEditCommentToggleButton = previouslyActiveCommentContainer.querySelector(".editCommentToggleButton")

                    //make the previously active comment button uneditable
                    previousEditCommentButton.setAttribute("disabled", "true");
                    previousEditCommentButton.classList.remove("btn-primary");
                    previousEditCommentButton.innerHTML = "Edit Comment";                                             
                    previousEditCommentToggleButton.setAttribute("disabled", "true");   

                    //hide the comment position drop down list in this normal mode
                    previousCommentPositionDropDownContainer.classList.add("hiddenUntilEditable");    

                    //make the previous comment's text area uneditable
                    previousCodeCommentText.setAttribute("contenteditable", "false");

                    //remove any selected code 
                    clearSelectedCode();
                
                } //else- no previous active comment, this happens on a pause before any clicks of comments

                //get the newly active comment's edit buttons
                var newEditCommentButton = newActiveCommentContainer.querySelector(".editCommentButton");
                var newEditCommentToggleButton = newActiveCommentContainer.querySelector(".editCommentToggleButton")

                //make the selected comment editable
                newEditCommentButton.removeAttribute("disabled");
                newEditCommentToggleButton.removeAttribute("disabled");

                //if there are any highlighted code characters make sure the playback tab is visible and the highlighted code is visible
                focusOnHighlightedCommentCode(comment);
            }
            
            /*
             * Marks a comment as read.
             */
            function markCommentAsRead(activeCommentContainer) {

                //get the div that holds the number of comments read
                var commentsReadProgress = document.querySelector("#commentsReadProgress");

                //get the number of comments read and the total number of readable comments at this pause point
                var numberOfCommentsActuallyRead = document.querySelectorAll(".commentClickedAndRead").length;
                var numberOfReadableComments = document.querySelectorAll(".readableComment").length;
                
                //mark it as read
                activeCommentContainer.classList.add("commentClickedAndRead");

                //increase the total number of read comments by 1
                numberOfCommentsActuallyRead++;

                //if there are no more unread comments
                if(numberOfCommentsActuallyRead === numberOfReadableComments) {

                    //remove the class for unread comments
                    commentsReadProgress.classList.remove("someUnreadComments");
                }
                
                //update the text to show that another comment has been read
                commentsReadProgress.innerHTML = "Comments read " + numberOfCommentsActuallyRead + "/" + numberOfReadableComments;

                //get the comment number in this comment, remove a class, and add a class indicating it has been read
                var commentNumber = activeCommentContainer.querySelector(".commentNumberUnread");
                commentNumber.classList.remove("commentNumberUnread");
                commentNumber.classList.add("commentNumberRead");
            }

            /*
             * Build a UI for the comment.
             */
            function buildCommentUI(comment, currentCommentIndex, totalComments) {

                //grab the relevant info from the comment
                var text = comment.commentText;
                var devGroup = comment.developerGroupId;
                var timestamp = formatDateShortWithDayOfWeek(new Date(comment.timestamp));

                //create the div to hold the comment info and make it clickable
                var commentContainer = document.createElement("div");
                commentContainer.classList.add("well");
                commentContainer.classList.add("well-lg");
                commentContainer.classList.add("readableComment");

                //when someone clicks the comment
                commentContainer.addEventListener("click", function(e){
                //commentContainer.addEventListener("mouseenter", function(e){ //for mouse over instead of a click

                    //get the active comment (might be null if this is there has been no comments clicked yet)
                    activeCommentContainer = document.querySelector(".activeComment");

                    //if the active comment is different than the one clicked
                    if(activeCommentContainer !== commentContainer) {

                        //make the previous comment inactive (if there is one) and the new comment active
                        makeCommentActive(comment, commentContainer);

                    } //else- the comment clicked is already the active comment, do nothing
                
                    //if this comment has NOT been clicked and read before 
                    if(!commentContainer.classList.contains("commentClickedAndRead")) {

                        //mark the new comment as having been read
                        markCommentAsRead(commentContainer);
                    
                    } //else- this comment has been read and clicked before, there is no need to mark it as read again
                });

                //for each of the comment images
                for(var i = 0;i < comment.images.length;i++) {
                    
                    //get a small pic of the image 
                    var smallImage = getCommentImagePreview(286, 225, comment.images[i].dataURL);

                    //create a link so users can click the small image and bring up the comment pic modal
                    var smallImageLink = document.createElement("a");
                    smallImageLink.setAttribute("href", "#");
                    smallImageLink.setAttribute("data-toggle", "modal");
                    smallImageLink.setAttribute("data-target", "#commentPictureDisplayModal");
                    smallImageLink.appendChild(smallImage);

                    //add the event handler
                    smallImageLink.addEventListener("click", function(e){
                        
                        //add the image to the large display
                        var largeImageDisplay = document.querySelector("#largeImageDisplay");
                        largeImageDisplay.src = e.target.getAttribute("src");

                        //re-display the comment text to the modal also
                        var commentTextInLargeDisplay = document.querySelector("#commentTextInLargeDisplay");
                        commentTextInLargeDisplay.innerHTML = comment.commentText;
                    });

                    commentContainer.appendChild(smallImageLink);
                }

                //for each of the video comments
                for(var i = 0;i < comment.videoComments.length;i++) {

                    //create a video control element
                    var videoElement = document.createElement("video");
                    //mark it as a video window for css
                    videoElement.classList.add("videoWindow");
                    
                    //add video playback controls
                    videoElement.setAttribute("controls", "");
                    //this is a stored video clip not one that is in preview that may be added to a comment
                    videoElement.classList.add("actualVideoClip");

                    //get the data url that contains the video and convert it back to a blob (http://stackoverflow.com/questions/12168909/blob-from-dataurl)
                    var videoCommentDataURL = comment.videoComments[i];

                    //get the base64 encoded data portion of the data url and decode it back to raw data 
                    var rawVideoData = atob(videoCommentDataURL.split(",")[1]);
                    //buffer the data 
                    var arrBuff = new ArrayBuffer(rawVideoData.length);
                    var uintArr = new Uint8Array(arrBuff);
                    for (var j = 0; j < rawVideoData.length; j++) {
                        uintArr[j] = rawVideoData.charCodeAt(j);
                    }
                    //turn the buffer into an video blob
                    var blob = new Blob([arrBuff], {type: "video/webm"});

                    //create a data url and load the video control with it
                    var videoURL = window.URL.createObjectURL(blob);
                    videoElement.setAttribute("src", videoURL);

                    //add the video to the comment container
                    commentContainer.appendChild(videoElement);
                }

                var divPanel = document.createElement("div");
                divPanel.classList.add("panel");
                divPanel.classList.add("panel-default");

                //add the comment text
                var commentTextDiv = document.createElement("div");
                commentTextDiv.classList.add("codeCommentText");
                commentTextDiv.classList.add("storytellerEditable");
                commentTextDiv.classList.add("panel-body");
                commentTextDiv.setAttribute("contenteditable", "false");
                commentTextDiv.innerHTML = (text === "") ? "--" : text;
                //add the comment author and timestamp
                var commentInfoDiv = document.createElement("div");
                commentInfoDiv.classList.add("panel-footer");

                //display the developers who made the comment
                //get the info about all of the dev's in the dev group who made the comment
                var devs = getDevelopersInDevGroup(devGroup);

                //go through each of the developers
                for(var j = 0;j < devs.length;j++) {

                    //add the dev group who made the comment
                    commentInfoDiv.appendChild(getDevElement(devs[j], 30));
                }

                divPanel.appendChild(commentTextDiv);
                //make a text formatting toolbar for the comment
                var textEditToolbar = makeATextEditToolbar();
                //hide it until the comment is edited
                textEditToolbar.classList.add("hiddenUntilEditable");                
                divPanel.appendChild(textEditToolbar);
                divPanel.appendChild(commentInfoDiv);
                commentContainer.appendChild(divPanel);

                //add a button group for edit and delete
                var editCommentButtonGroup = document.createElement("div");
                editCommentButtonGroup.classList.add("btn-group"); 

                //drop down list to change the order of comments in edit mode
                var commentPositionDropDown = document.createElement("select");
                commentPositionDropDown.classList.add("commentPositionDropDown");

                //create the options for the drop down
                for(var i = 1;i <= totalComments;i++) {

                    //create an option for the drop down list
                    var commentPositionOption = document.createElement("option");
                    
                    //if this is position of the current comment
                    if(i === currentCommentIndex) {
                        
                        //make this the selected option
                        commentPositionOption.setAttribute("selected", "true");

                        //store the original position of the comment in the drop down list
                        commentPositionDropDown.setAttribute("originalCommentPosition", (i - 1).toString());                        
                    }

                    //store the comment number in the option 
                    commentPositionOption.innerHTML = i;

                    //add the option to the drop down list
                    commentPositionDropDown.appendChild(commentPositionOption);
                }

                //label text for the drop down
                var newCommentPosLabel = document.createElement("span");
                newCommentPosLabel.innerHTML = " Update the comment position: ";

                var updateCommentPositionDiv = document.createElement("div");
                updateCommentPositionDiv.classList.add("text-right");
                updateCommentPositionDiv.classList.add("hiddenUntilEditable");
                updateCommentPositionDiv.classList.add("commentPositionDropDownContainer");                

                updateCommentPositionDiv.appendChild(newCommentPosLabel);
                updateCommentPositionDiv.appendChild(commentPositionDropDown);

                var commentNumberDiv = document.createElement("div");
                commentNumberDiv.classList.add("text-right");
                var commentNumberSpan = document.createElement("span");
                commentNumberSpan.classList.add("commentNumberUnread");
                commentNumberSpan.innerHTML = "&nbsp" + currentCommentIndex + "/" + totalComments;
                commentNumberDiv.appendChild(commentNumberSpan);

                //edit button
                var editCommentButton = document.createElement("button");
                editCommentButton.classList.add("btn");
                editCommentButton.classList.add("btn-xs");
                editCommentButton.classList.add("editCommentButton");
                editCommentButton.setAttribute("disabled", "true");
                editCommentButton.innerHTML = "Edit Comment";
                editCommentButton.addEventListener("click", function(e) {
                    
                    //if the user has selected to edit a comment
                    if(editCommentButton.innerHTML === "Edit Comment") {

                        //turn all of the highlighted code from the comment into potential new highlighted 
                        convertHighlightedCodeToSelectedCode();

                        //show the comment position drop down list in this edit mode
                        updateCommentPositionDiv.classList.remove("hiddenUntilEditable");                

                        //make the comment editable
                        commentTextDiv.setAttribute("contenteditable", "true");
                        commentTextDiv.focus();

                        //make the text formatting toolbar visible
                        textEditToolbar.classList.remove("hiddenUntilEditable");                

                        //update the edit button
                        editCommentButton.classList.add("btn-primary");
                        editCommentButton.innerHTML = "Save changes";

                    } else { //the user chose to save after an edit

                        //hide the comment position drop down list in this normal mode
                        updateCommentPositionDiv.classList.add("hiddenUntilEditable");                

                        //make the comment text are uneditable
                        commentTextDiv.setAttribute("contenteditable", "false");

                        //update the save button
                        editCommentButton.classList.remove("btn-primary");
                        editCommentButton.innerHTML = "Edit Comment";

                        //get the selected index position of the comment (0 based)
                        var commentPositionDropDown = commentContainer.querySelector(".commentPositionDropDown");
                        
                        //update the comment in the browser and on the server
                        updateCommentInBrowserOnly(comment, commentContainer);
                        updateCommentInEditorsDB(comment);

                        //get the original position of the comment
                        var originalCommentPosition = parseInt(commentPositionDropDown.getAttribute("originalCommentPosition"));

                        //if the selected comment position is NOT the same as its original position
                        if(originalCommentPosition !== commentPositionDropDown.selectedIndex) {

                            //get the new comment position
                            var newCommentPosition = parseInt(commentPositionDropDown.options[commentPositionDropDown.selectedIndex].value) - 1;

                            //update comment position
                            updateCommentPositionInBrowserOnly(comment, originalCommentPosition, newCommentPosition);
                            updateCommentPositionInEditorsDB(comment, originalCommentPosition, newCommentPosition);

                            //re-display all of the comments in their new order
                            displayComments(comment.displayCommentEvent.id, true);
                        }

                        //make the text formatting toolbar invisible
                        textEditToolbar.classList.add("hiddenUntilEditable");                

                    }
                });

                //toggle button
                var editCommentButtonToggle = document.createElement("button");
                editCommentButtonToggle.classList.add("btn");
                editCommentButtonToggle.classList.add("btn-xs");
                editCommentButtonToggle.classList.add("dropdown-toggle");
                editCommentButtonToggle.classList.add("editCommentToggleButton");
                editCommentButtonToggle.setAttribute("data-toggle", "dropdown");
                editCommentButtonToggle.setAttribute("disabled", "true");

                var toggleButtonSpan = document.createElement("span");
                toggleButtonSpan.classList.add("caret");
                editCommentButtonToggle.appendChild(toggleButtonSpan);

                //list of other buttons
                var editCommentListOptions = document.createElement("ul");
                editCommentListOptions.classList.add("dropdown-menu");

                //full delete of comment
                var deleteCommentListItem = document.createElement("li");
                var deleteCommentAnchor = document.createElement("a");
                deleteCommentAnchor.setAttribute("href", "#");
                deleteCommentAnchor.innerHTML = "Delete the comment";
                deleteCommentAnchor.addEventListener("click", function(e) {
                    
                    //delete in the browser and in the db
                    deleteCommentInBrowserOnly(comment, commentContainer);
                    deleteCommentInEditorsDB(comment);

                    //re-display all of the comments in their new order
                    displayComments(comment.displayCommentEvent.id, true);
                });
                deleteCommentListItem.appendChild(deleteCommentAnchor);

                editCommentListOptions.appendChild(deleteCommentListItem);

                editCommentButtonGroup.appendChild(editCommentButton);
                editCommentButtonGroup.appendChild(editCommentButtonToggle);
                editCommentButtonGroup.appendChild(editCommentListOptions);

                var editCommentDiv = document.createElement("div");
                editCommentDiv.appendChild(editCommentButton);
                editCommentDiv.appendChild(editCommentButtonGroup);
                commentContainer.appendChild(editCommentDiv);

                commentContainer.appendChild(commentNumberDiv);
                commentContainer.appendChild(updateCommentPositionDiv);
                
                //get the comments container and add the new comment to it
                var allCodeCommentsContainer = document.querySelector("#allCodeCommentsContainer");
                allCodeCommentsContainer.appendChild(commentContainer);
            }

            /*
             * adds a new comment to the storyteller server
             */
            function addCommentInEditorsDB(insertedComment) {

                //insert the comment on the server
                var xmlhttp = new XMLHttpRequest();   
                xmlhttp.addEventListener("load", function(){

                    console.log("successfully added a comment and receieved a response");
                });

                xmlhttp.addEventListener("error", function(){
                    
                    //notify the user that there was a problem
                    makeAnAlert("We were unable to permanently store your comment", "alert-danger", "commentAlertArea");
                });

                xmlhttp.open("POST", "/comment");
                xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                xmlhttp.send(JSON.stringify(insertedComment));
            }

            /*
             * updates a comment in the browser only
             */
            function updateCommentInBrowserOnly(comment, commentContainer) {
                
                //get the comment text area from the comment container
                var codeCommentText = commentContainer.querySelector(".codeCommentText");

                //get all of the new commented code
                var selectedCodeIds = getSelectedCodeIds();
                
                //get the array of events at the event id
                var arrayOfCommentsAtThisEvent = playbackData.comments[comment.displayCommentEvent.id];                                
                //get the index of the passed in comment
                var indexOfComment = arrayOfCommentsAtThisEvent.indexOf(comment);

                //get the comment to update
                var updatedComment = arrayOfCommentsAtThisEvent[indexOfComment];
                
                //update the comment text for this event
                updatedComment.commentText = codeCommentText.innerHTML;
                updatedComment.selectedCodeIds = selectedCodeIds;

                //clear the selected code and highlight the new code
                clearSelectedCode();
                focusOnHighlightedCommentCode(comment);                    
            }

            /*
             * updates a comment to the storyteller server
             */
            function updateCommentInEditorsDB(updatedComment) {
                
                //update the comment on the server
                var xmlhttp = new XMLHttpRequest();   
                xmlhttp.addEventListener("load", function(){

                    //TODO add something to the UI
                    console.log("successfully updated a comment and receieved a response");
                });

                xmlhttp.addEventListener("error", function(){
                    
                    //notify the user that there was a problem
                    makeAnAlert("We were unable to update your comment", "alert-danger", "commentAlertArea");

                });

                xmlhttp.open("PUT", "/comment");
                xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                xmlhttp.send(JSON.stringify(updatedComment));
            }

            /*
             * Update the position of the comment in the browser by rearranging the array in playbackData
             */
            function updateCommentPositionInBrowserOnly(comment, oldCommentPosition, newCommentPosition) {

                //get the array of events at the event id
                var arrayOfCommentsAtThisEvent = playbackData.comments[comment.displayCommentEvent.id];                

                //move the comment into its new position
                //get the element to move
                var element = arrayOfCommentsAtThisEvent[oldCommentPosition];

                //remove it from the array
                arrayOfCommentsAtThisEvent.splice(oldCommentPosition, 1);

                //add it back in the new postion
                arrayOfCommentsAtThisEvent.splice(newCommentPosition, 0, element);
            }

            /*
             * Send a request to rearrange the comment position on the server
             */
            function updateCommentPositionInEditorsDB(comment, oldCommentPosition, newCommentPosition) {

                //update the comment on the server
                var xmlhttp = new XMLHttpRequest();   
                xmlhttp.addEventListener("load", function(){

                    //TODO add something to the UI
                    console.log("successfully updated a comment position and receieved a response");
                });

                xmlhttp.addEventListener("error", function(){
                    
                    //notify the user that there was a problem
                    makeAnAlert("We were unable to update your comment position", "alert-danger", "commentAlertArea");
                });

                //create an object that tells the server what to move and where to move it
                var updatedCommentPosition = {
                    eventId: comment.displayCommentEvent.id, 
                    oldCommentPosition: oldCommentPosition, 
                    newCommentPosition: newCommentPosition
                };

                xmlhttp.open("PUT", "/commentPosition");
                xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                xmlhttp.send(JSON.stringify(updatedCommentPosition));            
            }

            /*
             * Deletes a comment in the browser only
             */
            function deleteCommentInBrowserOnly(comment, commentContainer) {
                
                //get the array of events at the event id
                var arrayOfCommentsAtThisEvent = playbackData.comments[comment.displayCommentEvent.id];
                var indexOfComment = arrayOfCommentsAtThisEvent.indexOf(comment);

                //if the comment was found
                if(indexOfComment >= 0) {

                    //remove the comment container
                    commentContainer.parentNode.removeChild(commentContainer);

                    //remove the comment
                    arrayOfCommentsAtThisEvent.splice(indexOfComment, 1);
                    
                    //if there are no more comments at this event
                    if(arrayOfCommentsAtThisEvent.length === 0) {

                        //remove the whole collection for this event
                        delete playbackData.comments[comment.displayCommentEvent.id];

                        //remove the comment marker from the slider
                        var commentMarker = document.querySelector("#commentPos_" + comment.displayCommentEvent.id);
                        commentMarker.parentNode.removeChild(commentMarker);
                    }
                }
            }

            /*
             * Deletes a comment in the storyteller server
             */
            function deleteCommentInEditorsDB(deletedComment) {
                
                //delete the comment on the server
                var xmlhttp = new XMLHttpRequest();   
                xmlhttp.addEventListener("load", function(){

                    //TODO add something to the UI
                    console.log("successfully deleted a comment and receieved a response");
                });

                xmlhttp.addEventListener("error", function(){

                    //TODO add a message to the UI indicating that there is no server to respond
                    console.log("was not able to delete a comment");
                    
                    //notify the user that there was a problem
                    makeAnAlert("We were unable to delete your comment", "alert-danger", "commentAlertArea");

                });

                xmlhttp.open("DELETE", "/comment");
                xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                xmlhttp.send(JSON.stringify(deletedComment));
            }

            /*
             * Updates a playback description (title and descriptive text) in the storyteller server
             */
            function updatePlaybackDescriptionInEditorsDB(updatedTitle, updatedDescription) {
                
                //update the title and description on the server
                var xmlhttp = new XMLHttpRequest();   
                xmlhttp.addEventListener("load", function(){

                    //TODO add something to the UI
                    console.log("successfully updated a comment and receieved a response");
                });

                xmlhttp.addEventListener("error", function(){

                    //TODO add a message to the UI indicating that there is no server to respond
                    console.log("was not able to update a comment");
                    
                    //notify the user that there was a problem
                    makeAnAlert("We were unable to update your comment", "alert-danger", "commentAlertArea");

                });

                //make an object with the new title and description
                var updatedPlaybackDescription = {
                    title: updatedTitle,
                    description: updatedDescription
                };

                xmlhttp.open("PUT", "/playbackDescription");
                xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                xmlhttp.send(JSON.stringify(updatedPlaybackDescription));
            }

            /*
             * Get an img element for the image
             */
            function getCommentImagePreview(width, height, dataURL) {

                var commentImage = document.createElement("img");
                commentImage.setAttribute("height", height);
                commentImage.setAttribute("width", width);
                commentImage.classList.add("commentImage");
                commentImage.classList.add("img-thumbnail");

                //make the image source the canvas image
                commentImage.src= dataURL;

                return commentImage;
            }

            /*
             * Get an image with a checkbox in a table
             */
            function getSelectableCommentImagePreview(commentImage, imgId, className) {

                var table = document.createElement("table");
                table.classList.add("selectableCommentImageTable");

                table.appendChild(document.createElement("tr"));
                table.appendChild(document.createElement("tr"));

                var chBox = document.createElement("input");
                chBox.setAttribute("type", "checkbox");
                chBox.setAttribute("value", imgId);
                chBox.setAttribute("checked", "checked");
                chBox.classList.add(className);

                var td = document.createElement("td");
                td.appendChild(commentImage);
                table.children[0].appendChild(td);

                td = document.createElement("td");
                td.appendChild(document.createTextNode(""));
                table.children[1].appendChild(td);

                td = document.createElement("td");
                td.appendChild(chBox);
                table.children[1].appendChild(td);

                return table;
            }

            /*
             * Get the drawing canvas ready for drawing
             */
            function setUpDrawingCanvas()
            {
                //store the canvas
                canvasData.commentCanvas = document.querySelector("#commentCanvas");
                //store the 2D context
                canvasData.commentCanvasContext = commentCanvas.getContext("2d");

                //set the drawing line parameters
                canvasData.commentCanvasContext.lineWidth = 4; //if this changes, make a change in the html to highlight the selected width
                canvasData.commentCanvasContext.lineJoin = 'round';
                canvasData.commentCanvasContext.lineCap = 'round';
                canvasData.commentCanvasContext.strokeStyle = 'blue'; //if this changes, make a change in the html to highlight the selected color

                //get the modal that holds the canvas
                var editCommentPictureModal = document.querySelector("#editCommentPictureModal");

                //capture mouse moves and always have a current mouse position
                canvasData.commentCanvas.addEventListener("mousemove", function(e){

                    //store the old current mouse position and the previous mouse position
                    canvasData.previousMousePosition.x = canvasData.currentMousePosition.x;
                    canvasData.previousMousePosition.y = canvasData.currentMousePosition.y;

                    //get the bounding rectangle
                    var boundingRectangle = canvasData.commentCanvas.getBoundingClientRect();

                    //get the new mouse position
                    canvasData.currentMousePosition.x = e.clientX - boundingRectangle.left;
                    canvasData.currentMousePosition.y = e.clientY - boundingRectangle.top;
                });

                //mouse down
                canvasData.commentCanvas.addEventListener('mousedown', function(e) {

                    //draw the first line segment 
                    canvasData.commentCanvasContext.beginPath();
                    canvasData.commentCanvasContext.moveTo(canvasData.previousMousePosition.x, canvasData.previousMousePosition.y);
                    canvasData.commentCanvasContext.lineTo(canvasData.currentMousePosition.x, canvasData.currentMousePosition.y);
                    canvasData.commentCanvasContext.stroke();

                    //add an additional listener to draw all future line segments while the mouse is down
                    commentCanvas.addEventListener('mousemove', onPaint);

                    //create a point that represents the beginning of the line
                    var startOfLinePoint = {
                        x: canvasData.previousMousePosition.x, 
                        y: canvasData.previousMousePosition.y,
                        width: canvasData.commentCanvasContext.lineWidth,
                        color: canvasData.commentCanvasContext.strokeStyle,
                        type: "start"
                    };

                    //add it to the list of points to undo
                    canvasData.undoList.push(startOfLinePoint);
                });

                //mouse up
                commentCanvas.addEventListener('mouseup', function() {

                    //remove the additional mouse move listener
                    canvasData.commentCanvas.removeEventListener('mousemove', onPaint);

                    //create a point that represents the end of the line
                    var endOfLinePoint = {
                        x: canvasData.currentMousePosition.x, 
                        y: canvasData.currentMousePosition.y,
                        type: "end"
                    };      

                    //add it to the list of points to undo
                    canvasData.undoList.push(endOfLinePoint);              
                });

                //an additional mouse listener to paint part of a line
                var onPaint = function() {

                    //draw the line
                    canvasData.commentCanvasContext.beginPath();
                    canvasData.commentCanvasContext.moveTo(canvasData.previousMousePosition.x, canvasData.previousMousePosition.y);
                    canvasData.commentCanvasContext.lineTo(canvasData.currentMousePosition.x, canvasData.currentMousePosition.y);
                    canvasData.commentCanvasContext.stroke();

                    //create a point that represents the interior of the line
                    var interiorOfLinePoint = {
                        x: canvasData.currentMousePosition.x, 
                        y: canvasData.currentMousePosition.y,
                        type: "interior"
                    };

                    //add it to the list of points to undo
                    canvasData.undoList.push(interiorOfLinePoint);
                };
            }

            /*
             * Sets the pen width for drawing. Also highlights an element on the screen so the user knows which pen width is selected
             */
            function setPenWidth(newPenSize, selectedPenElement) {

                //remove the previous selected pen size class from the width chooser
                var previousSelectedPenWidth = document.getElementsByClassName("penSizeSelected")[0];
                previousSelectedPenWidth.classList.remove("penSizeSelected");

                //highlight the new selected element
                selectedPenElement.classList.add("penSizeSelected");

                //store the chosen pen size
                canvasData.commentCanvasContext.lineWidth = newPenSize;
            }

            /*
             * Sets the pen color for drawing. Also highlights an element on the screen so the user knows which pen color is selected
             */
            function setPenColor(newColor, selectedPenElement) {
                    
                //remove the selected pen color class
                var previousSelectedPenColor = document.getElementsByClassName("penColorSelected")[0];
                previousSelectedPenColor.classList.remove("penColorSelected");

                //make this the selected pen color
                selectedPenElement.classList.add("penColorSelected");

                //store the chosen pen color
                canvasData.commentCanvasContext.strokeStyle = newColor;
            }

            /*
             * Completely clears the image on the drawing canvas- removes all pen strokes, removes any background image that may be on the canvas, 
             * and clears out the undo history
             */
            function clearCanvasImage() {

                //if there is an image on the canvas
                if(canvasData.basePicture) {

                    //remove the image info from the canvas object
                    canvasData.basePicture = null;                        
                }
                
                //clear out the undo history
                clearUndoHistory();
                
                //completely clear the drawing canvas
                canvasData.commentCanvasContext.clearRect(0, 0, canvasData.commentCanvas.width, canvasData.commentCanvas.height);
            }

            /*
             * Adds an image to the drawing canvas to be a part of a comment (can also be drawn on)
             */
            function importImageIntoCanvas(imageFile) {

                //create a reader to read the data
                var fileReader = new FileReader();

                //once the data is done being read
                fileReader.onload = function(data) {

                    //clear any undo history since this will start a 'fresh' image
                    clearUndoHistory();

                    //draw the selected image on the canvas
                    setImageOnDrawingCanvas(data.target.result);
                };

                //handler for a file that can't be displayed on the canvas
                fileReader.onerror = function(data) {
                    console.log("Error reading file to add to the comment image canvas");
                }

                //begin the read operation to read the selected image file
                fileReader.readAsDataURL(imageFile);
            }

            /*
             * This is called when the user chooses to use an image in a comment. The comment may or may not be saved or
             * the user may choose to deselect the image preview so this does not guarantee that the canvas image will
             * for sure be part of a comment.
             */
            function useImageInAComment() {
                
                //turn the image on the canvas into a data url
                var dataURL = canvasData.commentCanvas.toDataURL("image/png", 1.0);

                //generate a unique image id
                var imgId = images.prependId + images.sequenceNumber
                images.sequenceNumber++;

                //create an image object
                    var image = {
                    imgId: imgId,
                    dataURL: dataURL,
                    timestamp: Date.now()
                };

                //store the image object in the global image object 
                images[image.imgId] = image;

                //add the image to the collection that shows images that will be added to the comment
                //get the collection of images that will be added to the comment
                var commentImagesInComment = document.querySelector("#commentImagesInComment");

                //get an image element with a scaled down picture of the image
                var previewImg = getCommentImagePreview(80, 80, dataURL);

                //create a small image preview that can be selected or deselected
                var commentImagePreview = getSelectableCommentImagePreview(previewImg, imgId, "selectedCommentImage");

                //append a preview of the comment image
                commentImagesInComment.appendChild(commentImagePreview);

                //add an image to the gallery of starting points
                addImageToStartingPointGallery(images[imgId]);
            }

            /*
             * Clear the undo history
             */
            function clearUndoHistory() {
                
                //clear out the undo history
                canvasData.undoList = [];
                canvasData.redoList = [];
            }

            /*
             * Adds an image to the drawing canvas and scales it so that it fits in it.
             * If there are any points on the canvas they will be redrawn.
             */
            function setImageOnDrawingCanvas(dataURL) {
                
                //completely clear the drawing canvas
                canvasData.commentCanvasContext.clearRect(0, 0, canvasData.commentCanvas.width, canvasData.commentCanvas.height);

                //create an image
                var img = new Image();

                //when the image is finally loaded
                img.onload = function() {

                    //scale the image to fit completely on the canvas                    
                    var scaledWidth;
                    var scaledHeight;
                        
                    //get the ratios of the width and height to the canvas dimensions
                    var widthRatio = canvasData.commentCanvas.width / img.width;
                    var heightRatio = canvasData.commentCanvas.height / img.height;

                    //if the width ratio is smaller than the height ratio
                    if(widthRatio <= heightRatio) {
                        
                        //scale using the smaller width ratio to scale the height
                        scaledWidth = canvasData.commentCanvas.width;
                        scaledHeight = widthRatio * img.height;

                    } else { //the height ratio is smaller that the width ratio

                        //scale using the smaller height ratio to scale the width ratio
                        scaledWidth = heightRatio * img.width;
                        scaledHeight = canvasData.commentCanvas.height;
                    }

                    //draw a scaled image onto the canvas
                    canvasData.commentCanvasContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, scaledWidth, scaledHeight);

                    //redraw any lines that are left in the undo history
                    redrawAllPoints();
                }

                //load the image with the image file selected
                img.src = dataURL;

                //store the data url in the canvas data
                canvasData.basePicture = dataURL;
            }

            /*
             * Redraws the canvas including any lines that are on it. If there is an image
             * it will be redrawn before the lines are added.
             */
            function redrawCanvasWithLines() {
                
                //if there is NOT a value for the base picture
                if(!canvasData.basePicture) {
                    
                    //completely clear the drawing canvas
                    canvasData.commentCanvasContext.clearRect(0, 0, canvasData.commentCanvas.width, canvasData.commentCanvas.height);

                    //redraw all the lines
                    redrawAllPoints();

                } else { //there is a base picture for the canvas

                    //redraw the base image (lines will be redrawn once the background image is drawn)
                    setImageOnDrawingCanvas(canvasData.basePicture);
                }
            }

            /*
             * Undo the latest line drawn
             */
            function undoADrawnLine() {

                //get all the points that have been drawn
                var points = canvasData.undoList;

                //if there are any points
                if(points.length > 0) {

                    //remove the last "end" point and add it to the list
                    canvasData.redoList.push(points.pop());

                    //remove all the other points until we run out of points or encounter the previous "end" point
                    while(points.length > 0 && points[points.length - 1].type !== "end") {

                        //add the points to the redo list
                        canvasData.redoList.push(points.pop());
                    }

                    //redraw the remaining points (the last line is not included anymore)
                    redrawCanvasWithLines();
                }
            }

            /*
             * Redo the latest line that was undone
             */
             function redoADrawnLine() {
                
                //get all the points that have been undone
                var points = canvasData.redoList;

                //if there are any points
                if(points.length > 0) {

                    //remove the last "start" point and add it to the list
                    canvasData.undoList.push(points.pop());

                    //remove all the other points until we run out of points or encounter the previous "start" point
                    while(points.length > 0 && points[points.length - 1].type !== "start") {

                        //add the points to the undo list
                        canvasData.undoList.push(points.pop());
                    }

                    //redraw the points with the undone points added back
                    redrawCanvasWithLines();
                }
            }

            /*
             * Redraw all of the points on the canvas connecting them into lines
             */
            function redrawAllPoints() {
                
                //if there are some points to redraw
                if(canvasData.undoList.length > 0) {

                    //store the current pen configuration
                    var previousPenWidth = canvasData.commentCanvasContext.lineWidth;
                    var previousPenColor = canvasData.commentCanvasContext.strokeStyle;

                    //go through each point
                    for(var i = 0;i < canvasData.undoList.length;i++) {

                        //get the most recent point 
                        var point = canvasData.undoList[i];

                        //if this is the start of a line
                        if(point.type === "start") {

                            //set the context to the line's width and color
                            canvasData.commentCanvasContext.lineWidth = point.width;
                            canvasData.commentCanvasContext.strokeStyle = point.color;
                            
                            //begin the path and move to the first point
                            canvasData.commentCanvasContext.beginPath();
                            canvasData.commentCanvasContext.moveTo(point.x, point.y);

                        } else if(point.type === "interior") { //this is the interior of a line

                            //connect to the next interior point
                            canvasData.commentCanvasContext.lineTo(point.x, point.y);

                        } else if(point.type === "end") { //this is the end of a line

                            //connect the last point
                            canvasData.commentCanvasContext.lineTo(point.x, point.y);

                            //draw the line
                            canvasData.commentCanvasContext.stroke();
                        } 
                    }

                    //restore the pen to its previous state
                    canvasData.commentCanvasContext.lineWidth = previousPenWidth;
                    canvasData.commentCanvasContext.strokeStyle = previousPenColor;
                }
            }

            /*
             * This function will add an image to the starting point image gallery (a gallery where images
             * can be selected as a starting point to build on)
             */
            function addImageToStartingPointGallery(img) {

                //get the gallery of images to build off of
                var commentImageStartingPointGallery = document.querySelector("#commentImageStartingPointGallery");

                //create a small image
                var commentImageStartingPointImage = getCommentImagePreview(60, 60, img.dataURL);

                //make a link that points to nothing
                var commentImageStartingPointLink = document.createElement("a");
                commentImageStartingPointLink.setAttribute("href", "#");

                //put the image in the link
                commentImageStartingPointLink.appendChild(commentImageStartingPointImage);

                //when the user clicks on this link
                commentImageStartingPointLink.addEventListener("click", function(e){

                    //clear any undo history since this will start a 'fresh' image
                    clearUndoHistory();

                    //draw the selected image on the canvas
                    setImageOnDrawingCanvas(img.dataURL);
                });

                //add the image to the gallery
                commentImageStartingPointGallery.appendChild(commentImageStartingPointLink);                
            }

            /*
             * This function gets all the images from the comments in a playback and adds them to the
             * images collection and the starting point image gallery.
             */
            function displayCommentImagesInGallery() {
                
                //holds all of the images from the comments
                var allCommentImages = [];

                //go through each of events where there is at least one comment
                for(var eventId in playbackData.comments) {
                    if(playbackData.comments.hasOwnProperty(eventId)) {

                        //get all of the comments at each event                         
                        var commentsForAnEvent = playbackData.comments[eventId];

                        //go through all of the comments at an event
                        for(var i = 0;i < commentsForAnEvent.length;i++) {
                            
                            //if there is one or more images for this comment
                            if(commentsForAnEvent[i].images && commentsForAnEvent[i].images.length > 0) {
                                
                                //get the images for this comment
                                var imagesForAnEvent = commentsForAnEvent[i].images;

                                //go through all of the images
                                for(var j = 0;j < imagesForAnEvent.length;j++) {

                                    //get the image
                                    var image = imagesForAnEvent[j]; 
                                                                        
                                    //add the image to a collection
                                    allCommentImages.push(image);
                                }
                            }
                        }
                    }
                }

                //if there were any images from the comments
                if(allCommentImages.length > 0) {
                    
                    //get the gallery of images to build off of
                    var commentImageStartingPointGallery = document.querySelector("#commentImageStartingPointGallery");
                    //clear all existing images
                    commentImageStartingPointGallery.innerHTML = "";

                    //sort the images by their creation timestamp
                    allCommentImages.sort(function(firstImg, secondImg) {return firstImg.timestamp - secondImg.timestamp;});

                    //go through each of the images from the comments
                    for(var i = 0;i < allCommentImages.length;i++) {

                        //get the image
                        var image = allCommentImages[i];

                        //add the image to the collection of all images
                        images[image.imgId] = image;

                        //add the image to the gallery
                        addImageToStartingPointGallery(image);

                        //increase the image sequence number so new images get unique ids
                        images.sequenceNumber++;
                    }
                }
            }

            /*
             * Sets up the page for recording video comments
             */
            function setUpVideoRecordingOfComments() {
                
                //get the user media or an alternative if it doesn't exist
                navigator.getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);

                //if there is media support
                if (navigator.getUserMedia && window.MediaRecorder) {

                    //record audio and video 
                    var constraints = { 
                        audio: true,
                        video: true
                    };

                    //holds the raw video data
                    var chunksOfVideoData = [];

                    //set up the handlers for the call to navigator.getUserMedia
                    //if the media object can be configured
                    var onSuccess = function(stream) {

                        //store the media stream in a global so that it can be used to turn the web cam off later
                        mediaStream = stream;

                        //tie the media stream to the video preview window
                        document.querySelector("#previewVideoWindow").srcObject = stream;

                        //use the stream to make a media recorder and store it in the global variable
                        mediaRecorder = new MediaRecorder(stream);

                        //the function that will be called once the video data is ready to be stored                        
                        mediaRecorder.onstop = function(e) {

                            //holds every video clip
                            var videoClipDiv = document.createElement("div");
                            
                            //create a preview clip for the new recording
                            var videoElement = document.createElement("video");
                            videoElement.classList.add("videoWindow");
                            videoElement.setAttribute("controls", "");
                            //this has not been added to a comment yet
                            videoElement.classList.add("potentialVideoClip");

                            //create a blob of the video data
                            var blob = new Blob(chunksOfVideoData, {type: "video/webm"});
                            
                            //use a reader to read the blob to turn it into a data url that can be stored in the json file
                            var reader = new FileReader();

                            //function to be called after reading as a data url
                            reader.addEventListener("load", function () {
                                    
                                //add the data url to the collection of video comments
                                globalVideoComments.push(reader.result);

                            }, false);

                            //begin the read process
                            reader.readAsDataURL(blob);

                            //empty out the chunksOfVideoData, they aren't needed anymore for this bit of video
                            chunksOfVideoData = [];
                            
                            //create a data url and set the video control to point to it
                            var videoURL = window.URL.createObjectURL(blob);
                            videoElement.setAttribute("src", videoURL);
                            
                            var deleteButton = document.createElement("button");
                            deleteButton.textContent = "Delete";
                            deleteButton.classList.add("btn");
                            deleteButton.classList.add("btn-default");
                            deleteButton.classList.add("btn-xs");
                            
                            deleteButton.addEventListener("click", function(e) {

                                evtTgt = e.target;
                                
                                //clean up the url object for the deleted video
                                window.URL.revokeObjectURL(evtTgt.parentNode.children[0].getAttribute("src"));
                                
                                //remove the video element
                                evtTgt.parentNode.parentNode.removeChild(evtTgt.parentNode);

                                //clean up the video resources
                                revokePotentialVideoComments();

                                //empty out the collection of videos to add to the next comment
                                globalVideoComments = [];
                            });

                            //add the elements to a div
                            videoClipDiv.appendChild(videoElement);
                            videoClipDiv.appendChild(deleteButton);

                            videoCommentClips = document.querySelector("#videoCommentClips");
                            videoCommentClips.appendChild(videoClipDiv);
                        }

                        mediaRecorder.ondataavailable = function(e) {
                            
                            //add a new chunk of raw video data 
                            chunksOfVideoData.push(e.data);
                        }
                    }

                    //if the media object cannot be configured
                    var onError = function(err) {

                        console.log('The following error occured: ' + err);
                    }
                    
                    //configure the user media object
                    navigator.getUserMedia(constraints, onSuccess, onError);

                } else { //video recording is not supported in this browser

                    //let the user know we can't access the camera
                    makeAnAlert("We were unable to capture video in your browser", "alert-danger", "commentAlertArea");
                }
            }
            
            /*
             * Clean up the media controls for capturing video
             */
            function tearDownVideoRecordingOfComments() {
                
                //get all the 'tracks' from the media stream
                var allMediaStreamTracks = mediaStream.getTracks();
                
                //go through each track and stop it
                for(var i = 0;i < allMediaStreamTracks.length;i++) {
                    allMediaStreamTracks[i].stop();
                }

                //reset the global media stream
                mediaStream = null;

                //reset the global media recorder
                mediaRecorder = null;
            }

            /*
             * Revokes any actual video comments
             */
            function revokeActualVideoComments() {
                
                //get all of the previous actual video comment controls to revoke the object url
                var actualVideoClips = document.querySelectorAll("actualVideoClip");
                
                //go through each one and revoke the object url for it
                for(var i = 0;i < actualVideoClips.length;i++) {

                    var actualVideoClip = actualVideoClips[i];

                    //the browser is holding onto the video object, free it up
                    window.URL.revokeObjectURL(actualVideoClip.getAttribute("src"));
                }
            }

            /*
             * Revokes any potential video comments
             */
            function revokePotentialVideoComments() {
                //get each potential clip video control and revoke the object url
                var potentialVideoClips = document.querySelectorAll("potentialVideoClip");
                
                //go through each one and revoke the object url for it
                for(var i = 0;i < potentialVideoClips.length;i++) {

                    var potentialVideoClip = potentialVideoClips[i];
                    
                    //the browser is holding onto the video object, free it up
                    window.URL.revokeObjectURL(potentialVideoClip.getAttribute("src"));
                }
            }

        </script>
	</body>
</html>