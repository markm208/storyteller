<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->

		<!-- Bootstrap CSS -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

		<!-- Optional theme -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

        <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
		<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
		<!--[if lt IE 9]>
		<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
		<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
		<![endif]-->
        
        <style type="text/css">

            .logo {
                color: green;
                font-weight: bold;
                font-size: 200%;
            }

            /* for code in a playback */
            .codeChar {

            }

            /* to hide code characters that haven't been played yet */
            .codeNotVisible {
                display: none;
            }

            /* to gray out tabs that hold files that are not present */
            .playbackTabNotVisible {
                font-style: italic;
                color: gray;
                background-color: lightgray;
            }

            /* to hide deleted files/dirs */
            .deletedFileOrDirectoryNotVisible {
                display: none;
            }

            /* to highlight code that has been recently deleted */
            .recentDelete {
                color: red;
                text-decoration: line-through;
            }

            /* to highlight code that satisfies all of the filters */
            .relevantCode {
                font-style: normal;
                background-color: #DCF2AD;
                font-weight: bold;
            }

            /* to highlight code that has been recently added */
            .recentInsert {
                color: green;
                font-weight: bold;
                text-decoration: underline;
            }

            /* for a blinking cursor */
            @-webkit-keyframes blinkingCursor { 
                50% { border-right-color: transparent; border-right-width: 2px; border-right-style: solid; } 
            }
            @keyframes blinkingCursor { 
                50% { border-right-color: transparent; border-right-width: 2px; border-right-style: solid; } 
            }

            /* for displaying a cursor in the playback */
            .caretCursor {
                border-right-color: black;
                border-right-width: 2px;
                border-right-style: solid; 
                
                animation: blinkingCursor .60s step-end infinite alternate;
                -webkit-animation: blinkingCursor .60s step-end infinite alternate;
            }

            /* to display the active file/dir in the playback */
            .activeFileOrDirectory {
                font-weight: bold;
                font-style: italic;
            }

            #codeCommentContainer {
                /*width: 50px;*/
                height: 600px;
                overflow-y: scroll;
                overflow-x:hidden;
            }

            .activeComment {
                border-color: green;
            }

            /* to highlight code that is linked to a comment */
            .commentRelevant {
                font-style: normal;
                background-color: greenyellow;
                font-weight: bold;
            }

            /* for comment images */
            .commentImage {

            }

            /* for code comment display (not in the code but off to the side) */
            .codeCommentText {
                /*background-color: greenyellow;*/
                font-weight: bold;
                border-width: 2px; 
            }

            /* timestamp in the comments */
            .codeCommentTimestamp {
                font-style: italic;
                /*display: block;*/
            }

            /* display of images */
            .selectableCommentImageTable {
                display: inline-table;
                margin: 3px;
            }
            
            .table {
                margin-bottom: 0px;
            }
            
            .audio-button-recording {
                color: red;
            }
            
            /* to hide the last span element yet give it some space on the screen */
            .lastSpan {
                visibility: hidden;
            }

            /* current active line in a playback */
            .currentLine {
                font-weight: bold;
                background-color: #EBEBEB;
                font-size: 110%;
            }

            /* the main playback container. It holds a playback window and a line number gutter */
            #playbackWindows {

                overflow: auto; /* for scrolling */
                height:700px;
                white-space: nowrap; /* for horizontal scrolling to prevent wrap */
                font-size: 24px;
                background-color: #C9DBA3;
                font-family: 'Courier New';
            }

            /* for the main code window */
            .playbackWindow {
                font-style: italic;
            }

            /* the div that holds the gutter */
            .lineNumberGutter {
                counter-reset: lineNumCounter; /* set the line num counter to 0 */
                background-color: #DBDBDB; /* color of the gutter */
                float: left;
            }

            /* list of contents of a dir */
            .playbackViewFileOrDirList
            {
                list-style-type: none;
            }

            /* name of a dir */
            .playbackDirNameLabel {
                margin-left: 5px;
            }

            /* for hiding file/dir names in a playback */
            .hiddenFile {
                display: none;
            }
            .hiddenDirectory {
                display: none;
            }

            /* playback info */
            #playbackControlTD {
                width: 30%;
            }
            #eventInfoTD {
                width: 40%;
            }
            #eventDevInfo {
                width: 30%;
            }

            /* a line number in the gutter */
            .lineNum {
                padding-left: 10px;
                padding-right: 10px;
                text-align: right;
            }

            /* increment line numbers */
            .lineNum::before {
                counter-increment: lineNumCounter;
                content: counter(lineNumCounter);
            }

            /* a deleted file */
            .deletedFileOrDirectory {
                color: red;
                font-style: italic;
            }
            
            /* dir icon */
            .dirIcon {
                margin-right: 5px;
            }

            /* list of files/dirs in the filtering menu */
            .fileOrDirListForFiltering
            {
                list-style-type: none;
            }

            /* link to open a tab */
            .fileLink {
                color: black;
            }

            /* for the playback control slider */
            #progressBarContainer {
                margin-top: 3px;
                margin-bottom: 3px;
            }

            /* all divs that hold tabs*/
            .tab-content {
                margin-top:5px
            }

            /* the div that is holding the tab structure */
            #tabContainer {
                margin-top:10px
            }

            /* event time and dev info */
            #timeAndDevEventInfo {
                margin: 5px;
            }

            /* image of a dev */
            .devImage {
                border-style: solid;
                border-width: 2px;
            }

            /* for making the file editor tablist move to the right */
            .nav-rtl {
                padding-left:40px;
                padding-right:0px;
            }
            .nav-rtl li {
                float:right;
            }

            .statistics-td {
                padding-left: 8px;
                padding-right: 8px;
            }


        </style>

		<title>Storyteller- Playback</title>
	</head>

	<body>        
		<!-- bootstrap container -->
		<div class="container-fluid">
			<div id="playbackContainer">
                <div class="logo">
                    Storyteller
                </div>
				<div class="row">     
                    <!-- playback window 75% of screen -->                   
					<div class="col-md-9">

						<!-- tabs for the playback windows -->
						<!-- start with a group of clickable file names -->
						<ul id="playbackWindowTabLinks" class="nav nav-tabs nav-rtl">
                            <!--
							<li class="playbackWindowLinkListItem" id="playbackWindowLinkListItem-fileId">
								<a href="#playbackWindowTab-fileId" data-toggle="tab">file name</a>
							</li>
							-->
						</ul>

                        <!-- next the tabs -->
						<div id="playbackWindows" class="tab-content">

							<!-- All playback window tab ids will look like this "playbackWindowTab-fileId" -->
							<!--
							<div id="playbackWindowTab-fileId" class="playbackWindowTab tab-pane fade in">

								<!-- gutter for line numbers -- >
								<div id="lineNumberGutter-fileId" class="lineNumberGutter">
									<div class='lineNum'></div>
								</div>

								<!-- this is a playback window where code will go -- >
								<div id="playbackWindow-fileId" class="playbackWindow">
									<span id="firstSpan-fileId" class="firstSpan"></span>
									<span id="lastSpan-fileId" class="lastSpan">X</span>
								</div>
							</div>
							-->
						</div>

						<!-- this holds the controls for a code playback -->
						<div id="codeControl">

							<!-- this is where the playback slider (bootstrap progress bar) will go -->
							<div class="progress" id="progressBarContainer"
								 data-toggle="tooltip" data-placement="right"
								 title="Use the left/right arrow keys or click anywhere in the slider to move the playback.">

								<!-- adjustable part of the progress bar -->
								<div class="progress-bar progress-bar-success" role="progressbar" id="playbackProgressBar" style="width:0%"></div>
							</div>

							<!-- this is a table of playback controls and playback info -->
							<div>
								<table class="table table-bordered">
									<tr>
										<th>Playback Control</th>
										<th>Event Info</th>
										<th>Developer Group</th>
									</tr>

									<tr>
                                        <!-- pause/play, step, and filter controls -->
										<td id="playbackControlTD">
											<!-- step backward button -->
											<button id="stepBackwardButton" class="btn btn-default"
													data-toggle="tooltip" data-placement="left" title="Step Backwards (left arrow)">
												<!-- image for the step backward button -->
												<
                                                <!--<span class="glyphicon glyphicon-step-backward"></span>-->
											</button>

											<!-- play/pause button -->
											<button id="playPauseButton" class="btn btn-default btn-lg"
													data-toggle="tooltip" data-placement="bottom" title="Play/Pause (space bar)">
												<!-- image for the play/pause button -->
                                                Play
												<!--<span id="playPausePic" class="glyphicon glyphicon-play"></span>-->
											</button>

											<!-- step forward button -->
											<button id="stepForwardButton" class="btn btn-default"
													data-toggle="tooltip" data-placement="right" title="Step Forwards (right arrow)">
												<!-- image for the step forward button -->
                                                >
                                                <!--<span class="glyphicon glyphicon-step-forward"></span>-->
											</button>

                                            <!-- filter button -->
											<button id="playbackOptionsDropUp" data-toggle="modal" data-target="#filtersModal" class="btn btn-primary btn-lg pull-right">
												Filters 
                                                <!--<span class="glyphicon glyphicon-filter"></span>-->
											</button>

										</td>

                                        <!-- event info -->
										<td id="eventInfoTD">
											<div id="eventTypeDiv"></div>
											<div id="eventInfoDiv"></div >
											<div id="timestampDiv"></div >
										</td>

                                        <!-- developer group info -->
										<td id="eventDevInfo"></td>
									</tr>                                    
								</table>


                                <!-- options link at bottom of page -->
								<div class="text-right">
									<a href="#" data-toggle="modal" data-target="#playbackOptionsModal">Options 
                                        <!--<span class="glyphicon glyphicon-cog"></span>-->
                                    </a>
								</div>
							</div>
						</div>									
					</div>

                    <!-- playback comments 25% of screen -->
					<div class="col-md-3">
						<fieldset>
                            <!-- links for toggling between reading comments and making comments -->
							<legend>Comments</legend>
							<ul class="nav nav-tabs" role="tablist">
								<li id="addNewCommentListItem" class="active"><a href="#addNewCommentTab" data-toggle="tab">Add Comment</a></li>
								<li id="playbackCommentsListItem"><a href="#playbackCommentsTab" data-toggle="tab">Playback Comments</a></li>
							</ul>

							<!-- actual comment tabs -->
							<div class="tab-content">
								<div role="tabpanel" class="tab-pane fade in active" id="addNewCommentTab">
									<fieldset>
                                        <legend>Text for the Comment</legend>                                        
                                        <!-- a place to add comment text -->
                                        <div class="form-group">
                                            <textarea id="textCommentTextArea" class="form-control" rows="10" placeholder="Select some text and add a comment at this point in the playback."></textarea>
                                       </div>
                                    </fieldset>

                                    
                                    <filedset>
                                        <legend>Images for the Comment</legend>

                                        <!-- a place to see all of the comment images for the current comment -->
                                        <div id="commentImagesInComment"></div>

                                        <div class="form-group">
                                            <button type="button" data-toggle="modal" data-target="#editCommentPictureModal" class="btn btn-default">
                                                Add a picture 
                                                <!--<span class="glyphicon glyphicon-picture"></span>-->
                                            </button>
                                        </div>
                                    </filedset>
                                    

                                    <fieldset>
                                        <legend>Audio Comment</legend>
                                        <!-- control to whether to allow audio comments or not -->
                                        <div class="form-group">
                                            <div class="checkbox">
                                                <label>
                                                    <input type="checkbox" id="enableAudioCommentsCheckbox" name="enableAudio" value="0">
                                                    <span>Enable audio comments</span>
                                                </label>
                                            </div>
                                        </div>

                                        <button id="addNewAudioComment" type="button" audioRecording="false" class="btn btn-default" disabled="true">
                                            Start Recording
                                            <!--<span id="audioRecordingStateIcon" class="glyphicon glyphicon-stop"></span>-->
                                            <span id="audioRecordingStateIcon">O</span>
                                        </button>
                                        
                                        <div id="audioCommentClips"></div>
                                    </fieldset>


                                    <!-- submit comment controls -->
									<div class="form-group">
										<button id="addCommentButton" type="button" class="btn btn-primary pull-right">
                                            Add Comment 
                                            <!--<span class="glyphicon glyphicon-comment"></span>-->
                                        </button>
									</div>
								</div>

                                <!-- tab to display comments from a playback -->
								<div role="tabpanel" class="tab-pane fade" id="playbackCommentsTab">
									<div id="codeCommentContainer">
										--
									</div>

                                    <!-- control to pause playbacks at comment points -->
									<div class="form-group">
										<div class="checkbox">
											<label>
												<input type="checkbox" id="pauseForCommentsCheckbox" name="pauseForComments" value="0" checked="checked">
												<span>Pause playback for all comments</span>
											</label>
										</div>
									</div>
								</div>
							</div>
						</fieldset>

                        <!-- the view of the file system at any point in a playback -->
						<fieldset>
							<legend>Current View of the File System</legend>
							
                            <!-- button to save the state of the playback at the current point -->
                            <div class="form-group">
                                <button id="saveStateModalButton" data-toggle="modal" data-target="#saveStateModal" class="btn btn-primary">
                                    Download Files at this Point 
                                    <!--<span class="glyphicon glyphicon-save"></span>-->
                                </button>

                                <!-- merge in a different history to this playback -->
                                <!-- TODO merge!!
                                <label class="btn btn-default btn-file">
                                    Merge <input id="mergeButton" type="file" style="display: none;">
                                </label>
                                -->
                            </div>
                            
                            <!-- display of the files system at the current point in the playback -->
                            <ul id="playbackViewOfFileSystem" class="playbackViewFileOrDirList">
							</ul>

						</fieldset>

                        <!-- show playback statistics up to current point -->
                        <fieldset>
                            <legend>Playback Statistics</legend>

                            <!-- button to bring up the modal with statistics -->
                            <div class="form-group">
                                <button id="statisticsModalButton" data-toggle="modal" data-target="#statisticsModal" class = "btn btn-primary">
                                    View Statistics
                                </button>
                            </div>
                        </fieldset>
					</div>
					<!-- end of nested tabs for the playback windows -->
				</div>
			</div>
		</div>


		<!-- playback modals -->

		<!-- playback options modal -->
        <div id="playbackOptionsModal" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">

                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                        <h3 class="modal-title">Playback Options</h3>
                    </div>

                    <div class="modal-body">
                        <div class="row">
                            <div class="col-sm-2">
                                <h4>Playback Speed</h4>
                                <!-- playback speed control -->
                                <div class="text-left" data-toggle="tooltip" data-placement="left" title="Playback Speed: Use the buttons or the 'shift' + up/down arrow keys to speed up or slow down the playback.">

                                    <!-- increase speed button -->
                                    <button id="playbackSpeedIncreaseButton" class="btn btn-default">
                                        +
                                        <!-- image for increase speed button -->
                                        <!--<span class="glyphicon glyphicon-arrow-down"></span>-->
                                    </button>

                                    <!-- decrease speed button -->
                                    <button id="playbackSpeedDecreaseButton" class="btn btn-default">
                                        -
                                        <!-- image for decrease speed button -->
                                        <!--<span class="glyphicon glyphicon-arrow-up"></span>-->
	                                </button>

                                    <!-- description of the current speed -->
                                    <!--<span id="playbackSpeedDisplay">
                                        <strong>Fast</strong>
                                    </span>-->

                                    <!-- progress bar for the speed -->
                                    <!--<div class="progress" id="speedControlProgressBarContainer" style="height:5px;margin-top:5px">
                                        <div class="progress-bar progress-bar-success" role="progressbar" id="speedControlPlaybackProgressBar" style="width:70%;"></div>
                                    </div>-->
	                            </div>
	                        </div>

	                        <div class="col-sm-2">
	                            <h4>Cut/paste in blocks</h4>
	                            <!-- show all events with the same timestamp in a single block -->
	                            <label for="cutPasteInBlocksCheckbox">
	                                <input type="checkbox" id="cutPasteInBlocksCheckbox" checked="true">
	                                Use blocks
	                            </label>
	                        </div>

	                        <div class="col-sm-2">
	                            <h4>Font size</h4>
                                <!-- control font size -->
                                <!-- decrease font button -->
                                <button id="fontIncreaseButton" class="btn btn-default">
                                    +
                                    <!-- image for decrease font button -->
                                    <!--<span class="glyphicon glyphicon-arrow-down"></span>-->
                                </button>

                                <!-- increase font button -->
                                <button id="fontDecreaseButton" class="btn btn-default">
                                    -
                                    <!-- image for increase font button -->
                                    <!--<span class="glyphicon glyphicon-arrow-up"></span>-->
                                </button>
	                        </div>

                            <div class="col-sm-2">
                                <h4>Save this playback</h4>
                                <!-- save the state of a playback in a json file -->
                                <button id="savePlaybackButton" class="btn btn-default">
                                    Download 
                                    <!--<span class="glyphicon glyphicon-save"></span>-->
                                </button>
                                <!-- link to a json file to download -->
                                <!--<a id="playbackDownloadLink"></a> -->
                            </div>

                            <div class="col-sm-2">
                                <h4>Upload a playback</h4>
                                <!-- load a previously downloaded playback to display -->
                                <input type="file" id="uploadPlaybackButton">
                                Upload 
                                <!--<span class="glyphicon glyphicon-upload"></span>-->
                            </div>

	                    </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <!-- save state modal -->
        <div id="saveStateModal" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">

                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                        <h3 class="modal-title">Save State of Playback</h3>
                    </div>

                    <div class="modal-body">
                        <p>
                            Saving the state of a playback will cause a zip file to be downloaded. You can unzip and open it with a 
                            Storyteller supported editor. This has the contents of the code where the playback was paused so that 
                            you can build from that point in the playback. The file also has some history (code and comments from 
                            the current playback) that will be displayed in future playbacks. 
                        </p>
                        <p>
                            There are three options when saving the state of a playback:
                        </p>
                        
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <div class="radio">
                                    <label>
                                        <input type="radio" name="saveStateRadios" id="saveStateRadioX" value="full" checked>
                                        <span class="panel-title">Full History with Future Events Undone</span>
                                    </label>
                                </div>
                            </div>

                            <div class="panel-body">
                                <p>
                                    With this type of save, <em>all</em> of the history of the playback is recorded in the download, 
                                    even after the point where the playback was paused. However, all events after the pause point are 
                                    undone by adding the inverse of those events. 
                                </p>
                                <p>
                                    For example, if there is a create file followed by three inserts after the point in the playback
                                    where the user paused, then three deletes and a delete file will be added to the list of events 
                                    to roll back the starting state of the new download to the pause point. 
                                </p>
                                <p>
                                    All comments and history are available to see in playbacks from that project but the starting point 
                                    for future development is the pause point in the playback. This is the best option if you want a deep 
                                    history of all the changes in your code.
                                </p>
                            </div>
                        </div>

                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <div class="radio">
                                    <label>
                                        <input type="radio" name="saveStateRadios" id="saveStateRadioX" value="upToPausePoint">
                                        <span class="panel-title">No History Beyond Pause Point</span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="panel-body">
                                <p>
                                    With this type of save, all the code and comments up to the pause point are recorded but none after. In
                                    the download there will be no code or comments past the pause point in the playback. 
                                </p>
                                <p>
                                    This is the best option if you'd like to forget everything after the pause point.
                                </p>
                            </div>
                        </div>

                        
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <div class="radio">
                                    <label>
                                        <input type="radio" name="saveStateRadios" id="saveStateRadioX" value="minimal">
                                        <span class="panel-title">Minimal History</span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="panel-body">
                                <p>
                                    With this type of save, only the code on the screen is added to the download. Any code that was
                                    added and then deleted will not be a part of the download's history.
                                </p>
                                <p>
                                    This is the best option if you'd like to completely forget all the past history except 
                                    for what is on the screen.
                                </p>
                            </div>
                        </div>
                    </div>

                    <div class="modal-footer">
                        <div class="form-group">
                            
                            <button type="button" id="saveStateOfFilesButton" class="btn btn-default" data-dismiss="modal">
                                Save 
                                <!--<span class="glyphicon glyphicon-filter"></span>-->
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- playback filter modal -->
        <div id="filtersModal" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">

                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                        <h3 class="modal-title">Filter Options</h3>
                    </div>

                    <div class="modal-body">
                        <div id="filterOptionsContainer">
                            <!-- links for the filter tabs -->
                            <ul class="nav nav-tabs" role="tablist">
                                <li class="active"><a href="#filterByTimeTab" data-toggle="tab">By Time</a></li>
                                <li><a href="#filterByDevGroupTab" data-toggle="tab">By Developer Group</a></li>
                                <li><a href="#filterByFileTab" data-toggle="tab">By File</a></li>
                                <li><a href="#filterBySelectedTextTab" data-toggle="tab">By Selected Text</a></li>
                            </ul>

                            <!-- filter tab panes -->
                            <div class="tab-content">
                                <!-- by time -->
                                <div class="tab-pane active" id="filterByTimeTab">
                                    <div>
                                        <div class="form-group">
                                            <label for="startTimeInput" >Start time: </label>
                                            <div class="input-group">
                                                <input type="text" class="form-control" id="startTimeInput" placeholder="MM/DD/YYYY HH:MM::SS"/>
                                                <span class="input-group-btn">
                                                    <button type="button" id="useCurrentEventStartTimeButton" class="btn btn-default">
                                                        Use the current event's time
                                                    </button>
                                                </span>
                                            </div>
                                        
                                            <label for="endTimeInput" >End time: </label>
                                            <div class="input-group">
                                                <input type="text" class="form-control" id="endTimeInput" placeholder="MM/DD/YYYY HH:MM::SS"/>
                                                <span class="input-group-btn">
                                                    <button type="button" id="useCurrentEventEndTimeButton" class="btn btn-default">
                                                        Use the current event's time
                                                    </button>
                                                </span>
                                            </div>
                                            <br/>
                                            <button type="button" id="addTimeFilterButton" class="btn btn-default">
                                                Add a time span to the filter 
                                                <!--<span class="glyphicon glyphicon-time"></span>-->
                                            </button>
                                            
                                        </div>
                                    </div>

                                    <div>                                        
                                        <table id="userSelectedTimeSpans" class="table table-striped table-condensed table-hover"> 
                                            <caption>Selected filters</caption>
                                            <tr>
                                                <th>&nbsp;</th>
                                                <th>Start Time</th>
                                                <th>End Time</th>
                                            </tr>                                            
                                        </table>
                                    </div>
                                </div>

                                <!-- by dev group -->
                                <div class="tab-pane" id="filterByDevGroupTab">
                                    <div id="devGroupFilter"></div>
                                </div>

                                <!-- by file -->
                                <div class="tab-pane" id="filterByFileTab">
                                    <div class="form-group">
                                        <!-- list of all files/dirs in the system even deleted ones -->
                                        <ul id="viewOfFileSystemForFiltering" class="fileOrDirListForFiltering"></ul>

                                        <!-- controls to show or hide deleted files/dirs-->
                                        <input type="checkbox" name="hideDeletedDirsCheckbox" id="hideDeletedDirsCheckbox">
                                        <label for="hideDeletedDirsCheckbox">Hide deleted files and directories</label>
                                    </div>
                                </div>

                                <!-- by selected text -->                                
                                <div class="tab-pane" id="filterBySelectedTextTab">
                                    <div class="form-group">
                                        <p>
                                            The selected text on the screen will be played back.
                                        </p>
                                        <!-- choose the text that is selected on the screen -->
                                        <button type="button" id="selectedTextButton" class="btn btn-default" data-dismiss="modal">
                                            Selected Text Playback 
                                            <!--<span class="glyphicon glyphicon-blackboard"></span>-->
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="modal-footer">
                        <div class="form-group">
                            <!-- clear all filters -->
                            <button type="button" id="clearFilterButton" class="btn btn-default" data-dismiss="modal">
                                Clear All Filters 
                                <!--<span class="glyphicon glyphicon-remove"></span>-->
                            </button>

                            <button type="button" id="filterButton" class="btn btn-default" data-dismiss="modal">
                                Filter 
                                <!--<span class="glyphicon glyphicon-filter"></span>-->
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- playback comment picture modal -->
        <div id="editCommentPictureModal" class="modal fade" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">

                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                        <h3 class="modal-title">Add an image</h3>
                    </div>

                    <div class="modal-body">
                        <!-- the drawing canvas -->
                        <canvas id="commentCanvas" class="img-thumbnail" height="675" width="860">
                        </canvas>

                        <!-- a collection of previous images to start a new image from -->
                        <div id="commentImageStartingPointGallery">
                            <!--<span class="glyphicon glyphicon-picture"></span>-->
                            <input type="file" id="importImageButton">
                        </div>

                    </div>

                    <div class="modal-footer">
                        <div class="form-group">
                            <!-- clear the image and create a blank slate -->
                            <button type="button" id="clearCommentImageButton" class="btn btn-default">
                                Clear Image 
                                <!--<span class="glyphicon glyphicon-remove"></span>-->
                            </button>

                            <!-- save the image -->
                            <button type="button" id="saveCommentImageButton" class="btn btn-default" data-dismiss="modal">
                                Use this Image 
                                <!--<span class="glyphicon glyphicon-floppy-disk"></span>-->
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- playback comment picture modal for displaying comments -->
        <div id="commentPictureDisplayModal" class="modal fade" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">

                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                        <h3 class="modal-title">Comment Image</h3>
                    </div>

                    <div class="modal-body">
                        <!-- the image will go here-->
                        <img id="largeImageDisplay" class="img-thumbnail" height="675" width="820" alt="Comment Image">

                        <!-- a repeat of the comment text will go here -->
                        <div id="commentTextInLargeDisplay">
                        </div>
                    </div>

                    <div class="modal-footer">
                        <button type="button" class="btn btn-default" data-dismiss="modal">
                            Close
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- modal for showing playback statistics -->
        <div id="statisticsModal" class="modal fade" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <!-- header goes here -->
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                        <h3 class="modal-title">Playback Statistics</h3>
                    </div>

                    <!-- important contents go here -->
                    <div class="modal-body" id="statisticsModalBody">
                        <!-- statistics go here -->
                    </div>

                    <!-- extra close button -->
                    <div class="modal-footer">
                        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        </div>
		
        <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
        <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>

        <!-- Latest compiled and minified JavaScript -->
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

        <!-- md5 -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.3.1/js/md5.min.js"></script>
        
        <!-- zip -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.3/jszip.min.js"></script>

        <script>
  
            /*
             * This data structure holds information necessary for a playback.
             */
            var playbackData = {
                codeEvents: [],						//holds all of the events to be played back
                codeEventsIndex: -1,				//holds the index of the 'current' event during playback
                mostRecentDirection: "forward",		//holds the direction of the latest animated event
                numberOfRelevantEvents: 0,			//holds the number of events that are marked as relevant
                relevantEventIndex: 0,				//the index of the most recent relevant event
                playbackState: "paused",			//state of the playback (playing/paused)
                playbackTimerId: null,				//id of the timer used to control animating events
                activeFileId: null,					//the latest active file id in the playback
                activeLineNumber: null,				//the latest active line number in the playback
                allDevelopers: null,				//an object of all of the developers (each dev id is a key)
                allDeveloperGroups: null,			//an array of all of the developer groups
                currentDevGroupId: null,			//the id of the dev group that will be used to create new comments and events
                latestPlaybackEventDevGroupId: null,//the id of the last dev group to make a relevant contribution during playback 
                allFiles: null,             		//an object with info about all the files ever created in the system 
                allDirs: null,              		//an object with info about all of the directories ever created in the system 
                delay: 150,							//delay in between playback events in ms
                highlightDelay: 300,    			//amount of time a new element will be highlighted on insert/delete
                showPastesInABlock: true,			//show any pasted code as a single big block of text
                comments: {},						//an object that will hold event ids as a key and groups of comments to display at the event
                pauseForComments: true          	//indicates whether playback should be paused if there is a comment
            };
            //when adding to this make sure to update getPlaybackWindowsReadyForAnimation()

            /*
             * This object holds info about the canvas that is used to draw on when making comments
             */
            var canvasData = {
                commentCanvas: null,				//the canvas to draw on
                commentCanvasContext: null,			//the context used to do the drawing
                currentMousePosition: {x: 0, y: 0},	//current mouse position on the canvas
                previousMousePosition: {x: 0, y: 0}	//previous mouse position on the canvas
            };

            /*
             * This object holds info about the different images that have been created
             */
            var images = {
                prependId: "img_",
                sequenceNumber: 0
            };

            /*
             * For audio recording comments
             */
            var audioComments = [];

            //timer for UI blinking when recording
            var audioRecordBlinkTimer;

            /*
             *  This object holds statistics for events up to the current playback point
             */
            var statisticsData = {
                numInserts: 0,              //number of insert events
                numDeletes: 0,              //number of delete events
                numFileDirEvents: 0,        //number of file and directory events
                eventsByDevGroup: [],       //holds objects for each dev group that's contributed, giving number of inserts, deletes, and total events for each
                lastDevGroupId: "none",     //the dev group responsible for the most recent event
                lastDevGroupIndex: -1,      //most recently used index of eventsByDevGroup
                modifiedFiles: [],          //files we've seen changes in during this playback
            };

            //*****************************************************************************
            //                         Page setup related code
            //                         -----------------------
            // This code has to do with setting up the page to be ready to playback code. 
            // It mostly involves setting up the UI to respond to events. Most of what the 
            // listeners do is right in the anonymous functions.
            //*****************************************************************************
            /*
             * Set up the event handlers for all of the controls on the page. Set up the drawing canvas
             * for comment pictures. Load the playback data to make it ready to animate.
             */
            document.addEventListener("DOMContentLoaded", function(event) {

                //set up the UI event handlers
                setUpUIEventHandlers();

                //set up the drawing canvas
                setUpDrawingCanvas();

                //jquery and bootstrap tab related code
                //for tooltips- can remove if move away from bootstrap
                //the tooltips won't show until a hover that lasts 1000 ms and will go away
                //after 200 ms hover out
                $('[data-toggle="tooltip"]').tooltip({delay: {show: 1000, hide: 200}});

                //construct the playback object. There is a bit of magic here, loadPlaybackData() is added 
                //to this file dynamically by the playback web server and it includes all of the events,
                //dev info, commments, etc.                
                loadPlaybackData();
            });

			/*
			 * This function is called by the playback code to get code events and developer info used
			 * for playback. This is one of the only direct dependencies between the playback code and 
			 * this editor. Before a playback begins the playback code will always call a function called
			 * loadPlaybackData to attempt to load data in from an editor (if the playback gets its data
			 * from somewhere else then there won't be an implementation for loadPlaybackData and nothing
			 * will be called).
			 *
			 * If we move away from using an editor and playback in the same page this can be removed
			 * but there has to be another way for the playback data to be filled in (perhaps from a file,
			 * local storage, or from a textbox)
			 */            
            function loadPlaybackData() {} //!!! string replacement of function here !!!
            
            /*
             * This function registers the UI listeners for
             * - step forward/backward buttons
             * - play/pause button
             * - playback progress slider
             * - playback speed controls
             * - font increase/decrease buttons
             * - keyboard shortcuts
             * --- left arrow: go back a step
             * --- right arrow: go forward a step
             * --- up arrow: speed up the playback
             * --- down arrow: slow down the playback
             * --- space bar: toggle the playback state
             * - cut/paste in blocks checkbox
             * - pause for comments checkbox
             * - filter setup
             * --- hide deleted files/dirs
             * --- gather filter info
             * --- selected text filter
             * --- clear all filters
             * - add comments
             * - comment image
             * --- save image
             * --- clear image
             * --- import image
             * - save state of file system
             * - save playback in json file
             * - load saved playback
             */
            function setUpUIEventHandlers() { 

                //TODO make each one of these a separate non-anonymous function

                //single step backwards button
                document.querySelector("#stepBackwardButton").addEventListener("click", function(e) {

                    //stop the playback
                    pausePlayback();

                    //move backward one element
                    step("backward", 1);
                });

                //toggle play/pause
                document.querySelector("#playPauseButton").addEventListener("click", function(e) {

                    //handle the click of the play/pause button
                    togglePlayPause();
                });

                //single step forwards button
                document.querySelector("#stepForwardButton").addEventListener("click", function(e) {

                    //stop the playback
                    pausePlayback();

                    //move forward one element
                    step("forward", 1);
                });

                //event slider
                document.querySelector("#progressBarContainer").addEventListener("click", function(e) {

                    //this is somewhat dependent on bootstrap. If we ever get rid of bootstrap
                    //in favor of pure js/html we can use an html5 range as a slider or roll our own

                    //the offset from the beginning of the progress bar (in pixels) when
                    //the progress bar click happened
                    var offsetXFromBeginningOfProgressBar;

                    //older versions of firefox don't support offsetX so this is a work around

                    //if there is an offsetX in the click event (chrome and all other browsers except ff)
                    if(e.offsetX) {

                        //offsetX is the offset in pixels from the beginning of the progress bar
                        offsetXFromBeginningOfProgressBar = e.offsetX;

                    } else { //older versions of firefox don't have offsetX, they have e.layerX

                        //get the equivalent in firefox
                        offsetXFromBeginningOfProgressBar = e.layerX;
                    }

                    //e.target.parentNode.offsetWidth is the width of the entire progress bar (in pixels)
                    //calculate the percentage where the click happened in the progress bar
                    var percentPositionOfClick = offsetXFromBeginningOfProgressBar / e.target.parentNode.offsetWidth;

                    //choose a code event index based on the percent position in the progress bar
                    var clickedEventIndex = Math.round(percentPositionOfClick * playbackData.numberOfRelevantEvents);
                    
                    //stop playback
                    pausePlayback();
                    
                    //if the clicked event index is before the current position
                    if(clickedEventIndex < playbackData.relevantEventIndex) {

                        //move backwards to the click point
                        step("backward", playbackData.relevantEventIndex - clickedEventIndex);

                    } else if (clickedEventIndex > playbackData.relevantEventIndex) { //clicked after the current position

                        //move forwards to the click point
                        step("forward", clickedEventIndex - playbackData.relevantEventIndex);
                    }
                    //else- it is equal and the code does not have to move

                });

                //playback speed increase button
                document.querySelector("#playbackSpeedIncreaseButton").addEventListener("click", function(e) {

                    //increase the delay in between playing back events (function takes a delta)
                    changeSpeed(-25);
                });

                //playback speed decrease button
                document.querySelector("#playbackSpeedDecreaseButton").addEventListener("click", function(e) {

                    //decrease the delay in between playing back events (function takes a delta)
                    changeSpeed(25);
                });

                //font increase button
                document.querySelector("#fontIncreaseButton").addEventListener("click", function(e) {

                    //increase the font of the playback windows and the gutters
                    //get all the playback windows
                    var playbackWindows = document.querySelector("#playbackWindows");

                    //if there is a defined font size
                    if(playbackWindows.style.fontSize) {

                        //get the old size by stripping off the 'px' at the end
                        var oldSizeInPx = parseInt(playbackWindows.style.fontSize.slice(0, playbackWindows.style.fontSize.length - 2));

                        //add 2 points to the size
                        oldSizeInPx = oldSizeInPx + 2;

                        //set the font size
                        playbackWindows.style.fontSize = oldSizeInPx + "px";

                    } else { //no defined font size

                        //default is 24 so make it 2 points bigger
                        playbackWindows.style.fontSize = "26px";
                    }
                });

                //font decrease button
                document.querySelector("#fontDecreaseButton").addEventListener("click", function(e) {

                    //decrease the font of the playback windows and the gutters
                    var playbackWindows = document.querySelector("#playbackWindows");

                    //if there is a defined font size
                    if(playbackWindows.style.fontSize) {

                        //get the old size by stripping off the 'px' at the end
                        var oldSizeInPx = parseInt(playbackWindows.style.fontSize.slice(0, playbackWindows.style.fontSize.length - 2));

                        //deduct 2 points to the size
                        oldSizeInPx = oldSizeInPx - 2;

                        //set the font size
                        playbackWindows.style.fontSize = oldSizeInPx + "px";

                    } else { //no defined font size

                        //default is 24 so make it 2 points smaller
                        playbackWindows.style.fontSize = "22px";
                    }
                });

                //keyboard shortcuts
                document.addEventListener("keydown", function (e) {

                    //left arrow, right arrow, up arrow, down arrow, and space bar control
                    //the playing of events

                    if(e.keyCode === 37){ //left

                        //if the left arrow happened in the comment text area
                        if(e.target.getAttribute("id") === "textCommentTextArea") {

                            //don't let it move the playback backwards
                            e.stopImmediatePropagation();

                        } else { //left arrow happened outside of the comment text area

                            //pause the playback
                            pausePlayback();

                            //move back one step
                            step("backward", 1);
                        }

                    } else if(e.keyCode === 39){ //right

                        //if the right arrow happened in the comment text area
                        if(e.target.getAttribute("id") === "textCommentTextArea") {

                            //don't let it move the playback forwards
                            e.stopImmediatePropagation();

                        } else { //right arrow happened outside of the comment text area

                            //pause the playback
                            pausePlayback();

                            //move forward one step
                            step("forward", 1);
                        }

                    } else if(e.keyCode === 38 && e.shiftKey){ //shift + up

                        //decrease the delay in between playing back events, increases playback speed (function takes a delta)
                        changeSpeed(-25);

                    } else if(e.keyCode === 40 && e.shiftKey){ //shift + down

                        //increase the delay in between playing back events, decreases playback speed (function takes a delta)
                        changeSpeed(25);

                    } else if(e.keyCode === 32){ //space bar

                        //if the space bar happened in the comment text area
                        if(e.target.getAttribute("id") === "textCommentTextArea") {

                            //don't let it start playback
                            e.stopImmediatePropagation();

                            //console.log("blocking space bar in comment");

                        } else { //space bar outside of the text area

                            //toggle playing and pausing
                            togglePlayPause();
                        }
                    }
                });

                //indicates whether the user wants to see all cuts and pastes in blocks
                document.querySelector("#cutPasteInBlocksCheckbox").addEventListener("click", function(e) {

                    //store the user's choice about whether to see all cuts/pastes in blocks
                    playbackData.showPastesInABlock = e.target.checked;
                });

                //indicates whether the user wants to have playback pause whenever there is a comment
                document.querySelector("#pauseForCommentsCheckbox").addEventListener("click", function(e) {

                    //store the user's choice about whether to pause for comments
                    playbackData.pauseForComments = e.target.checked;
                });

                //indicates whether deleted files/dirs should be hidden in the file filter options
                document.querySelector("#hideDeletedDirsCheckbox").addEventListener("click", function(e) {

                    //get all of the deleted files and directory checkboxes
                    var allDeletedFileAndDirectoryCheckBoxes = document.querySelectorAll(".deletedFileOrDirectory");

                    //if the user wants to hide them
                    if(e.target.checked === true) {

                        //go through all of them
                        for(var i = 0;i < allDeletedFileAndDirectoryCheckBoxes.length;i++){

                            //hide by adding a class that makes them display: none
                            allDeletedFileAndDirectoryCheckBoxes[i].classList.add("deletedFileOrDirectoryNotVisible");
                        }

                    } else { //the user want to see the deleted files and directories

                        //go through them all
                        for(var i = 0;i < allDeletedFileAndDirectoryCheckBoxes.length;i++){

                            //show them by removing the class that hides them
                            allDeletedFileAndDirectoryCheckBoxes[i].classList.remove("deletedFileOrDirectoryNotVisible");
                        }
                    }
                });

                //wire the button to use the current event's timestamp as a start time
                document.querySelector("#useCurrentEventStartTimeButton").addEventListener("click", function(e) {

                    //if there are any events in the playback
                    if(playbackData.codeEvents.length > 0) {

                        var currEvent;

                        //if the playback has been started
                        if(playbackData.codeEventsIndex >= 0) {

                            //get the current event
                            currEvent = playbackData.codeEvents[playbackData.codeEventsIndex];

                        } else { //no movement in the playback

                            //use the first event
                            currEvent = playbackData.codeEvents[0];                        
                        }

                        //get the time from the event and display it
                        document.querySelector("#startTimeInput").value = formatDateShortWithDayOfWeek(new Date(currEvent.timestamp));
                    }                    
                });

                //wire the button to use the current event's timestamp as an end time
                document.querySelector("#useCurrentEventEndTimeButton").addEventListener("click", function(e) {

                    //if there are any events in the playback
                    if(playbackData.codeEvents.length > 0) {

                        var currEvent;

                        //if the playback has been started
                        if(playbackData.codeEventsIndex >= 0) {

                            //get the current event
                            currEvent = playbackData.codeEvents[playbackData.codeEventsIndex];

                        } else { //no movement in the playback

                            //use the first event
                            currEvent = playbackData.codeEvents[0];                        
                        }

                        //get the time from the event and display it
                        document.querySelector("#endTimeInput").value = formatDateShortWithDayOfWeek(new Date(currEvent.timestamp));
                    }                    
                });

                //add a time span to the group of time spans
                document.querySelector("#addTimeFilterButton").addEventListener("click", function(e) {
            
                    //get the times from the text boxes 
                    var startTime = new Date(document.querySelector("#startTimeInput").value);
                    var endTime = new Date(document.querySelector("#endTimeInput").value);

                    //if the dates are incorrect
                    if(startTime === NaN) {
                        console.log("Error with the start time");

                        //use a start date a long time in the past
                        startTime = new Date(0);
                    }

                    if(endTime === NaN) {
                        console.log("Error with the end time");

                        //use right now as the end date
                        endTime = new Date();
                    }

                    //add a row to the table that lists all of the selected timeframes
                    addFilteredTimeFrame(startTime, endTime);
                });

                //collect the user's filter info and start filtering
                document.querySelector("#filterButton").addEventListener("click", function(e) {

                    //these are the filter parameters
                    var timeFilters = [];
                    var devGroupFilter = null;
                    var fileDirFilter = null;

                    //time filtering
                    //get all the rows from the table with selected time frames
                    var filterTimeFrames = document.querySelectorAll(".filterTimeframe");
                    
                    //go through each selected time frame
                    for(var i = 0;i < filterTimeFrames.length;i++) {
                        
                        //get time from the table (pos 0 is a delete button, 1 is the start time, 2 is the end time)
                        var startTime = filterTimeFrames[i].children[1];
                        var endTime = filterTimeFrames[i].children[2];

                        //convert the strings to epoch vals
                        var epochStartTime = Date.parse(startTime.innerHTML);
                        var epochEndTime = Date.parse(endTime.innerHTML);
                        
                        //bump up the end time to get the last ms in the selected time's second value
                        epochEndTime = epochEndTime + (999 - (epochEndTime % 1000));

                        //create a time filter object that holds the requested start and end time
                        var timeFilter = {
                            startTimestamp: epochStartTime,
                            endTimestamp: epochEndTime
                        };

                        //add each time filter to the collection
                        timeFilters.push(timeFilter);
                    }


                    //developer filtering
                    //get all of the selected dev group checkboxes
                    var allSelectedDevGroupCheckboxes = document.querySelectorAll(".devGroupSelectCheckbox:checked");

                    //holds the values of the selected dev group checkboxes
                    var selectedDevGroupIds = [];

                    //go through the checkboxes
                    for(var i = 0;i < allSelectedDevGroupCheckboxes.length;i++) {

                        //get the developer group id from the value of the checkbox and store it
                        selectedDevGroupIds.push(allSelectedDevGroupCheckboxes[i].value);
                    }

                    //if there were some dev groups selected
                    if(selectedDevGroupIds.length > 0) {

                        //create an object with all of the selected dev group ids
                        devGroupFilter = {
                            devGroupIds: selectedDevGroupIds
                        };
                    }


                    //file filtering
                    //get all of the selected file and dir checkboxes and add the file ids to the filter object
                    var allSelectedFilesAndDirCheckboxes = document.querySelectorAll(".filterCheckBox:checked");

                    //holds the values of the selected file/dir checkboxes
                    var selectedFileAndDirIds = [];

                    //go through the checkboxes
                    for(var i = 0;i < allSelectedFilesAndDirCheckboxes.length;i++) {

                        //get the file/dir id from the value of the checkbox and store it
                        selectedFileAndDirIds.push(allSelectedFilesAndDirCheckboxes[i].value);
                    }

                    //if there were some files/dirs selected
                    if(selectedFileAndDirIds.length > 0) {

                        //create an object with all of the selected file/dir ids
                        fileDirFilter = {
                            fileDirIds: selectedFileAndDirIds
                        };
                    }

                    //selected text filtering is somewhat different, it is handled in its own event handler
                    

                    //reset the window for a new playback
                    getPlaybackWindowsReadyForAnimation(false);

                    //filter the playback data to mark some of the code as relevant
                    filterPlayback(timeFilters, devGroupFilter, fileDirFilter);
                });

                //used to turn this back into an unfiltered playback
                document.querySelector("#clearFilterButton").addEventListener("click", function(e) {

                    //reset the entire playback
                    getPlaybackWindowsReadyForAnimation(true);
                    clearStatisticsData();
                });

                //for a selected text playback
                document.querySelector("#selectedTextButton").addEventListener("click", function(e) {

                    //filter by selected text
                    selectedTextFilter();
                });

                //clear the drawing canvas
                document.querySelector("#clearCommentImageButton").addEventListener("click", function(e) {

                    //clear the drawing canvas
                    canvasData.commentCanvasContext.clearRect(0, 0, canvasData.commentCanvas.width, canvasData.commentCanvas.height);
                });

                //use the drawing in a comment and save it to build on later
                document.querySelector("#saveCommentImageButton").addEventListener("click", function(e) {

                    //turn the canvas into a data url
                    var dataURL = canvasData.commentCanvas.toDataURL("image/png", 1.0);

                    //generate a unique image id
                    var imgId = images.prependId + images.sequenceNumber
                    images.sequenceNumber++;

                    //store the data url in a global image repo
                    images[imgId] = dataURL;

                    //add the image to the collection that shows images that will be added to the comment
                    //get the collection of images that will be added to the comment
                    var commentImagesInComment = document.querySelector("#commentImagesInComment");

                    //get an image element with a scaled down picture of the image
                    var previewImg = getCommentImagePreview(80, 80, dataURL);

                    //create a small image preview of what is in the canvas
                    var commentImagePreview = getSelectableCommentImagePreview(previewImg, imgId, "selectedCommentImage");

                    //append a preview of the comment image
                    commentImagesInComment.appendChild(commentImagePreview);


                    //add the image to the collection of images to build off of
                    //get the gallery of images to build off of
                    var commentImageStartingPointGallery = document.querySelector("#commentImageStartingPointGallery");

                    //create a small image
                    var commentImageStartingPointImage = getCommentImagePreview(60, 60, dataURL);

                    //make a link that points to nothing
                    var commentImageStartingPointLink = document.createElement("a");
                    commentImageStartingPointLink.setAttribute("href", "#");

                    //put the image in the link
                    commentImageStartingPointLink.appendChild(commentImageStartingPointImage);

                    //when the user clicks on this link
                    commentImageStartingPointLink.addEventListener("click", function(e){

                        //clear the drawing canvas
                        canvasData.commentCanvasContext.clearRect(0, 0, canvasData.commentCanvas.width, canvasData.commentCanvas.height);

                        //redraw the image from the link on to the canvas
                        canvasData.commentCanvasContext.drawImage(commentImageStartingPointImage, 0, 0);
                    });

                    //add the image to the gallery
                    commentImageStartingPointGallery.appendChild(commentImageStartingPointLink);
                });

                //import an image onto the comment drawing canvas
                document.querySelector("#importImageButton").addEventListener("change", function(e) {

                    //get the selected file from the file input control
                    var imageFile = this.files[0];

                    //create a reader to read the data
                    var fileReader = new FileReader();

                    //once the data is done being read
                    fileReader.onload = function(data) {

                        //create an image
                        var img = new Image();

                        //when the image is finally loaded
                        img.onload = function() {

                            //clear the drawing canvas
                            canvasData.commentCanvasContext.clearRect(0, 0, canvasData.commentCanvas.width, canvasData.commentCanvas.height);

                            //draw a scaled image onto the canvas
                            canvasData.commentCanvasContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvasData.commentCanvas.width, canvasData.commentCanvas.height);
                        }

                        //load the image with the image file selected
                        img.src = data.target.result;
                    };

                    //begin the read operation to read the selected image file
                    fileReader.readAsDataURL(imageFile);
                });

                //to get a zip with the state of the file system
                document.querySelector("#saveStateOfFilesButton").addEventListener("click", function(e) {

                    //pause the playback if it is not already paused
                    pausePlayback();
                    
                    //if there are any events that have been played on the screen
                    if(playbackData.codeEventsIndex >= 0) {
                    
                        //get the type of playback
                        var typeOfSave = document.querySelector("input[name='saveStateRadios']:checked").value;

                        //the playback is paused at a single event. Save the state of the files/dirs, the playbackData.json, 
                        //and editorState.json files at this point in a zip file. A user can unzip and open the root dir
                        //and begin from the pause point. There are three different types of saved files 
                        saveStateOfPlaybackAtPausePoint(typeOfSave);

                    } else {

                        //TODO notify user there is nothing to zip
                        console.log("Nothing to zip up");
                    }
                });

                // //merge with another playbackData file
                // document.querySelector("#mergeButton").addEventListener("change", function(e) {

                //     //pause the playback if it is not already paused
                //     pausePlayback();

                //     //get the file from the file input
                //     var uploadedFile = this.files[0];

                //     //create a reader to read the data
                //     var fileReader = new FileReader();

                //     //once the data is done being read
                //     fileReader.onload = function(data){

                //         //get the events in the playback up to the pause point
                //         var playbackDataEventsBranch1 = playbackData.codeEvents.slice(0, playbackData.codeEventsIndex + 1);

                //         //get the selected playback.json file
                //         var playbackDataBranch2 = JSON.parse(data.target.result);
                        
                //         //get the code events from it
                //         var playbackDataEventsBranch2 = playbackDataBranch2.codeEvents;

                //         //TODO end the entire data structure, playbackDataBranch2, to merge not just events to merge in comments as well

                //         //begin the merge process 
                //         merge(playbackDataEventsBranch1, playbackDataEventsBranch2);
                //     };

                //     //begin the read operation (as text)
                //     fileReader.readAsText(uploadedFile);
                    
                // });
                
                //to add a comment
                document.querySelector("#addCommentButton").addEventListener("click", function(e) {

                    //if the playback is paused, we can make a comment
                    if(playbackData.playbackState === "paused") {

                        //get the text area
                        var textCommentTextArea = document.querySelector("#textCommentTextArea");

                        //get the comment text
                        var commentText = textCommentTextArea.value.trim();

                        //get any selected text ids if there are any
                        var selectedCodeIds = getSelectedCodeIds(false);

                        //an array of images to go along with this comment
                        var commentImages = [];

                        //get the selected comment images
                        var selectedImageCheckBoxes = document.querySelectorAll(".selectedCommentImage:checked");
                        for(var i = 0;i < selectedImageCheckBoxes.length;i++) {

                            //get the image id from the checkbox
                            var imgId = selectedImageCheckBoxes[i].getAttribute("value");

                            //use the image id to retrieve the data url of the image
                            commentImages.push(images[imgId]);
                        }
                        
                        //if there was a comment, some selected text, at least one image, or one audio comment
                        if(commentText.length > 0 || selectedCodeIds.length > 0 || 
                           commentImagesInComment.children.length > 0 || audioComments.length > 0) {

                            //clear out the text area
                            textCommentTextArea.value = "";

                            //get each potential clip audio control and revoke the object url
                            revokePotentialAudioComments()

                            //clear out the actual audio control elements
                            audioCommentClips = document.querySelector("#audioCommentClips");
                            audioCommentClips.innerHTML = "";

                            //playbackData.codeEventsIndex starts at -1 and is incremented every step forward
                            //this ? is to account for comments before any events are played back
                            var eventIndex = playbackData.codeEventsIndex >= 0 ? playbackData.codeEventsIndex : 0

                            //if we are moving backwards move the event index forward to account for the
                            if(playbackData.mostRecentDirection === "backward" && eventIndex > 0) {
                                eventIndex--;
                            }

                            //get the event to playback this comment
                            var commentEvent = playbackData.codeEvents[eventIndex];

                            //create an object that has all of the comment info
                            var comment = {
                                displayCommentEvent: commentEvent,
                                developerGroupId: playbackData.currentDevGroupId, 
                                timestamp: new Date().getTime(),
                                commentText: commentText,
                                selectedCodeIds: selectedCodeIds,
                                images: commentImages,
                                audioComments: audioComments
                            };

                            //clear out the reference to the audio clips to get ready for the next comment
                            audioComments = [];

                            //if there is not an array to hold comments on this event
                            if(!playbackData.comments[commentEvent.id]) {

                                //create an empty array to hold comments keyed by the comment event
                                playbackData.comments[commentEvent.id] = [];
                            }

                            //add the comment to the array of comments for this particular event
                            playbackData.comments[commentEvent.id].push(comment);


                            //send the comment to the server
                            var xmlhttp = new XMLHttpRequest();   
                            xmlhttp.addEventListener("load", function(){

                                //TODO add a message to the UI indicating that the message was received and saved
                                console.log("successfully added a comment and receieved a response");
                            });

                            xmlhttp.addEventListener("error", function(){

                                //TODO add a message to the UI indicating that there is no server to respond
                                console.log("was not able to add a comment");
                            });

                            //send the comment to the server
                            xmlhttp.open("POST", "/comment");
                            xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                            xmlhttp.send(JSON.stringify(comment));

                            //clear the images in comment
                            commentImagesInComment.innerHTML = "";
                        }
                        //else- no text or selected code, we can't make a comment
                    }
                    //else- playback is playing, can't comment while the playback is moving
                });

                document.querySelector("#enableAudioCommentsCheckbox").addEventListener("click", function(e) { 
                    
                    //get the audio button
                    var addNewAudioComment = document.querySelector("#addNewAudioComment");

                    //if audio comments are enabled
                    if(e.target.checked) {

                        //if the user chooses to enable audio comments, set up the media recorder
                        setUpAudioRecordingOfComments();

                        addNewAudioComment.disabled = false
                        e.target.disabled = true;

                    } else {

                        addNewAudioComment.disabled = true;
                    }
                });
                
                //save a playback
                document.querySelector("#savePlaybackButton").addEventListener("click", function(e) {

                    //all code events that are stored to disk should be compressed first

                    //store a pointer to the uncompressed events
                    var uncompressedCodeEvents = playbackData.codeEvents;

                    //replace the uncompressed events with compressed ones
                    playbackData.codeEvents = compressEvents(playbackData.codeEvents);

                    //create a blob with the playback data in it in json
                    var blob = new Blob([JSON.stringify(playbackData, null, 2)], {type : 'application/json'});

                    //put the uncompressed events back in the playbackData (events are compressed only when stored on disk, in memory they are fully decompressed)
                    playbackData.codeEvents = uncompressedCodeEvents;

                    //make a data url out of the blob (this is a downloadable piece of data from a link)
                    var dataURL = window.URL.createObjectURL(blob);

                    //create a temp, invisible anchor and add it to the page
                    var a = document.createElement("a");
                    document.body.appendChild(a);
                    a.style = "display: none";

                    //assign the new with zip data url to the anchor
                    a.href = dataURL;

                    //add a name to the zip
                    a.download = "playback.json";

                    //simulate a click of the button
                    a.click();

                    //clean up the resources for the url
                    window.URL.revokeObjectURL(dataURL);
                    
                    //remove the anchor
                    a.remove();
                });

                //upload a playback from a previously downloaded json file
                document.querySelector("#uploadPlaybackButton").addEventListener("change", function(e) {

                    //get the file from the file input
                    var uploadedFile = this.files[0];

                    //create a reader to read the data
                    var fileReader = new FileReader();

                    //once the data is done being read
                    fileReader.onload = function(data){

                        //get the text of the file and turn it into json                        
                        //store the playback data from the file
                        playbackData = JSON.parse(data.target.result);

                        //all events stored on disk are compressed, decompress  them for use in memory
                        //decompress the events
                        playbackData.codeEvents = decompressEvents(playbackData.codeEvents);

                        //re-init the playback
                        getPlaybackWindowsReadyForAnimation(true);
                    };

                    //begin the read operation (as text)
                    fileReader.readAsText(uploadedFile);
                });

                //add statistics data to the modal only when the modal shows up
                document.querySelector('#statisticsModalButton').addEventListener("click", function(e) {
                    //clear out the modal body (in case this isn't the first time viewing statistics)
                    $('#statisticsModalBody').html('');

                    //make a table and populate it with general statistics
                    $('#statisticsModalBody').append('<div class="container">');
                    $('#statisticsModalBody').append('<h4>General Statistics</h3>')
                    $('#statisticsModalBody').append('<table class="table table-striped table-hover">');
                    //$('#statisticsModalBody').append('<caption>General Statistics</caption>');

                    //text inserts
                    $('#statisticsModalBody').append('<tr>');
                    $('#statisticsModalBody').append('<td class = "statistics-td">Inserts</td>');
                    $('#statisticsModalBody').append('<td class = "statistics-td">&nbsp;</td>');
                    $('#statisticsModalBody').append('<td class = "statistics-td">' + statisticsData.numInserts + '</td>');
                    $('#statisticsModalBody').append('</tr>');
                    
                    //text deletes
                    $('#statisticsModalBody').append('<tr>');
                    $('#statisticsModalBody').append('<td class = "statistics-td">Deletes</td>');
                    $('#statisticsModalBody').append('<td class = "statistics-td">&nbsp;</td>');
                    $('#statisticsModalBody').append('<td class = "statistics-td">' + statisticsData.numDeletes + '</td>');
                    $('#statisticsModalBody').append('</tr>');
                    
                    //file and directory events
                    $('#statisticsModalBody').append('<tr>');
                    $('#statisticsModalBody').append('<td class = "statistics-td">File and Directory Events</td>');
                    $('#statisticsModalBody').append('<td class = "statistics-td">&nbsp;</td>');
                    $('#statisticsModalBody').append('<td class = "statistics-td">' + statisticsData.numFileDirEvents + '</td>');
                    $('#statisticsModalBody').append('</tr>');

                    $('#statisticsModalBody').append('</table>');
                    $('#statisticsModalBody').append('</div>');

                    //make a table for statistics by dev group (or just say no one has contributed)
                    $('#statisticsModalBody').append('<div class="container">');
                    if(statisticsData.eventsByDevGroup.length === 0) {
                        $('#statisticsModalBody').append('<h4>No contributors yet.</h4>');
                    }
                    else { //we have at least one contributing developer group
                        //make the table
                        $('#statisticsModalBody').append('<h4>Events by Developer Group</h4>');
                        $('#statisticsModalBody').append('<table class="table table-striped table-hover">');
                        //$('#statisticsModalBody').append('<caption>Events by Developer Group</caption>');
                        //label the columns
                        $('#statisticsModalBody').append('<tr>');
                        $('#statisticsModalBody').append('<th class = "statistics-td">Developer(s)</th>');
                        $('#statisticsModalBody').append('<th class = "statistics-td">Inserts</th>');
                        $('#statisticsModalBody').append('<th class = "statistics-td">Deletes</th>');
                        $('#statisticsModalBody').append('<th class = "statistics-td">Total Events</th>');
                        $('#statisticsModalBody').append('</tr>');
                        //populate the table
                        for(var i = 0; i < statisticsData.eventsByDevGroup.length; i++) {
                            $('#statisticsModalBody').append('<tr>');
                            var devs = getDevelopersInDevGroup(statisticsData.eventsByDevGroup[i].id);
                            //If this group contains one developer, add that one developer to the table
                            if(devs.length === 1) {
                                $('#statisticsModalBody').append('<td class = "statistics-td"><a href="mailto:' + devs[0].email + '">' + devs[0].firstName + ' ' + devs[0].lastName + '</a></td>');
                            }
                            //I can't think of any reason for a dev group to be empty, so output something if one is
                            else if(devs.length === 0) {
                                console.log('This dev group has no developers: ' + statisticsData.eventsByDevGroup[i].id);
                            }
                            //If there are multiple devs in a group, print them all in one cell and hope the number of devs per group never gets too extreme
                            else { //This group has multiple devs
                                $('#statisticsModalBody').append('<td class = "statistics-td">');
                                for(var j = 0; j < devs.length; j++) {
                                    $('#statisticsModalBody').append("<a href='mailto:" + devs[j].email + "'>" + devs[j].firstName + " " + devs[j].lastName + "</a>");
                                    //Add commas to separate developers
                                    if(j < devs.length - 1) {
                                        $('statisticsModalBody').append(' , ');
                                    }
                                }
                                $('#statisticsModalBody').append('</td>');
                            }
                            //$('#statisticsModalBody').append('<td>' + statisticsData.eventsByDevGroup[i].id + '</td>');
                            $('#statisticsModalBody').append('<td class = "statistics-td">' + statisticsData.eventsByDevGroup[i].numInserts + '</td>');
                            $('#statisticsModalBody').append('<td class = "statistics-td">' + statisticsData.eventsByDevGroup[i].numDeletes + '</td>');
                            $('#statisticsModalBody').append('<td class = "statistics-td">' + statisticsData.eventsByDevGroup[i].numEvents + '</td>');
                            $('#statisticsModalBody').append('</tr>');
                        }
                        $('#statisticsModalBody').append('</table>');
                    }
                    $('#statisticsModalBody').append('</div>');

                    //make a list of modified files (or say there are none)
                    $('#statisticsModalBody').append('<div class="container">');
                    if(statisticsData.modifiedFiles.length === 0) {
                        $('#statisticsModalBody').append('<h4>No files have been modified yet.</h4>');
                    }
                    else { //Files have been modified
                        $('#statisticsModalBody').append('<h4>Files with changes:</h4>');
                        $('#statisticsModalBody').append('<ul>');
                        for(var i = 0; i < statisticsData.modifiedFiles.length; i++) {
                            $('#statisticsModalBody').append('<li>' + statisticsData.modifiedFiles[i].name + '</li>');
                        }
                        $('#statisticsModalBody').append('</ul>');
                    }
                    $('#statisticsModalBody').append('</div>');
                });
            }
            
            /*
             * Adds a time frame to the table of selected filtered timeframes
             */
            function addFilteredTimeFrame(startTime, endTime) {

                //get the table with all of the selected time filters
                var userSelectedTimeSpans = document.querySelector("#userSelectedTimeSpans");

                //add a new row to the table that holds all of the selected time frames
                var timeFrameRow = userSelectedTimeSpans.insertRow();
                timeFrameRow.classList.add("filterTimeframe");

                //button to delete the time frame
                var deleteTimeFrameButton = timeFrameRow.insertCell(0);
                var deleteAnchor = document.createElement("a");
                deleteAnchor.href="#";
                deleteAnchor.innerHTML = "&times";
                deleteAnchor.addEventListener("click", function(e) {
                    
                    //delete the row that this button is on
                    userSelectedTimeSpans.deleteRow(timeFrameRow.rowIndex);
                });
                deleteTimeFrameButton.appendChild(deleteAnchor);

                //display the start time
                var startTimeTD = timeFrameRow.insertCell(1);
                startTimeTD.classList.add("startTimeFrame");
                startTimeTD.innerHTML = formatDateShortWithDayOfWeek(startTime);

                //display the end time
                var endTimeTD = timeFrameRow.insertCell(2);
                endTimeTD.classList.add("endTimeFrame");
                endTimeTD.innerHTML = formatDateShortWithDayOfWeek(endTime);
            }

            //*****************************************************************************
            //                         playback window related code
            //                         ----------------------------
            // This code has to do with adding characters on the playback window
            //*****************************************************************************
            /*
             * Used to get the playback window ready for animating code. There are two types
             * of preparation. If the user wants a complete intitialization (or re-init) then
             * all the playback windows will be wiped out and
             *
             * - reset the playback object's data to get ready for a new playback
             * - add an initial span for all 'first' characters in the file to go in front of
             * - add an invisible last span to always have the playback window take up some space
             * - preload all the insert spans to the screen and make them not visible
             */
            function getPlaybackWindowsReadyForAnimation(shouldInitialize) {

                //reset some playback information
                playbackData.codeEventsIndex = -1;
                playbackData.mostRecentDirection = "forward";
                playbackData.relevantEventIndex = 0;
                playbackData.playbackState = "paused";
                playbackData.playbackTimerId = null;
                playbackData.activeFileId = null;
                playbackData.activeLineNumber = null;
                playbackData.latestPlaybackEventDevGroupId = null;

                //set the slider back to the beginning and empty the timestamp
                var playbackProgressBar = document.querySelector("#playbackProgressBar");
                playbackProgressBar.setAttribute("style", "width:0%");
                playbackProgressBar.innerHTML = "";


                //empty the timestamp info
                document.querySelector("#eventTypeDiv").innerHTML = "";
                document.querySelector("#eventInfoDiv").innerHTML = "";
                document.querySelector("#timestampDiv").innerHTML = "";

                //add an avatar to take up space in the UI
                var anonDevImage = document.createElement("img");
                anonDevImage.setAttribute("src", "http://www.gravatar.com/avatar/anon?s=50&d=mm");
                anonDevImage.setAttribute("alt", "Developer Info");
                anonDevImage.classList.add("img-thumbnail");

                //add the avatar
                var eventDevInfo = document.querySelector("#eventDevInfo")
                eventDevInfo.innerHTML = "";
                eventDevInfo.appendChild(anonDevImage);


                //filter start and end time
                var startDateTime;
                var endDateTime;

                //if there are some code events
                if(playbackData.codeEvents.length > 0) {

                    //get the time of the first and last events and populate the text inputs
                    startDateTime = new Date(playbackData.codeEvents[0].timestamp);
                    endDateTime = new Date(playbackData.codeEvents[playbackData.codeEvents.length - 1].timestamp);

                } else { //no events

                    //use the current time for both inputs just to show something
                    startDateTime = new Date();
                    endDateTime = startDateTime;
                }

                //display the start and end time of events for filtering
                //set the time of the two time filter inputs
                document.querySelector("#startTimeInput").value = formatDateShortWithDayOfWeek(startDateTime);
                document.querySelector("#endTimeInput").value = formatDateShortWithDayOfWeek(endDateTime);
                
                //clear out any selected time frames
                var userSelectedTimeSpans = document.querySelector("#userSelectedTimeSpans");

                //we want to keep the first row because it is a row of headers
                while(userSelectedTimeSpans.rows.length > 1) {

                    //remove the last row
                    userSelectedTimeSpans.deleteRow(userSelectedTimeSpans.rows.length - 1);
                }

                //add the default time filter
                addFilteredTimeFrame(startDateTime, endDateTime);

                //if there are some developer groups display them in the filter section
                displayAllDevGroupMembersForFiltering();

                //display a view of the file system for file filtering
                displayFileSystemForFiltering();

                //empty the view of the file system (this gets built up during playback)
                document.querySelector("#playbackViewOfFileSystem").innerHTML = "";

                //clear any previous comments that are displayed
                clearPreviousComment();

                //if we want to completely reinitialize a playback
                if(shouldInitialize === true) {

                    //empty out any old playback windows
                    document.querySelector("#playbackWindowTabLinks").innerHTML = "";
                    document.querySelector("#playbackWindows").innerHTML = "";

                    //clear out the number of relevant events (we'll count them below)
                    playbackData.numberOfRelevantEvents = 0;

                    //go through all of the code and pre-load the playback window with spans that hold
                    //the code to display. Each code event knows the id of its previous neighbor and
                    //will be displayed immediately after a span with that id. There is a style that
                    //will make the code invisible by default. The playback is animated by going through
                    //the code events removing the style so that the code will show up.

                    //the benefit of pre-loading the playback window with all of the spans is that it makes
                    //animating the code easy (no DOM adds/removes during playback), just adding and removing
                    //styles to spans. This makes the code for going forward and backward through the code 
                    //simpler (especially backward).

                    //go through all of the events
                    for(var i = 0;i < playbackData.codeEvents.length;i++) {

                        //if the event does not have a relevant member OR there is a relevant member and its true
                        if(playbackData.codeEvents[i].relevant === undefined || playbackData.codeEvents[i].relevant === true) {

                            //initially all events are relevant (if the user filters the playback some events may become irrelevant)
                            playbackData.codeEvents[i].relevant = true;

                            //increase the number of relevant events
                            playbackData.numberOfRelevantEvents++;

                        } //else- the event has a relevant member already, this data came from a saved, filtered playback

                        //if the code character is an insert
                        if(playbackData.codeEvents[i].type === "Insert") {

                            //add it to the file's playback window
                            addCharacter(playbackData.codeEvents[i], playbackData.codeEvents[i].fileId);

                        } else if(playbackData.codeEvents[i].type === "Create File") { //new file

                            //create a new tab to show the code
                            createFilePlaybackTab(playbackData.codeEvents[i].fileId, playbackData.codeEvents[i].initialName);
                        }
                    }

                } else { //do not need to reinitialize the whole playback, we just want to start an existing playback over again

                    //get all of the code elements that are visible on the screen
                    var allVisibleCodeElements = document.querySelectorAll(".codeChar:not(.codeNotVisible)");

                    //go through the visible elements and make them invisible
                    for(var i = 0;i < allVisibleCodeElements.length;i++) {

                        //add a style that will hide them
                        allVisibleCodeElements[i].classList.add("codeNotVisible");
                    }

                    //for each file that is displayed, empty out any old line numbers and add the first line number
                    var allLineNumberGutters = document.querySelectorAll(".lineNumberGutter");

                    for(var i = 0;i < allLineNumberGutters.length;i++) {

                        //make a single line number in each playback window tab
                        allLineNumberGutters[i].innerHTML = "<div class='lineNum'></div>";
                    }

                    //hide all of the playback windows
                    //get all of the links to the playback window tabs
                    var allplaybackWindowTabLinks = document.querySelectorAll("#playbackWindowTabLink");

                    for(var i = 0;i < allplaybackWindowTabLinks.length;i++) {

                        //make the tabs 'invisible' by adding a class (not really invisible just styled differently)
                        allplaybackWindowTabLinks[i].classList.add("playbackTabNotVisible");
                    }
                }
            }

            /*
             * Adds a character to the playback window. It creates a new element (either a <span>
             * for code characters and a <br> for new line characters) and sets the id to
             * be the id of the code event.
             *
             * To place it on the screen it looks at the id of the code event's previous
             * neighbor and finds a span with that id. It then inserts a new element right
             * after that.
             *
             * All code elements are added to the playback window once before the animation starts.
             * They are hidden initially. Once the events are played back they will be made
             * visible and show up on the screen.
             */
            function addCharacter(code, fileId) {

                //new element (either a <span> for code or a <br> for newlines) to put in
                //the playback window
                var newElement;

                //if the code character is a newline
                if(code.character === "\n") {

                    //create a <br> object with the character id and a newLine class
                    //when this is played back it will become visible and the current
                    //line of code will end
                    newElement = document.createElement("br");
                    newElement.setAttribute("id", code.id);
                    newElement.classList.add("newLine");

                } else { //non-newline (tab or code)

                    //create a <span> object with the character id as its id
                    newElement = document.createElement("span");
                    newElement.setAttribute("id", code.id);

                    //if its a tab
                    if(code.character === "\t") {

                        //add a tab class
                        newElement.classList.add("tab");

                        //add some spaces for each tab
                        newElement.innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;"

                    } else if(code.character === " ") { //its a single space

                        //add a space class
                        newElement.classList.add("space");

                        //add a visible space
                        newElement.innerHTML = "&nbsp;"

                    } else { //visible character

                        //add the single code character to the span
                        newElement.appendChild(document.createTextNode(code.character));
                    }
                }

                //identify all code characters
                newElement.classList.add("codeChar");

                //default all code elements to not be visible initially. This class will
                //be removed when it is 'played back'
                newElement.classList.add("codeNotVisible");


                //add the code element to the playback window
                //holds the code's previous neighbor element
                var previousElement;
                
                //if the code event has a previous neighbor id
                if(code.previousNeighborId !== "none") {

                    //find the previous neighbor element
                    previousElement = document.querySelector("#" + code.previousNeighborId);

                } else { //no previous neighbor (this is the first character in the file)

                    //use the first span in the file as a previous neighbor
                    previousElement = document.querySelector("#firstSpan-" + fileId);
                }

                //debug- if there is no previous element
                if(!previousElement) {
                    console.log("There is nor previous element at all!!!");
                }

                //add the new element right after the previous element (there is no insertAfter)
                previousElement.parentNode.insertBefore(newElement, previousElement.nextSibling);
            }

            //*****************************************************************************
            //                         Event compression related code
            //                         ------------------------------
            // This code has to do with making the footprint of the stored events smaller
            // on the disk. The approach we take is to rely on the fact that sequential 
            // events tend to share many of the same attributes. The contributing developer
            // group, for example, tends to stay the same for long periods of time. So, we
            // store the dev group id in an event once it changes and then leave it out of 
            // future events until it changes again. During decompression, the code will look
            // for attributes in the events but if one can't be found it will use the last 
            // saved value for that one.  
            //*****************************************************************************

            //event compression can be used or not (it is useful to NOT use compression 
            //while debugging), this flag indicates whether to use it or not
            var useCompressionForEvents = true;

            /*
            * This function minimizes the footprint of insert and delete events. This is done because the event info eventually
            * ends up being stored on a disk. We want to miminize the disk space required to store these events. 
            * 
            * Since many sequential inserts and deletes share many of the same attributes they can be omitted from the events 
            * and the playback code can use the latest values from immediate past events.
            * 
            * The names of the properties are shortened and some properties are left out if they are the same as immediately 
            * previous events. 
            * 
            * The file/dir related events happen infrequently enough (and they don't share much in common with other events)
            * that there is no attempt to compress them. 
            */
            function compressEvents(events) {

                //create an object to hold all of the values that may be used for future events
                var latestEventValues = {
                    type: null,
                    timestamp: 0,
                    createdByDevGroupId: null,  
                    previousNeighborId: null,
                    lineNumber: null,
                    column: null,
                    fileId: null,
                    anticipatedNextEventId: null,
                    relevant: null
                };

                //holds the compressed events
                var compressedEvents = [];

                //loop through all the events and compress them
                for(var i = 0;i < events.length;i++) {

                    //get the uncompressed event            
                    var event = events[i];

                    //default to the uncompressed event (this will hold a new object if there is any compression to do)
                    var compressedEvent = event;

                    //if we are compressing events AND the event is not already compressed (compressed events don't have an 'id') AND this is an insert or a delete
                    if(useCompressionForEvents && event.id && (event.type === "Insert" || event.type === "Delete")) {
                        
                        //get the numeric part of the event's id (without the 'ev_') and turn it into a number
                        var numericPartOfEventId = parseInt(event.id.substr("ev_".length), 10);

                        //every compressed insert/delete event has an id and a character in it
                        compressedEvent = {
                            c: event.character,
                            i: numericPartOfEventId.toString(36) //shorten the id num associated with the event
                        };
                        
                        //if the event type is different than the last one
                        if(event.type !== latestEventValues.type) {

                            //add the type (abbreviated to 'ty' to make the json file smaller) to the compressed event
                            compressedEvent.ty = event.type;

                            //store the latest type
                            latestEventValues.type = event.type;

                        } //else- same as the last event, leave this attribute out to make it a smaller event object

                        //if there is a difference between this event's timestamp and the last event's time stamp
                        if(event.timestamp - latestEventValues.timestamp !== 0) {

                            //add the difference between the two timestamps (in base 36 to shorten the string)
                            compressedEvent.t = (event.timestamp - latestEventValues.timestamp).toString(36);

                            //store the latest timestamp
                            latestEventValues.timestamp = event.timestamp;

                        } //else- same as the last event, leave this attribute out to make it a smaller event object

                        //if the dev group is different than the last one
                        if(event.createdByDevGroupId !== latestEventValues.createdByDevGroupId) {

                            //add the dev group (abbreviated to 'd' to make the json file smaller) to the compressed event
                            compressedEvent.d = event.createdByDevGroupId;

                            //store the latest dev group
                            latestEventValues.createdByDevGroupId = event.createdByDevGroupId;
                        
                        } //else- same as the last event, leave this attribute out to make it a smaller event object
                        
                        //if the file id is different than the last one
                        if(event.fileId !== latestEventValues.fileId) {

                            //add the file id (abbreviated to 'f' to make the json file smaller) to the compressed event
                            compressedEvent.f = event.fileId;

                            //store the latest file id
                            latestEventValues.fileId = event.fileId;

                        } //else- same as the last event, leave this attribute out to make it a smaller event object

                        //if the previous neighbor id is different than the last event added/removed
                        if(event.previousNeighborId !== latestEventValues.anticipatedNextEventId) {

                            //add the previous neighbor (abbreviated to 'p' to make the json file smaller) to the compressed event
                            compressedEvent.p = event.previousNeighborId;

                            //the latestEventValues's anticipatedNextEventId will get set below

                        } //else- same as the last event, leave this attribute out to make it a smaller event object

                        //if the line number is different than the last one
                        if(event.lineNumber !== latestEventValues.lineNumber) {

                            //add the line number (abbreviated to 'l' to make the json file smaller) to the compressed event
                            compressedEvent.l = event.lineNumber;

                            //store the latest line number
                            latestEventValues.lineNumber = event.lineNumber;

                        } //else- same as the last event, leave this attribute out to make it a smaller event object
                        
                        //if there is a 'relevant' member in the event 
                        //the 'relevant' member gets added only after filtering is done in a playback, this only happens when saving a filtered 
                        //playback to a json file (in most cases will be absent). If one event has it, all will have it
                        if(event.relevant !== undefined) {
                            
                            //if the relevancy is different from the last one
                            if(event.relevant !== latestEventValues.relevant) {

                                //add the relevancy (abbreviated to 'r' to make the json file smaller) to the compressed event
                                compressedEvent.r = event.relevant;

                                //store the last relevancy value
                                latestEventValues.relevant = event.relevant;
                            }

                        } //else- no relevant member, do nothing

                        //if this is an insert
                        if(event.type === "Insert") {

                            //if the column is different than one more than the last one
                            if(event.column !== (latestEventValues.column + 1)) {

                                //add the column (abbreviated to 'co' to make the json file smaller) to the compressed event
                                compressedEvent.co = event.column;

                                //store the latest column
                                latestEventValues.column = event.column;

                            } else { //same as the last event, leave this attribute out to make it a smaller event object
                                
                                //add one to get ready for the next event
                                latestEventValues.column = latestEventValues.column + 1;                
                            }

                            //store the id of the current event in anticipation of the next one also being an 
                            //insert event that will back to this one
                            latestEventValues.anticipatedNextEventId = event.id;

                        } else if(event.type === "Delete") { //this is a delete

                            //if the column is different than one more than the last one
                            if(event.column !== latestEventValues.column) {

                                //add the column (abbreviated to 'co' to make the json file smaller) to the compressed event
                                compressedEvent.co = event.column;

                                //store the latest column
                                latestEventValues.column = event.column;

                            } //else- same as the last event, leave this attribute out to make it a smaller event object
                            
                            //get the numeric value associated with the delete event's previous neighbor and increment it
                            var nextEventIdNumber = parseInt(event.previousNeighborId.substr("ev_".length), 10) + 1;

                            //deletes usually happen in blocks (as do inserts) so anticipate that the next event deleted 
                            //will have an id that it one more than the current event being deleted 
                            latestEventValues.anticipatedNextEventId = "ev_" + nextEventIdNumber;            
                        }

                    } //else- no compression for non-inserts/deletes

                    //add the compressed event to the collection of all compressed events
                    compressedEvents.push(compressedEvent);
                }

                return compressedEvents;
            }

            /* 
            * This function creates new event objects and adds full members from a group of compressed events. If the compressed event
            * is missing data members it uses values from previous events.
            * 
            * Since many sequential inserts and deletes share many of the same attributes they can be omitted 
            * from the events and the playback code can use the latest values from immediate past events. 
            * 
            * The shortened names of the properties are expanded and some properties are added if they are missing from an event 
            * based on the values of previous events. 
            * 
            * The file/dir related events happen infrequently enough (and they don't share much in common with other events)
            * that there is no attemp to compress them. 
            */
            function decompressEvents(compressedEvents) {

                //create an object to hold all of the values that may be used for future events
                var latestEventValues = {
                    type: null,
                    timestamp: 0,
                    createdByDevGroupId: null,  
                    previousNeighborId: null,
                    lineNumber: null,
                    column: null,
                    fileId: null,
                    anticipatedNextEventId: null,
                    relevant: null
                };

                //holds the decompressed events
                var decompressedEvents = [];

                //loop through all the compressed events and decompress them
                for(var i = 0;i < compressedEvents.length;i++) {
                
                    //get the latest event
                    var event = compressedEvents[i];

                    //decompressed event- start with an empty object
                    var decompressedEvent = {};

                    //if the object has a full 'id' property then it is NOT a compressed event 
                    if(event.id) {

                        //use the passed in event (likely a file/dir event)
                        decompressedEvent = event;

                    } else { //this is a compressed event

                        //get the numeric part of the id and turn it back into a base 10 number
                        decompressedEvent.id = "ev_" + parseInt(event.i, 36);

                        //every compressed event has the original event's character, no need to do anything with these
                        decompressedEvent.character = event.c;

                        //'ty' === 'type'
                        //if the event has a type 
                        if(event.ty) {
                            
                            //change it into a type
                            decompressedEvent.type = event.ty;

                            //store the last event type
                            latestEventValues.type = event.ty;
                            
                        } else { //there is not a 'ty' property, use the same as the latest event
                            
                            //add the last event's type to the decompressed event
                            decompressedEvent.type = latestEventValues.type;
                        }
                        
                        //'t' === 'timestamp'
                        //if the event has a timestamp (really it's a difference between the last two timestamps)
                        if(event.t) {
                            
                            //change it into a timestamp- add the last timestamp value to the difference received in the event (converted from a base 36 to a base 10)
                            decompressedEvent.timestamp = latestEventValues.timestamp + parseInt(event.t, 36);

                            //store the last event type
                            latestEventValues.timestamp = decompressedEvent.timestamp; 
                            
                        } else { //there is not a 't' property, use the same as the latest event
                            
                            //add the last event's type to the decompressed event
                            decompressedEvent.timestamp = latestEventValues.timestamp;
                        }

                        //'d' === 'createdByDevGroupId'
                        //if the event has a dev group                     
                        if(event.d) {

                            //use the shortened property 
                            decompressedEvent.createdByDevGroupId = event.d;

                            //use this as the last dev group
                            latestEventValues.createdByDevGroupId = event.d; 

                        } else { //there is not a 'd' property, use the same as the latest event

                            //use the last event's dev group id 
                            decompressedEvent.createdByDevGroupId = latestEventValues.createdByDevGroupId;                            
                        }
                        
                        //'f' === 'fileId'
                        //if the event has a file id                     
                        if(event.f) {

                            //use the shortened property 
                            decompressedEvent.fileId = event.f;

                            //use this as the last file id
                            latestEventValues.fileId = event.f;
                            
                        } else { //there is no 'f' property, use the same as the latest event

                            //use the last event's file id
                            decompressedEvent.fileId = latestEventValues.fileId;
                        }
                        
                        //'p' === 'previousNeighborId'
                        //if the event has a prev neighbor id                     
                        if(event.p) {

                            //use the shortened property 
                            decompressedEvent.previousNeighborId = event.p; 
                            
                            //the latestEventValues's anticipatedNextEventId will get set below

                        } else { //there is no 'p' property, use the same as the latest event

                            //use the last event as a prev neighbor id
                            decompressedEvent.previousNeighborId = latestEventValues.anticipatedNextEventId;
                        }
                        
                        //'l' === 'lineNumber'
                        //if the event has a line number 
                        if(event.l) {

                            //use the shortened property 
                            decompressedEvent.lineNumber = event.l;

                            //use this as the last line number 
                            latestEventValues.lineNumber = event.l;                         

                        } else { //there is no 'l' property, use the same as the latest event 

                            //use the last event's line number 
                            decompressedEvent.lineNumber = latestEventValues.lineNumber;
                        }
                    
                        //'r' === 'relevant'
                        //if the event has a relevant field from a playback  
                        if(event.r !== undefined) {

                            //use the shortened property 
                            decompressedEvent.relevant = event.r;

                            //use this as the relevant value 
                            latestEventValues.relevant = event.r;                         

                        } else { //there is no 'r' property 

                            //if the 'relevant' field has been set before
                            if(latestEventValues.relevant !== null) {

                                //use the last event's relevant value
                                decompressedEvent.relevant = latestEventValues.relevant; 

                            } //else- none of the events so far have had a relevant value, the event does need this property
                        }

                        //if this is an insert
                        if(decompressedEvent.type === "Insert") {

                            //'co' === 'column'
                            //if the event has a column
                            if(event.co) {

                                //use the shortened property 
                                decompressedEvent.column = event.co;                        

                                //use this as the last column
                                latestEventValues.column = event.co; 

                            } else { //there is no 'co' property, use the same as the latest event 

                                //move the column forward one position
                                latestEventValues.column = latestEventValues.column + 1;

                                //use the last event's column plus one 
                                decompressedEvent.column = latestEventValues.column;
                            }

                            //store the id of the current event in anticipation of the next one also being an 
                            //insert event that will back to this one

                            //store the id of the event so the next call knows what came before
                            latestEventValues.anticipatedNextEventId = decompressedEvent.id;

                        } else if(decompressedEvent.type === "Delete") { //this is a delete
                            
                            //'co' === 'column'
                            //if the event has a column
                            if(event.co) {

                                //use the shortened property 
                                decompressedEvent.column = event.co;                        

                                //use this as the last column
                                latestEventValues.column = event.co; 

                            } else { //there is no 'co' property, use the same as the latest event 

                                //deletes do not move the column forward like inserts do

                                //use the last event's column plus one 
                                decompressedEvent.column = latestEventValues.column;
                            }

                            //get the numeric value associated with the delete event's previous neighbor and increment it
                            var nextEventIdNumber = parseInt(decompressedEvent.previousNeighborId.substr("ev_".length), 10) + 1;

                            //deletes usually happen in blocks (as do inserts) so anticipate that the next event deleted 
                            //will have an id that it one more than the current event being deleted 
                            latestEventValues.anticipatedNextEventId = "ev_" + nextEventIdNumber;            
                        }
                    }

                    //add the decompressed event to the collection
                    decompressedEvents.push(decompressedEvent);
                }

                return decompressedEvents;
            }

            //*****************************************************************************
            //                         Animation related code
            //                         ----------------------
            // This code has to do with animating the adding and removing of code in the
            // playback window. This is playback.
            //*****************************************************************************
            /*
             * Toggle between playing and pausing. The state ("playing" or "paused") is kept
             * in the main playbackData object.
             */
            function togglePlayPause() {

                //if the playback is in a playing state
                if(playbackData.playbackState === "playing") {

                    //pause the playback
                    pausePlayback();

                } else if(playbackData.playbackState === "paused"){ //the playback is paused

                    //start playing the playback
                    playPlayback();
                }
            }

            /*
             * This is a function that will start an animated playback
             */
            function playPlayback() {

                //change the bootstrap class name to get the pause image to show
                //var playPausePic = document.querySelector("#playPausePic");
                //playPausePic.className = "glyphicon glyphicon-pause";

                //change the button to allow pausing the playback
                playPauseButton.innerHTML = "Pause";

                //start playing the playback
                playbackData.playbackState = "playing";

                //create a timer to animate the next step with a call to timedPlayback() after a delay 
                playbackData.playbackTimerId = window.setTimeout(timedPlayback, playbackData.delay);
            }

            /*
             * This function will be called every playbackData.delay ms during the playing state.
             * When the end of the playback is reached it will automatically stop.
             * If the requested delay ever hits 0 it will jump right to the end in one big step.
             */
            function timedPlayback() {

                //if there are no more events to play back
                if(playbackData.relevantEventIndex === playbackData.numberOfRelevantEvents) {

                    //stop the playback because its done
                    pausePlayback();

                } else if(playbackData.delay <= 0) { //if the delay is so small they don't want to see any animation

                    //step forward to the very end of the code
                    step("forward", playbackData.numberOfRelevantEvents);

                    //stop the playback
                    pausePlayback();

                } else { //normal playback operation

                    //take one step forward
                    step("forward", 1, playbackData);

                    //if we haven't been interrupted by a comment
                    if(playbackData.playbackState === "playing") {

                        //create a timer to animate the next step with a call to this function after a delay
                        playbackData.playbackTimerId = window.setTimeout(timedPlayback, playbackData.delay);
                    }
                }
            }

            /*
             * This is a function that will pause playback,
             */
            function pausePlayback() {

                //change the bootstrap class name to get the pause image to show
                //var playPausePic = document.querySelector("#playPausePic");
                //playPausePic.className = "glyphicon glyphicon-play";

                //change the text of the button to allow playing
                playPauseButton.innerHTML = "Play";

                //change the state of the playback
                playbackData.playbackState = "paused";

                //stop the automatic stepping of the playback
                window.clearTimeout(playbackData.playbackTimerId);

                //remove the timer id since it isn't needed anymore
                playbackData.playbackTimerId = null;
            }

            /*
             * Moves a playback forward or backward some number of steps. First it verifies the number of steps to
             * move is valid. Then it grabs the next relevant event from the playback data and handles it based on 
             * its type. If there is a comment the playback will stop for it (unless the user wishes to not pause on 
             * comments). The last event in the step will cause some changes to the UI like making the correct tab 
             * active and updating the file system view of the playback. At the last step we look forward to the next 
             * event in sequence to see if it has the same timestamp. If so, and the user wants to see cuts/pastes in 
             * a big block then it will move forward since events with the same timestamp are cuts/pastes.
             */
            function step(direction, numStepsRequested) {

                //holds the number of steps to move (default to the requested amount- this may be changed below)
                var numSteps = numStepsRequested;
                
                //handle improper step requests
                //if going forward in a playback
                if(direction === "forward") {
                    
                    //if the user wants to go to the very end (this value is set in the playback server to go to the end of of a playback to add a comment) OR 
                    //the number of steps is too great to playback
                    if(numStepsRequested === Number.MAX_SAFE_INTEGER || (playbackData.relevantEventIndex + numStepsRequested) >= playbackData.numberOfRelevantEvents) {

                        //scale back the number of steps to go to the end
                        numSteps = playbackData.numberOfRelevantEvents - playbackData.relevantEventIndex;
                    }

                } else if(direction === "backward") { //backward through a playback

                    //if the number of steps is too great to playback backwards
                    if(numStepsRequested > playbackData.relevantEventIndex) {

                        //scale back the number of steps to go back to the beginning
                        numSteps = playbackData.relevantEventIndex;
                    }
                }

                //if there are any steps to playback after adjusting numSteps
                if(numSteps > 0) {

                    //when numStepsRequested is equal to Number.MAX_SAFE_INTEGER we want to jump to the end of the playback without comments being displayed
                    var skipAllComments = (numStepsRequested === Number.MAX_SAFE_INTEGER);

                    //holds information about a step
                    var stepData = {
                        codeEvent: null,	//holds the current code event that is being handled
                        codeElement: null,	//holds an element in the playback window to either show/hide
                        currentStep: 0		//holds the number of steps handled so far
                    };
                    
                    //for each requested step
                    while(stepData.currentStep < numSteps) {

                        //move the code event index forward/backward to move through the events before the animated step
                        //if continuing forward
                        if(direction === "forward" && playbackData.mostRecentDirection === "forward") {

                            //move forward to the next event in sequence
                            playbackData.codeEventsIndex++;

                        } else if(direction === "backward" && playbackData.mostRecentDirection === "backward") { //continuing backward

                            //move backward to the previous position
                            playbackData.codeEventsIndex--;

                        } else if(direction === "backward" && playbackData.mostRecentDirection === "forward") { //changing direction
                            
                            //switch to going from forwards to backwards, don't change the playbackData.codeEventsIndex
                            //clear the comments
                            clearPreviousComment();
                        }
                        //else- change of direction from backwards to forwards, no need to change the code events index

                        //get the next code event in sequence
                        stepData.codeEvent = playbackData.codeEvents[playbackData.codeEventsIndex];

                        //handle the event in either directions
                        if(direction === "forward") {

                            //forward
                            handleEventForward(stepData);

                            //update statistics
                            updateStatisticsOneStep(direction, stepData.codeEvent);
                            
                            //if this event is relevant 
                            if(stepData.codeEvent.relevant) {

                                //we have moved to the next relevant event
                                playbackData.relevantEventIndex++;

                                //indicate that we have handled the current step
                                stepData.currentStep++;
                            }
                            
                            //store the most recent direction
                            playbackData.mostRecentDirection = "forward";
                            
                            //display comments (if there are any for this event)
                            //if we are supposed to display comments AND there are any comments for this event AND the event is relevant
                            if(!skipAllComments && playbackData.comments[stepData.codeEvent.id] && stepData.codeEvent.relevant) {

                                //clear the previous comment
                                clearPreviousComment();

                                //get the group of all comments for this event (there can be more than one)
                                var commentsForAnEvent = playbackData.comments[stepData.codeEvent.id];

                                //display the next comment
                                displayComments(commentsForAnEvent);

                                //if the user wants to pause for all comments
                                if(playbackData.pauseForComments) {

                                    //pause the playback
                                    pausePlayback();

                                    //stop handling events for now
                                    break;
                                }                                
                            }

                        } else { //moving backwards

                            //backward
                            handleEventBackward(stepData);

                            //update statistics
                            updateStatisticsOneStep(direction, stepData.codeEvent);

                            //if this is a relevant event
                            if(stepData.codeEvent.relevant) {

                                //we have moved backward to the previous relevant event
                                playbackData.relevantEventIndex--;

                                //indicate that we have handled the current step
                                stepData.currentStep++;
                            }

                            //store the most recent direction
                            playbackData.mostRecentDirection = "backward";                            
                        }

                        //if showing cuts/pastes in blocks, and we are at the final step in this group, look for 
                        //future events that have the same timestamp and are relevant and playback those too

                        //if the user wants to see pastes in a big block at once AND
                        //this is the last event in the group to step through 
                        if(playbackData.showPastesInABlock && stepData.currentStep === numSteps) {

                            //if we are going forward
                            if(direction === "forward") {

                                //if there are more events to see AND
                                //the next event has the exact same timestamp as the current one AND
                                //the next event is relevant
                                if(playbackData.codeEventsIndex < playbackData.codeEvents.length - 1 &&
                                   playbackData.codeEvents[playbackData.codeEventsIndex + 1].timestamp === stepData.codeEvent.timestamp &&
                                   playbackData.codeEvents[playbackData.codeEventsIndex + 1].relevant === true) {

                                    //add another step to playback
                                    numSteps++;
                                }

                            } else { //we are going backwards

                                //if there are more previous events to see AND
                                //the previous event has the exact same timestamp as the current one AND
                                //the previous event is relevant
                                if(playbackData.codeEventsIndex > 0 &&
                                   playbackData.codeEvents[playbackData.codeEventsIndex - 1].timestamp === stepData.codeEvent.timestamp &&
                                   playbackData.codeEvents[playbackData.codeEventsIndex - 1].relevant === true) {

                                    //add another step to playback
                                    numSteps++;
                                }
                            }
                        }
                    }

                    //for the last event in this step, perform some UI related updates that only affect the last in the step
                    //if the last event in this group of events played back is a code character event being added or removed in the editor
                    if(stepData.codeEvent.type === "Insert" || stepData.codeEvent.type === "Delete") {

                        //if the line number or column is missing search for them manually
                        lineNumberColumnCheck(stepData.codeEvent);

                        //determines if the event is an insert (if not it must be a delete)
                        var isInsert = (stepData.codeEvent.type === "Insert" && direction === "forward") || (stepData.codeEvent.type === "Delete" && direction === "backward");
	                    
                        //place a caret cursor on the relevant code character 
                        displayCaretCursor(stepData, isInsert);

                        //if this is a relevant character
                        if(stepData.codeEvent.relevant) {
                            
                            //make the correct tab active
                            makePlaybackTabActive(stepData.codeEvent.fileId);

                            //activate the file in the file system
                            addActiveFileStyling(stepData.codeEvent.fileId);
                        }

                        //highlight the current line number
                        highlightLine(stepData.codeEvent.lineNumber, stepData.codeEvent.fileId);

                        //scroll to make the code element visible in the playback window (if necessary)
                        handleScroll(stepData.codeElement);

                    } else if (stepData.codeEvent.type === "Create File" || //file related events (except delete- nothing to animate)
                               stepData.codeEvent.type === "Rename File" ||                                
                               stepData.codeEvent.type === "Move File") { 

                        //if this is a relevant character AND we are moving forward (animating in reverse is not so important)
                        if(stepData.codeEvent.relevant && direction === "forward") {

                            //TODO see if people prefer to have a caret- the problem is it may not be at the last insert in the file
                            //remove the caret from the screen
                            removeCaretCursor(stepData.codeElement);

                            //make the correct tab active
                            makePlaybackTabActive(stepData.codeEvent.fileId);

                            //highlight the file in the file system view
                            addActiveFileStyling(stepData.codeEvent.fileId);
                        }

                    } else if (stepData.codeEvent.type === "Create Directory" || //dir related events (except delete- nothing to animate) 
                               stepData.codeEvent.type === "Rename Directory" ||                               
                               stepData.codeEvent.type === "Move Directory") { 

                        //if this is a relevant character AND we are moving forward (animating in reverse is not so important)
                        if(stepData.codeEvent.relevant && direction === "forward") {

                            //TODO see if people prefer to have a caret- the problem is it may not be at the last insert in the file
                            //remove the caret from the screen
                            removeCaretCursor(stepData.codeElement);

                            //highlight the dir in the file system view  
                            addActiveDirectoryStyling(stepData.codeEvent.directoryId);                          
                        }
                    }

                    //update the elements of the UI that are
                    //affected by a code event (slider, timestamp, devs)
                    updateEventInfoUI(stepData.codeEvent);
                }
            }

            /*
             * Handle events in the forward direction. This function has three main responsibilities:
             * - adding or removing code on insert/delete
             * - adding/removing/updating elements in the file system view of the playback
             * - making file tabs visible or invisible (grayed) based on file create/delete events and renaming file tabs for file renames
             */
            function handleEventForward(stepData) {

                //check the event type
                if(stepData.codeEvent.type === "Insert") {

                    //get the hidden element for this code event and store it in the stepData
                    stepData.codeElement = document.querySelector("#" + stepData.codeEvent.id);

                    //show the code on the screen 
                    makeCodeVisible(stepData);
                    
                } else if(stepData.codeEvent.type === "Delete") {

                    //get the visible element to hide as a result of this delete and store it in the stepData
                    stepData.codeElement = document.querySelector("#" + stepData.codeEvent.previousNeighborId);

                    //hide the code on the screen 
                    makeCodeInvisible(stepData);

                } else if(stepData.codeEvent.type === "Create File") {

                    //add a new entry in the tree file system UI
                    addFileToPlaybackViewOfFileSystem(stepData.codeEvent.initialName, stepData.codeEvent.fileId, stepData.codeEvent.parentDirectoryId);

                    //at a minimum, make the file tab visible (not grayed out). If the event is relevant, step() will make it the active tab 
                    makePlaybackTabVisible(stepData.codeEvent.fileId);

                } else if(stepData.codeEvent.type === "Create Directory") {

                    //add a new entry in the tree file system UI
                    addDirectoryToPlaybackViewOfFileSystem(stepData.codeEvent.initialName, stepData.codeEvent.directoryId, stepData.codeEvent.parentDirectoryId);

                } else if(stepData.codeEvent.type === "Rename File") {

                    //update the tab link to hold the new file name (get the anchor inside the linklist item)
                    var playbackWindowLinkListItemAnchor = document.querySelector("#playbackWindowLinkListItem-" + stepData.codeEvent.fileId + " a");
                    playbackWindowLinkListItemAnchor.innerHTML = stepData.codeEvent.newFileName;

                    //update the entry in the tree file system UI
                    renameFileInPlaybackViewOfFileSystem(stepData.codeEvent.newFileName, stepData.codeEvent.fileId);

                } else if(stepData.codeEvent.type === "Rename Directory") {

                    //update the entry in the tree file system UI
                    renameDirectoryInPlaybackViewOfFileSystem(stepData.codeEvent.newDirectoryName, stepData.codeEvent.directoryId);

                } else if(stepData.codeEvent.type === "Move File") {

                    //update the entry in the tree file system UI
                    moveFileInPlaybackViewOfFileSystem(stepData.codeEvent.fileId, stepData.codeEvent.newParentDirectoryId);

                } else if(stepData.codeEvent.type === "Move Directory") {

                    //update the entry in the tree file system UI
                    moveDirectoryInPlaybackViewOfFileSystem(stepData.codeEvent.directoryId, stepData.codeEvent.newParentDirectoryId);

                } else if(stepData.codeEvent.type === "Delete File") {

                    //hide the tab so that it appears to be removed
                    makePlaybackTabInvisible(stepData.codeEvent.fileId)                        

                    //remove the entry in the tree file system UI
                    hideFileInPlaybackViewOfFileSystem(stepData.codeEvent.fileId);

                } else if(stepData.codeEvent.type === "Delete Directory") {

                    //hide all of the playback window tabs that were under the directory
                    //recurse through the directories and call makeTabInvisible for each file
                    makePlaybackTabsInADirectoryInvisible(stepData.codeEvent.directoryId);

                    //remove the entry in the tree file system UI
                    hideDirectoryInPlaybackViewOfFileSystem(stepData.codeEvent.directoryId);

                } else { //something is not right

                    console.log("ERROR: event does not have the correct type");
                    return;
                }
            }

            /*
             * Handle events in the reverse direction. This function has three main responsibilities:
             * - adding or removing code on insert/delete
             * - adding/removing/updating elements in the file system view of the playback
             * - making file tabs visible or invisible (grayed) based on file create/delete events and renaming file tabs for file renames
             */

            function handleEventBackward(stepData) {

                //check the event type
                if(stepData.codeEvent.type === "Insert") {

                    //we want to hide inserts when going in reverse
                    //get the visible element to hide as a result of this insert and store it in the stepData
                    stepData.codeElement = document.querySelector("#" + stepData.codeEvent.id);

                    //hide the code on the screen 
                    makeCodeInvisible(stepData);

                } else if(stepData.codeEvent.type === "Delete") {

                    //we want to show deletes when going in reverse
                    //get the hidden element to show as a result of this delete and store it in the stepData
                    stepData.codeElement = document.querySelector("#" + stepData.codeEvent.previousNeighborId);

                    //show the code on the screen
                    makeCodeVisible(stepData);

                } else if(stepData.codeEvent.type === "Create File") {

                    //we want to hide new files when going in reverse
                    //hide the tab so that it appears to be removed
                    makePlaybackTabInvisible(stepData.codeEvent.fileId)                        

                    //remove the entry in the tree file system UI
                    hideFileInPlaybackViewOfFileSystem(stepData.codeEvent.fileId);

                } else if(stepData.codeEvent.type === "Create Directory") {

                    //we want to hide new dirs when going in reverse
                    //hide all of the playback window tabs that were under the directory
                    //recurse through the directories and call makeTabInvisible for each file
                    makePlaybackTabsInADirectoryInvisible(stepData.codeEvent.directoryId);

                    //remove the entry in the tree file system UI
                    hideDirectoryInPlaybackViewOfFileSystem(stepData.codeEvent.directoryId);

                } else if(stepData.codeEvent.type === "Rename File") {

                    //we want to show the old name of the file when going in reverse
                    //update the link to hold the OLD file name (get the anchor inside the linklist item)
                    var playbackWindowLinkListItem = document.querySelector("#playbackWindowLinkListItem-" + stepData.codeEvent.fileId + " a");
                    playbackWindowLinkListItem.innerHTML = stepData.codeEvent.oldFileName;

                    //update the entry in the tree file system UI to the old name
                    renameFileInPlaybackViewOfFileSystem(stepData.codeEvent.oldFileName, stepData.codeEvent.fileId);

                } else if(stepData.codeEvent.type === "Rename Directory") {

                    //we want to show the old name when going in reverse
                    //update the entry in the tree file system UI to the old name
                    renameDirectoryInPlaybackViewOfFileSystem(stepData.codeEvent.oldDirectoryName, stepData.codeEvent.directoryId);

                } else if(stepData.codeEvent.type === "Move File") {

                    //we want to update to the old parent when going in reverse
                    //update the entry in the tree file system UI to the old location
                    moveFileInPlaybackViewOfFileSystem(stepData.codeEvent.fileId, stepData.codeEvent.oldParentDirectoryId);

                } else if(stepData.codeEvent.type === "Move Directory") {

                    //we want to update to the old parent when going in reverse
                    //update the entry in the tree file system UI to the old location
                    moveDirectoryInPlaybackViewOfFileSystem(stepData.codeEvent.directoryId, stepData.codeEvent.oldParentDirectoryId);

                } else if(stepData.codeEvent.type === "Delete File") {

                    //we want to show a deleted file when going in reverse
                    //add a new entry in the tree file system UI
                    addFileToPlaybackViewOfFileSystem(stepData.codeEvent.initialName, stepData.codeEvent.fileId, stepData.codeEvent.parentDirectoryId);

                    //at a minimum, make the file tab visible (not grayed out). If the event is relevant step() will make it the active tab 
                    makePlaybackTabVisible(stepData.codeEvent.fileId);

                } else if(stepData.codeEvent.type === "Delete Directory") {

                    //we want to show a deleted dir when going in reverse
                    //add a new entry in the tree file system UI
                    addDirectoryToPlaybackViewOfFileSystem(stepData.codeEvent.initialName, stepData.codeEvent.directoryId, stepData.codeEvent.parentDirectoryId);

                } else { //something is not right

                    console.log("ERROR: event does not have the correct type");
                    return;
                }
            }

            
            /*
             * Makes an element visible on the screen. If it is a relevant event then it will be higlighted.
             */
            function makeCodeVisible(stepData) {

                //make the span visible by removing the style that hides code on the screen
                stepData.codeElement.classList.remove("codeNotVisible");

                //if this is a relevant character
                if(stepData.codeEvent.relevant) {

                    //add a style for relevant characters
                    stepData.codeElement.classList.add("relevantCode");

                    //if there is any delay between characters we will highlight the insert
                    if(playbackData.delay > 0) {
                        
                        //for new insert highlighting (class will be removed with a timer below)
                        stepData.codeElement.classList.add("recentInsert");

                        //set a timer to remove the .recentInsert class from the element
                        window.setTimeout(function(codeElement) {

                            //find the recent insert and remove the class
                            codeElement.classList.remove("recentInsert");
                            
                            //remove the codeNotVisible class, perhaps again, since a very quick change of direction
                            //can make this class be added again before this code executes. This is just to
                            //ensure we always see code added
                            codeElement.classList.remove("codeNotVisible");

                        }, playbackData.highlightDelay, stepData.codeElement); //highlight delay and the element to remove the class from                        
                    } 

                } else { //code is not relevant

                    //remove the class from the code element (it may have been set from a previous playback)
                    stepData.codeElement.classList.remove("relevantCode");
                }

                //if a new line was added, add the line number
                addLineNumberIfNecessary(stepData.codeElement, stepData.codeEvent.fileId);
            }

            /*
             * Makes an element invisible on the screen. If it is a relevant event it will be highlighted.
             */
            function makeCodeInvisible(stepData)
            {
                //if this is a relevant character
                if(stepData.codeEvent.relevant) {

                    //if there is any delay between characters
                    if(playbackData.delay > 0) {
                        
                        //for new delete highlighting (class will be removed with a timer below)
                        stepData.codeElement.classList.add("recentDelete");

                        //set a timer to remove the .recentDelete class and to actually hide the event
                        window.setTimeout(function(codeElement, fileId){                            
                            
                            //remove the recent delete class
                            codeElement.classList.remove("recentDelete");

                            //add the 'code not visible' to hide it
                            codeElement.classList.add("codeNotVisible");

                            //if a new line was removed, remove the line number
                            removeLineNumberIfNecessary(codeElement, fileId);

                        }, playbackData.highlightDelay, stepData.codeElement, stepData.codeEvent.fileId); //highlight delay, the element to remove, and the id of the file where the delete is
                    
                    } else { //no delay, 
                        
                        //add the 'code not visible' to hide it
                        stepData.codeElement.classList.add("codeNotVisible");
                        
                        //if a new line was removed, remove the line number
                        removeLineNumberIfNecessary(stepData.codeElement, stepData.codeEvent.fileId);
                    }
                    
                } else { //not a relevant step

                    //remove the class from the code element (it may have been set from a previous playback)
                    stepData.codeElement.classList.remove("relevantCode");
                    
                    //hide the element
                    stepData.codeElement.classList.add("codeNotVisible");

                    //if a new line was removed, remove the line number
                    removeLineNumberIfNecessary(stepData.codeElement, stepData.codeEvent.fileId);
                }
            }

            /* 
             * used to add a visible cursor to the code. If the element to add the cursor to was inserted
             * we add a cursor to the right hand side of the element. If the element was just deleted then
             * we move backwards to find the previous visible element and add the cursor to its right hand 
             * side.
             */
            function displayCaretCursor(stepData, isInsert) {

                //remove the existing current caret cursor (if there is one)
                removeCaretCursor(stepData.codeElement);

                //if the code element was just inserted
                if(isInsert) {

                    //if the inserted element is a new line put the cursor on the next line attached to the gutter line number
                    if(stepData.codeElement.classList.contains("newLine")) {

                        //get the line number gutter for this file
                        var fileGutter = document.querySelector("#lineNumberGutter-" + stepData.codeEvent.fileId);

                        //add the cursor to the line number element (the next line because of 0 based index)
                        fileGutter.children[stepData.codeEvent.lineNumber].classList.add("caretCursor");

                    } else { //a non-newline character

                        //add the caret cursor class to the element (blink to the right)
                        stepData.codeElement.classList.add("caretCursor");
                    }           
                    
                } else { //the code element has just been deleted
                    
                    //add the caret to the previous visible code character that is not a newline
                    
                    //get the element immeditately previous to the code element
                    var previousElement = stepData.codeElement.previousSibling;

                    //while there are still some elements
                    while(previousElement) {

                        //if the previous element is a code character AND it is visible, then the cursor should go here  
                        if(previousElement.classList.contains("codeChar") && !previousElement.classList.contains("codeNotVisible")) {

                                //if it is a new line, put the cursor above on the previous line
                                if(previousElement.classList.contains("newLine")) {

                                    //get the line number gutter for this file
                                    var fileGutter = document.querySelector("#lineNumberGutter-" + stepData.codeEvent.fileId);

                                    //add the cursor to the line number element
                                    fileGutter.children[stepData.codeEvent.lineNumber - 1].classList.add("caretCursor");

                                } else { //a non-newline character

                                    //add caret cursor to the previous element 
                                    previousElement.classList.add("caretCursor");;
                                }

                                break;

                        } //else- this is not a candidate for a cursor

                        //get the previous element's previous element to continue backwards
                        previousElement = previousElement.previousSibling;
                    }
                }
            }
            
            /* 
             * used to remove a visible cursor from the code 
             */
            function removeCaretCursor(codeElement) {
                
                //get the existing current caret cursor
                var caretCursor = document.querySelector(".caretCursor");

                //if there is a cursor on the screen
                if(caretCursor) {

                    //remove it
                    caretCursor.classList.remove("caretCursor");
                }
            }

            /*
             * It is possible that the line number and column properties might have values of -1 (meaning we don't know what line
             * number and column the event occured on). A saved state playback that undoes all future events, for example. 
             * If an event is missing these then they will be calculated by manipulating the dom to find them. This is an 
             * expensive operation that should only be used when a line number and column can't be found any other way. The saved 
             * state playback that undoes events does not have access to an editor state so it can't easily determine these.
             */
            function lineNumberColumnCheck(codeEvent) {

                //only check inserts and deletes
                if(codeEvent.type === "Insert" || codeEvent.type === "Delete") {

                    //if the line number and column are missing
                    if(codeEvent.lineNumber === -1 && codeEvent.column === -1) {
                        
                        //holds elements around the code event
                        var codeElement;

                        //if it is an insert
                        if(codeEvent.type === "Insert") {

                            //grab the element being inserted
                            codeElement = document.querySelector("#" + codeEvent.id);

                        } else if(codeEvent.type === "Delete") { //its a delete

                            //grab the element being deleted
                            codeElement = document.querySelector("#" + codeEvent.previousNeighborId);
                        }
                        
                        //move the element back one to look for the br immediately before this event (in case we are removing a br 
                        //we want to find the one before it)
                        codeElement = codeElement.previousSibling;

                        //characters on the event's line (start at 1 since we moved back one element in the step above)
                        var numberOfColumnsBeforeFirstLinebreak = 1;
                        
                        //number of line breaks before the element
                        var numberOfLineBreaks = 1;
                        
                        //while there are still elements before the current element
                        while(codeElement) {

                            //if this is a visible code element AND NOT the invisible firstSpan element at the beginning of each playback window 
                            if(!codeElement.classList.contains("codeNotVisible") && !codeElement.classList.contains("firstSpan")) {
                                
                                //if we encounter a BR that is visible, this is where the previous line ends
                                if(codeElement.tagName === "BR") {
                                    
                                    //get all of the visible brs in this playback window
                                    var visibleBRs = codeElement.parentElement.querySelectorAll("br:not(.codeNotVisible)");

                                    //go through all the visible brs
                                    for(var i = 0;i < visibleBRs.length;i++) {

                                        //get a br
                                        var visibleBR = visibleBRs[i];

                                        //increase the line count
                                        numberOfLineBreaks++;

                                        //if the br has the same id as the element's closest br
                                        if(visibleBR.getAttribute("id") === codeElement.getAttribute("id")) {

                                            //stop looking for a matching br
                                            break;
                                        } 
                                    }
                                    
                                    //stop looking for the first br before the code element
                                    break;

                                } else { //visible span

                                    //increase the number of elements in the line
                                    numberOfColumnsBeforeFirstLinebreak++;
                                }
                            }
                            
                            //go backwards through all of the siblings
                            codeElement = codeElement.previousSibling;
                        }

                        //store the line number and column in the event
                        codeEvent.lineNumber = numberOfLineBreaks;
                        codeEvent.column = numberOfColumnsBeforeFirstLinebreak;
                    }
                }
            }

            /*
             * This function updates some elements of the UI when an event is rendered:
             * - the event type
             * - info about file operations
             * - the event timestamp
             * - the developer group who made the event
             * - the slider position and text
             */
            function updateEventInfoUI(codeEvent) {

                //holds event info
                var eventTypeDiv = document.querySelector("#eventTypeDiv");
                eventTypeDiv.innerHTML = codeEvent.type;

                //if this is an insert/delete print the character (useful for invisible characters)
                if(codeEvent.type === "Insert" || codeEvent.type === "Delete") {

                    //if it is a newline or a tab show the user some text
                    if(codeEvent.character === "\n") {

                        eventTypeDiv.innerHTML += " (newline '\\n') ";

                    } if(codeEvent.character === "\r") {

                        eventTypeDiv.innerHTML += " (carriage return '\\r') ";

                    } else if(codeEvent.character === " ") {

                        eventTypeDiv.innerHTML += " (space) ";

                    } else if(codeEvent.character === "\t") {

                        eventTypeDiv.innerHTML += " (tab '\\t') ";
                    }
                }

                //if there is a line number show it
                var eventInfoDiv = document.querySelector("#eventInfoDiv");

                eventInfoDiv.innerHTML = "";

                //if this is an event with a line and column number (inserts and deletes)
                if(codeEvent.lineNumber && codeEvent.column) {

                    //show the line number and column
                    eventInfoDiv.innerHTML += "Line: " + codeEvent.lineNumber + ", Col: " + codeEvent.column;

                } else { //event without a line number (file operation)

                    if(codeEvent.type === "Create File") {

                        //add the initial name of the file in the event info section
                        eventInfoDiv.innerHTML += "Initial name: " + codeEvent.initialName;

                    } else if(codeEvent.type === "Create Directory") {

                        //add the initial name of the directory in the event info section
                        eventInfoDiv.innerHTML += "Initial name: " + codeEvent.initialName;

                    } else if(codeEvent.type === "Rename File") {

                        //display the old name and the new name in the info section
                        eventInfoDiv.innerHTML += "Renaming from: '" + codeEvent.oldFileName + "' to '" + codeEvent.newFileName +"'";

                    } else if(codeEvent.type === "Rename Directory") {

                        //display the old name and the new name in the info section
                        eventInfoDiv.innerHTML += "Renaming from: '" + codeEvent.oldDirectoryName + "' to '" + codeEvent.newDirectoryName +"'";

                    } else if(codeEvent.type === "Move File") {

                        //display the old parent dir name and the new parent dir name in the info section
                        eventInfoDiv.innerHTML += "Moving '" + codeEvent.fileName +"' from: '" + codeEvent.oldParentDirectoryName + "' to '" + codeEvent.newParentDirectoryName +"'";

                    } else if(codeEvent.type === "Move Directory") {

                        //display the old parent dir name and the new parent dir name in the info section
                        eventInfoDiv.innerHTML += "Moving '" + codeEvent.directoryName +"' from: '" + codeEvent.oldParentDirectoryName + "' to '" + codeEvent.newParentDirectoryName +"'";

                    } else if(codeEvent.type === "Delete File") {

                        //add the name of the file to delete in the event info section
                        eventInfoDiv.innerHTML += "Deleting file: " + codeEvent.fileName;

                    } else if(codeEvent.type === "Delete Directory") {

                        //add the name of the file to delete in the event info section
                        eventInfoDiv.innerHTML += "Deleting directory: " + codeEvent.directoryName;

                    } else {

                        //empty the line number info
                        eventInfoDiv.innerHTML = "";
                    }
                }

                //show the timestamp
                document.querySelector("#timestampDiv").innerHTML = formatDateShortWithDayOfWeek(new Date(codeEvent.timestamp));

                //show the developers in the dev group
                showDevsInDevGroup(codeEvent);

                //update the progress bar
                var playbackProgressBar = document.querySelector("#playbackProgressBar");

                //update the slider based on how far along in the playback we are
                playbackProgressBar.setAttribute("style", "width:" +(playbackData.relevantEventIndex / playbackData.numberOfRelevantEvents) * 100.0 + "%");

                //show how many events we have displayed and how many are left
                playbackProgressBar.innerHTML = playbackData.relevantEventIndex + "/" + playbackData.numberOfRelevantEvents;
            }

            /*
             * Changes the speed of the playback. The delta can be a positive or negative number
             */
            function changeSpeed(delta) {

                //amount to increase/decrease the delay between events
                playbackData.delay += delta;

                //if we ever get a less than zero ms delay
                if(playbackData.delay < 0) {

                    //make sure we are at an even 0
                    playbackData.delay = 0;
                }

                //get the speed controls
                //var playbackSpeedDisplay = document.querySelector("#playbackSpeedDisplay");
                //var speedControlPlaybackProgressBar = document.querySelector("#speedControlPlaybackProgressBar");

                //if we are at the speed where there is no animation at all
                if(playbackData.delay <= 0) {

                    //set the speed control progress bar to be at the end
                    //speedControlPlaybackProgressBar.setAttribute("style", "width:100%");

                    //change the text to indicate no animation
                    //playbackSpeedDisplay.innerHTML = "<strong>None</strong>";

                } else if(playbackData.delay < 175) { //new speed is fast

                    //get an increment of 5% to move the slider
                    //var width = 75 + (5 * (5 - (playbackData.delay / 25)));

                    //set the width to the approximate speed
                    //speedControlPlaybackProgressBar.setAttribute("style", "width:" + width + "%");

                    //change the text to indicate a fast playback speed
                    //playbackSpeedDisplay.innerHTML = "<strong>Fast</strong>";

                } else { //new speed is slow

                    //move the slider to a low position (the same for all slow speeds)
                    //speedControlPlaybackProgressBar.setAttribute("style", "width:25%");

                    //change the text to indicate a slow playback speed
                    //playbackSpeedDisplay.innerHTML = "<strong>Slow</strong>";
                }
            }

            //*****************************************************************************
            //                         Tab related code
            //                         ----------------
            // This section of code has to do with tabs for the code files
            //*****************************************************************************
            /*
             * Create a tab that holds a playback window and a line number gutter. This is called
             * when the page is being set up for each new create file event.
             */
            function createFilePlaybackTab(fileId, fileName) {

                //it is possible with 'undone' events in a complete history playback to have multiple create file events for 
                //the same file. There is no need to create a second playback window when this happens

                //look for an existing playback window with the fileId
                var existingPlaybackWindowTab = document.querySelector("#playbackWindowTab-" + fileId);

                //if there is not an exsiting one, create it
                if(!existingPlaybackWindowTab) {
                
                    //start by adding a clickable file name link
                    //get the container of link list items for the playback window tabs
                    var playbackWindowTabLinks = document.querySelector("#playbackWindowTabLinks");

                    //create an anchor for the tab
                    //<a href="#playbackWindowTab-fileId" data-toggle="tab" class="playbackWindowTabLink">file name</a>
                    var newLink = document.createElement("a");
                    newLink.setAttribute("href", "#playbackWindowTab-" + fileId);
                    newLink.setAttribute("data-toggle", "tab");
                    newLink.classList.add("playbackWindowTabLink");
                    newLink.innerHTML = fileName;

                    //create a list item to hold the anchor
                    //<li class="playbackWindowLinkListItem" id="playbackWindowLinkListItem-fileId">
                    var newPlaybackWindowLinkListItem = document.createElement("li");
                    newPlaybackWindowLinkListItem.classList.add("playbackWindowLinkListItem");
                    newPlaybackWindowLinkListItem.setAttribute("id", "playbackWindowLinkListItem-" + fileId);

                    //add the link to the list item
                    newPlaybackWindowLinkListItem.appendChild(newLink);
                    
                    //add the list item to the group of all tab links at the top of the playback windows
                    playbackWindowTabLinks.appendChild(newPlaybackWindowLinkListItem);


                    //next, the actual playback window

                    //create a div to hold a playback window
                    //get the container of all playback window divs
                    var playbackWindows = document.querySelector("#playbackWindows");

                    //create a new div for this file (line gutter and code)
                    //<div id="playbackWindowTab-fileId" class="playbackWindowTab tab-pane fade in">
                    var newPlaybackWindowTab = document.createElement("div");
                    newPlaybackWindowTab.setAttribute("id", "playbackWindowTab-" + fileId);
                    newPlaybackWindowTab.classList.add("playbackWindowTab");
                    newPlaybackWindowTab.classList.add("tab-pane");
                    newPlaybackWindowTab.classList.add("fade");
                    newPlaybackWindowTab.classList.add("in");


                    //create a line number gutter to go in the playbackWindowTab
                    //<div id="lineNumberGutter-fileId" class="lineNumberGutter"><div class='lineNum'></div></div>
                    var lineNumberGutter = document.createElement("div");
                    lineNumberGutter.setAttribute("id", "lineNumberGutter-" + fileId);
                    //add the first line number
                    lineNumberGutter.innerHTML= "<div class='lineNum'></div>";
                    lineNumberGutter.classList.add("lineNumberGutter");

                    //create a playback window
                    //<div id="playbackWindow-fileId" class="playbackWindow">
                    //  <span id="firstSpan-fileId" class="firstSpan"></span>
                    //  <span id="lastSpan-fileId" class="lastSpan">X</span>
                    //</div>
                    var playbackWindow = document.createElement("div");
                    playbackWindow.setAttribute("id", "playbackWindow-" + fileId);
                    playbackWindow.classList.add("playbackWindow");

                    //create a span object that all code events without a previous neighbor id
                    //will back up to (all 'first' code characters have a "none" previous neighbor)
                    var firstSpan = document.createElement("span");
                    firstSpan.setAttribute("id", "firstSpan-" + fileId);
                    firstSpan.classList.add("firstSpan");

                    //create a last span (always hidden) to have a non-empty playback window
                    var lastSpan = document.createElement("span");
                    lastSpan.setAttribute("id", "lastSpan-" + fileId);
                    lastSpan.appendChild(document.createTextNode("X"));
                    lastSpan.classList.add("lastSpan");

                    //add the first and last span
                    playbackWindow.appendChild(firstSpan);
                    playbackWindow.appendChild(lastSpan);

                    //add the elements to the tab
                    newPlaybackWindowTab.appendChild(lineNumberGutter);
                    newPlaybackWindowTab.appendChild(playbackWindow);

                    //add the tab to all the others
                    playbackWindows.appendChild(newPlaybackWindowTab);

                    //add a class to give the tab a hidden style
                    newLink.classList.add("playbackTabNotVisible");

                }//else- the playback wiondow tab already exists, no need to create it again            
            }

            /*
             * Makes a playback window tab active
             */
            function makePlaybackTabActive(fileId) {

                //Link
                //look for an active playback tab link
                var currentlyActiveTabLink = document.querySelector(".playbackWindowLinkListItem.active");

                //if there is no active link OR if the currently active file is different than the passed in one, we need to change the active tab
                if(currentlyActiveTabLink === null || currentlyActiveTabLink.getAttribute("id") !== "playbackWindowLinkListItem-" + fileId) {

                    //if there is an active tab, deactivate it
                    if(currentlyActiveTabLink) {

                        //make the old active tab link inactive
                        currentlyActiveTabLink.classList.remove("active");
                    }

                    //get the link list item to highlight
                    var newTabLinkListItem = document.querySelector("#playbackWindowLinkListItem-" + fileId)

                    //the anchor that allows a user to change tabs is the first child of the list item
                    var newTabAnchor = newTabLinkListItem.children[0];

                    //make the link list item visible by removing the class that hides it
                    newTabAnchor.classList.remove("playbackTabNotVisible");

                    //make the new active tab link active
                    newTabLinkListItem.classList.add("active");


                    //Playback Tab
                    //look for a current active tab
                    var currentlyActivePlayback = document.querySelector(".playbackWindowTab.active");

                    //if there is an active tab
                    if(currentlyActivePlayback) {

                        //make it inactive
                        currentlyActivePlayback.classList.remove("active");
                        currentlyActivePlayback.classList.remove("in");
                    }

                    //get the new tab to activate
                    var newPlaybackWindowTab = document.querySelector("#playbackWindowTab-" + fileId);

                    //make the new tab active
                    newPlaybackWindowTab.classList.add("active");
                    newPlaybackWindowTab.classList.add("in");

                    //store the new active file id
                    playbackData.activeFileId = fileId;

                } //else- the passed in file id is already the active file
            }

            /*
             * Makes a playback window tab visible but not active
             */
            function makePlaybackTabVisible(fileId) {

                //Link
                //get the link list item to highlight
                var tabLinkListItem = document.querySelector("#playbackWindowLinkListItem-" + fileId)

                //the anchor that allows a user to change tabs is the first child of the list item
                var tabAnchor = tabLinkListItem.children[0];

                //make the link list item visible by removing the class that hides it
                tabAnchor.classList.remove("playbackTabNotVisible");
            }

            /*
             * Makes the tab visibilty hidden
             */
            function makePlaybackTabInvisible(fileId) {

                //Link
                //look for a playback tab link with the given file id
                var tabLinkListItem = document.querySelector("#playbackWindowLinkListItem-" + fileId);

                //if there is a link
                if(tabLinkListItem) {

                    //get the anchor (it is the only child of the link list tiem)
                    var tabLinkAnchor = tabLinkListItem.children[0];

                    //make the tab link inactive
                    tabLinkAnchor.classList.add("playbackTabNotVisible");

                    //make the list item not active
                    tabLinkListItem.classList.remove("active");
                }
            }

            /*
             * Go through all of the files in a directory and make their tabs invisible
             */
            function makePlaybackTabsInADirectoryInvisible(directoryId) {

                //go through all of the subdirectories
                for(var dirId in playbackData.allDirs) {
                    if(playbackData.allDirs.hasOwnProperty(dirId)) {

                        //if a directory is unde the current one
                        if(playbackData.allDirs[dirId].parentId === directoryId) {

                            //recurse into the subdirectory
                            makePlaybackTabsInADirectoryInvisible(playbackData.allDirs[dirId].id);
                        }
                    }
                }

                //make all of the files in this directory inactive
                for(var fileId in playbackData.allFiles) {
                    if(playbackData.allFiles.hasOwnProperty(fileId)) {

                        //if a file has this dir as a parent
                        if(playbackData.allFiles[fileId].parentId === directoryId) {

                            //make the tab invisible
                            makePlaybackTabInvisible(playbackData.allFiles[fileId].id);
                        }
                    }
                }
            }

            //*****************************************************************************
            //                Current view of fs during playback related code
            //                -----------------------------------------------
            // This code has to do with manipulating the view of the file system during a
            // playback. This UI element allows a user to see what the fs looked like when
            // the current event happened.
            //*****************************************************************************
            
            //The parentElement is a ul of either list items (li) for each file/dir name or an unordered list (ul)
            //with the contents of a subdirectory. A subdirectory's contents (ul) always comes immediately after the 
            //li with the name. For this sample file system: 
            //testDir
            // -- dir
            // ---- dir2
            // ------ test2.txt
            // ---- test.txt

            //we would see this dom structure:
            //<ul id="playbackViewOfFileSystem" class="playbackViewFileOrDirList">
            //    <!-- /testDir -->
            //    <li id="playbackDirView-dirId-0" class="playbackDirView">
            //        <span class="glyphicon glyphicon-folder-open"></span>
            //        <span class="playbackDirNameLabel">testDir</span>
            //        <ul class="playbackViewFileOrDirList">
            //            <!-- /testDir/dir -->
            //            <li id="playbackDirView-dirId-1" class="playbackDirView">
            //                <span class="glyphicon glyphicon-folder-open"></span>
            //                <span class="playbackDirNameLabel">dir</span>
            //                <ul class="playbackViewFileOrDirList">
            //                    <!-- /testDir/dir/dir2 -->
            //                    <li id="playbackDirView-dirId-2" class="playbackDirView">
            //                        <span class="glyphicon glyphicon-folder-open"></span>
            //                        <span class="playbackDirNameLabel">dir2</span>
            //                        <ul class="playbackViewFileOrDirList">
            //                            <!-- /testDir/dir/dir2/test2.txt -->
            //                            <li id="playbackViewFile-fileId-0" class="playbackFileView">
            //                                <a class="fileLink">
            //                                    <span class="glyphicon glyphicon-file"></span>
            //                                    <span>test2.txt</span>
            //                                </a>
            //                            </li>
            //                        </ul>
            //                    </li>
            //                    <!-- /testDir/dir/test.txt -->
            //                    <li id="playbackViewFile-fileId-1" class="playbackFileView">
            //                        <a class="fileLink">
            //                            <span class="glyphicon glyphicon-file"></span>
            //                            <span>test.txt</span>
            //                         </a>
            //                    </li>
            //                </ul>
            //            </li>
            //        </ul>
            //    </li>
            //</ul>

            /*
             * Adds an entry in the playback view of the filesystem if there isn't already an entry (there may be
             * an entry that is hidden because the playback moved in reverse). If we attempt to add a hidden, present
             * file we remove the hidden class to make it appear to be newly created.
             */
            function addFileToPlaybackViewOfFileSystem(fileName, fileId, parentDirectoryId) {

                //look for an existing file list item
                var fileLI = document.querySelector("#playbackViewFile-" + fileId);

                //if there is an existing list item it is because we previously hid it by going backwards
                if(fileLI) {

                    //show the file again
                    showFileInPlaybackViewOfFileSystem(fileId);

                } else { //this is a brand new file

                    //every file has a parent directory, get the parent dir and the ul that holds the contents
                    var parentOfFile = document.querySelector("#playbackViewDir-" + parentDirectoryId).children[2];
                    
                    //add a file icon
                    var fileIcon = document.createElement("span");
                    fileIcon.innerHTML = "-"
                    //fileIcon.classList.add("glyphicon");
                    //fileIcon.classList.add("glyphicon-file");

                    //create a span to display the file name
                    var fileNameSpan = document.createElement("span");
                    fileNameSpan.innerHTML = fileName;

                    //create a link to make the tab for this file active
                    var fileAnchor = document.createElement("a");
                    fileAnchor.classList.add("fileLink");
                    fileAnchor.addEventListener("click", function(e) {
                        
                        //make the selected file tab active
                        makePlaybackTabActive(fileId);
                    });

                    //add the icon and file name to the anchor
                    fileAnchor.appendChild(fileIcon);
                    fileAnchor.appendChild(fileNameSpan);

                    //add the anchor to a list item
                    fileLI = document.createElement("li");
                    fileLI.setAttribute("id", "playbackViewFile-" + fileId);
                    fileLI.classList.add("playbackFileView");
                    fileLI.appendChild(fileAnchor);

                    //add the file to the correct list
                    parentOfFile.appendChild(fileLI);

                    //<li id="playbackViewFile-fileId-0" class="playbackFileView">
                    //    <a class="fileLink">
                    //       <span class="glyphicon glyphicon-file"></span>
                    //       <span>file name</span>
                    //    </a>
                    //</li>
                }
            }

            /*
             * Adds an entry in the playback view of the filesystem if there isn't already an entry (there may be
             * an entry that is hidden because the playback moved in reverse). If we attempt to add a hidden, present
             * dir we remove the hidden class to make it appear to be newly created.
             */
            function addDirectoryToPlaybackViewOfFileSystem(directoryName, directoryId, parentDirectoryId) {

                //attempt to get the list item for the directory we are trying to add
                var dirLI = document.querySelector("#playbackViewDir-" + directoryId);

                //if it exists it means that it has been hidden because we moved backwards
                if(dirLI) {

                    //show the directory again
                    showDirectoryInPlaybackViewOfFileSystem(directoryId);

                } else { //the directory entry does not exist, we will create it

                    //the parent directory to add the new directory under
                    var parentElement;

                    //if there is a non-empty parent id (it is not the root of the filesystem)
                    if(parentDirectoryId) {

                        //get the li that represents the directory in the existing tree and then get its third child a ul that holds the contents of the dir
                        parentElement = document.querySelector("#playbackViewDir-" + parentDirectoryId).children[2];

                    } else { //empty parent id

                        //use the topmost ul
                        parentElement = document.querySelector("#playbackViewOfFileSystem");
                    }

                    //create a directory icon
                    var dirIcon = document.createElement("span");
                    dirIcon.innerHTML = "+"
                    //dirIcon.classList.add("glyphicon");
                    //dirIcon.classList.add("glyphicon-folder-open");

                    //create a span to hold the dir name
                    var dirNameSpan = document.createElement("span");
                    dirNameSpan.innerHTML = directoryName;
                    dirNameSpan.classList.add("playbackDirNameLabel");

                    //add a new empty unordered list to hold the contents of the directory
                    var newList = document.createElement("ul");
                    newList.classList.add("playbackViewFileOrDirList");

                    //create a li to hold the icon, dir name, and ul for the contents
                    var dirLI = document.createElement("li");
                    dirLI.setAttribute("id", "playbackViewDir-" + directoryId);
                    dirLI.classList.add("playbackDirView");
                    
                    //add the sub-elements
                    dirLI.appendChild(dirIcon);
                    dirLI.appendChild(dirNameSpan);
                    dirLI.appendChild(newList);
                    
                    //add the list items to the parent
                    parentElement.appendChild(dirLI);

                    //<li id="playbackDirView-dirId-0" class="playbackDirView">
                    //    <span class="glyphicon glyphicon-folder-open"></span>
                    //    <span class="playbackDirNameLabel">dir name</span>
                    //    <ul class="playbackViewFileOrDirList"></ul>
                    //</li>
                }
            }

            /*
             * Renames a file in the playback view of the file system
             */
            function renameFileInPlaybackViewOfFileSystem(newFileName, fileId) {

                //get the list item for the file
                var fileLi = document.querySelector("#playbackViewFile-" + fileId);

                //<li id="playbackViewFile-fileId-0" class="playbackFileView">
                //    <a class="fileLink">
                //       <span class="glyphicon glyphicon-file"></span>
                //       <span>file name</span>
                //    </a>
                //</li>

                //every file li has an anchor and an icon and a span as children. The span holds the file name
                fileLi.children[0].children[1].innerHTML = newFileName;
            }

            /*
             * Renames a dir in the playback view of the file system
             */
            function renameDirectoryInPlaybackViewOfFileSystem(directoryName, directoryId) {

                //get the list item that represents the contents of the dir
                var dirLi = document.querySelector("#playbackViewDir-" + directoryId);

                //<li id="playbackDirView-dirId-0" class="playbackDirView">
                //    <span class="glyphicon glyphicon-folder-open"></span>
                //    <span class="playbackDirNameLabel">dir name</span>
                //    <ul class="playbackViewFileOrDirList"></ul>
                //</li>

                //second child of li (a span with the dir name)
                dirLi.children[1].innerHTML = directoryName;
            }

            /*
             * Moves a file in the playback view of the file system
             */
            function moveFileInPlaybackViewOfFileSystem(fileId, newParentDirectoryId) {

                //get the list item for the file
                var fileLi = document.querySelector("#playbackViewFile-" + fileId);

                //<li id="playbackDirView-dirId-0" class="playbackDirView">
                //    <span class="glyphicon glyphicon-folder-open"></span>
                //    <span class="playbackDirNameLabel">dir name</span>
                //    <ul class="playbackViewFileOrDirList">
                //        <li id="playbackViewFile-fileId-0" class="playbackFileView">
                //            <a class="fileLink">
                //                <span class="glyphicon glyphicon-file"></span>
                //                <span>file name</span>
                //            </a>
                //        </li>
                //    </ul>
                //</li>
                
                //remove the file li from the parent
                fileLi.parentElement.removeChild(fileLi);

                //get the new parent
                var newParent = document.querySelector("#playbackViewDir-" + newParentDirectoryId).children[2];

                //add the file li to the new parent
                newParent.appendChild(fileLi);
            }

            /*
             * Moves a dir in the playback view of the file system
             */
            function moveDirectoryInPlaybackViewOfFileSystem(directoryId, newParentDirectoryId) {

                //get the list item for the directory
                var dirLi = document.querySelector("#playbackViewDir-" + directoryId);

                //<li id="playbackDirView-dirId-0" class="playbackDirView">
                //    <span class="glyphicon glyphicon-folder-open"></span>
                //    <span class="playbackDirNameLabel">dir name 0</span>
                //    <ul class="playbackViewFileOrDirList">
                //        <li id="playbackDirView-dirId-1" class="playbackDirView">
                //            <span class="glyphicon glyphicon-folder-open"></span>
                //            <span class="playbackDirNameLabel">dir name 1</span>
                //            <ul class="playbackViewFileOrDirList">
                //            </ul>
                //        </li>
                //    </ul>
                //</li>

                //remove the directory from the parent
                dirLi.parentElement.removeChild(dirLi);

                //get the new parent from the new dir's ul's parent
                var newParent = document.querySelector("#playbackViewDir-" + newParentDirectoryId).children[2];

                //add the file li to the new parent
                newParent.appendChild(dirLi);
            }

            /*
             * Used to hide but not remove a file in the playback view of the file system that has
             * previously been added.
             */
            function hideFileInPlaybackViewOfFileSystem(fileId) {

                //get the list item for the file
                var fileLi = document.querySelector("#playbackViewFile-" + fileId);

                //<li id="playbackViewFile-fileId-0" class="playbackFileView">
                //    <a class="fileLink">
                //       <span class="glyphicon glyphicon-file"></span>
                //       <span>file name</span>
                //    </a>
                //</li>
                
                //add a class to mark it as hidden
                fileLi.classList.add("hiddenFile");
            }

            /*
             * Used to hide but not remove a directory in the playback view of the file system that has
             * previously been added.
             */
            function hideDirectoryInPlaybackViewOfFileSystem(directoryId) {

                //get the list item for the directory
                var dirLi = document.querySelector("#playbackViewDir-" + directoryId);
                
                //<li id="playbackDirView-dirId-0" class="playbackDirView">
                //    <span class="glyphicon glyphicon-folder-open"></span>
                //    <span class="playbackDirNameLabel">dir name</span>
                //    <ul class="playbackViewFileOrDirList"></ul>
                //</li>

                //add a class to mark it as hidden
                dirLi.classList.add("hiddenDirectory");

                //remove the styling for the currently active file/dir
                removeActiveFileOrDirectoryStyling();
            }

            /*
             * Used to show a file in the playback view of the file system that has previously been
             * added and then hidden because of moving backwards.
             */
            function showFileInPlaybackViewOfFileSystem(fileId) {

                //get the list item for the file
                var fileLi = document.querySelector("#playbackViewFile-" + fileId);

                //<li id="playbackViewFile-fileId-0" class="playbackFileView hiddenFile">
                //    <a class="fileLink">
                //       <span class="glyphicon glyphicon-file"></span>
                //       <span>file name</span>
                //    </a>
                //</li>

                //remove the class that hides the file
                fileLi.classList.remove("hiddenFile");
            }

            /*
             * Used to show a directory in the playback view of the file system that has previously been
             * added and then hidden because of moving backwards.
             */
            function showDirectoryInPlaybackViewOfFileSystem(directoryId) {

                //get the list item for the directory
                var dirLi = document.querySelector("#playbackViewDir-" + directoryId);

                //<li id="playbackDirView-dirId-0" class="playbackDirView hiddenDirectory">
                //    <span class="glyphicon glyphicon-folder-open"></span>
                //    <span class="playbackDirNameLabel">dir name</span>
                //    <ul class="playbackViewFileOrDirList"></ul>
                //</li>

                //remove the class that hides the directory
                dirLi.classList.remove("hiddenDirectory");
            }

            /*
             * Removes the activeFileOrDirectory class from any element that is active
             * in the playback view of the file system.
             */
            function removeActiveFileOrDirectoryStyling() {

                //look for the current active file or directory
                var currentActiveFileOrDirectory = document.querySelector(".activeFileOrDirectory");

                //if there is an active file or directory
                if(currentActiveFileOrDirectory) {

                    //remove the class that makes it active
                    currentActiveFileOrDirectory.classList.remove("activeFileOrDirectory");
                }
            }

            /*
             * Adds the activeFileOrDirectory class to a file that is active
             * in the playback view of the file system.
             */
            function addActiveFileStyling(fileId) {

                //look for the current active file or directory
                var currentActiveFileOrDirectory = document.querySelector(".activeFileOrDirectory");

                //if there is no active file or directory
                if(currentActiveFileOrDirectory === null) {

                    //get the list item for the file
                    var fileListItem = document.querySelector("#playbackViewFile-" + fileId);

                    //make the file active
                    fileListItem.classList.add("activeFileOrDirectory");

                } else { //there is an active file or directory

                    //if the active file/dir is different from the passed in file id
                    if(currentActiveFileOrDirectory.getAttribute("id") !== "playbackViewFile-" + fileId) {

                        //remove the current active file or directory
                        removeActiveFileOrDirectoryStyling();

                        //get the list item for the file
                        var fileListItem = document.querySelector("#playbackViewFile-" + fileId);

                        //make the file active
                        fileListItem.classList.add("activeFileOrDirectory");
                    }
                }
            }

            /*
             * Adds the activeFileOrDirectory class to a directory that is active
             * in the playback view of the file system.
             */
            function addActiveDirectoryStyling(dirId) {

                //these don't happen very often so just always remove the old and add the new
                
                //remove the current active file or directory
                removeActiveFileOrDirectoryStyling();

                //get the list item for the directory
                var dirLi = document.querySelector("#playbackViewDir-" + dirId);

                //make the directory active
                dirLi.classList.add("activeFileOrDirectory");
            }

            //*****************************************************************************
            //                          Version control related code
            //                          ----------------------------
            // This code has to do with creating downloadable snapshots of the history 
            // during a playback. These can be used to branch from any point. 
            //*****************************************************************************
            /*
             * This function saves the state of a playback where it is paused. The files/dirs, playbackData.json,
             * and editorState.json are wrapped up in a zip file. This file can be unzipped and a user can build
             * from the pause point in a storyteller editor.
             * 
             * There are three types of 'saves' that store different event info in playbackData.json:
             * - getPlaybackDataMinimumHistory: in this case only the code that is present on the screen at the pause 
             *     point is added to the playbackData.json file. All of the code that was added and then deleted up to
             *     the pause point is stripped and will not be in the zip.
             * - getPlaybackDataNoFutureEvents: in this case all of the code up to the pause point is added to the
             *     playbackData.json file but no events after the pause point will be present. All of the code on the
             *     screen and all of the inserts that were deleted up to the pause point will be part of the history. 
             * - getPlaybackDataFutureEventsUndone: in this case all of the code up to the pause point and beyod is
             *     added to the playbackData.json file. However, the events after the pause point are 'undone' using 
             *     the inverse of each event after the pause point. 
             */
            function saveStateOfPlaybackAtPausePoint(typeOfSave) {
                
                //get all of the playback data (map of insert events on screen, allFiles, allDirs, allDevGroups, etc)
                var playbackDataOnScreenAtPausePoint = getAllPlaybackDataOnScreenAtPausePoint();

                //get the current view of the file system (all files and dirs on the screen at the pause point)
                var rootfileSystemViewAtPausePoint = getCurrentStateOfFileSystem(playbackDataOnScreenAtPausePoint.allInsertEvents);

                //get the editor state info (pathIdMap, allInsertEventsByFile, autoGeneratedEventId, etc.)
                var editorStateJson = getEditorState(rootfileSystemViewAtPausePoint, playbackDataOnScreenAtPausePoint);
                
                //get the name of the root of the project
                var rootDirName = rootfileSystemViewAtPausePoint[0].dirName;

                //for creating a zip
                var zip = new JSZip();

                //create a saved representation of the files/dirs in the file system in the zip
                zipUpCurrentStateOfFiles(rootfileSystemViewAtPausePoint, zip);
                
                //create a representation of the playback data and add it to the zip
                zipUpPlaybackData(rootfileSystemViewAtPausePoint, rootDirName, editorStateJson, playbackDataOnScreenAtPausePoint, zip, typeOfSave);

                //create a representation of the editor state and add it to the zip
                zipUpEditorState(rootDirName, editorStateJson, zip);
                
                //build the zip and make it downloadable
                buildZip(rootDirName, zip);
            }

            /*
             * This function scans the events in a playback by going through all the events from the first up to the point 
             * where it was paused (up to and including the event at index playbackData.codeEventsIndexGets) and collects 
             * data about the contribution up to that point. 
             * 
             * The data that is collected is:
             * - allInsertEvents: a map of all the insert events that are visible up to the point where the playback was paused
             * - allFiles: holds the files in the played back portion of the playback
             * - allDirs: holds the dirs in the played back portion of the playback
             * - allDeveloperGroups: holds the dev groups in the played back portion of the playback
             * - allDevelopers: holds the devs in the played back portion of the playback
             * - comments: holds the comments in the played back portion of the playback
             * - allInsertAndCreateComments: holds the comments associated with visible insert events in the played back portion of the playback
             * - allCreateFileEvents: holds all of the create file events up to the pause point
             * - allCreateDirEvents: holds all of the create dir events up to the pause point
             */
            function getAllPlaybackDataOnScreenAtPausePoint() {

                //object with the playback data up to the pause point
                var playedEventInfo = {
                    allInsertEvents: {},            //holds all the insert events that are visible up to the point where the playback was paused
                    allCreateFileEvents: {},        //holds all of the create file events up to the pause point (used for perfect programmer playback)
                    allCreateDirEvents: {},         //holds all of the create dir events up to the pause point (used for perfect programmer playback)
                    allFiles: {},                   //holds the files in the played back portion of the playback
                    allDirs: {},                    //holds the dirs in the played back portion of the playback
                    allDeveloperGroups: {},         //holds the dev groups in the played back portion of the playback
                    allDevelopers: {},              //holds the devs in the played back portion of the playback
                    comments: {},                   //holds the comments in the played back portion of the playback
                    allInsertAndCreateComments: {}  //holds the comments associated with insert events in the played back portion of the playback
                }

                //depending on the type of playback we are storing the current dev group might not have made any contributions yet. We want to make sure the 
                //current dev group is present because when this project is opened we want to attribute any new events to the current dev group
                //add the current dev group and its members to the object
                addDeveloperGroupAndDevelopersToObject(playedEventInfo, playbackData.currentDevGroupId);


                //go through all of the events up to the pause point in the playback
                for(var i = 0;i <= playbackData.codeEventsIndex;i++) {

                    //the current event in the playback
                    var currentEvent = playbackData.codeEvents[i];


                    //if the event's dev group is not currently being stored
                    if(!playedEventInfo.allDeveloperGroups[currentEvent.createdByDevGroupId]) {
                        
                        //add the dev group and its members to the object
                        addDeveloperGroupAndDevelopersToObject(playedEventInfo, currentEvent.createdByDevGroupId);
                    }

                    //every event may also have a comment
                    //if there is a comment for this event 
                    if(playbackData.comments[currentEvent.id]) {

                        //store the array of comments to the collection that will go in the zipped playback data
                        playedEventInfo.comments[currentEvent.id] = playbackData.comments[currentEvent.id];
                    } 
                    
                    //event specific checks
                    //if this is an insert
                    if(currentEvent.type === "Insert") {

                        //make a copy of the current event (some of these properties may be changed by the code that uses this)
                        var minimalInsertEvent = {
                            id: currentEvent.id,
                            timestamp: currentEvent.timestamp,
                            type: currentEvent.type,
                            character: currentEvent.character,
                            previousNeighborId: currentEvent.previousNeighborId,
                            createdByDevGroupId: currentEvent.createdByDevGroupId,
                            lineNumber: currentEvent.lineNumber,
                            column: currentEvent.column,
                            fileId: currentEvent.fileId,
                        };

                        //get the span on the screen for this event
                        var codeSpan = document.querySelector("#" + minimalInsertEvent.id);

                        //if this insert is still on the screen
                        if(codeSpan.classList.contains("codeChar") && !codeSpan.classList.contains("codeNotVisible")) {

                            //store the insert event keyed by the event id and store the event
                            playedEventInfo.allInsertEvents[minimalInsertEvent.id] = minimalInsertEvent;

                            //if there is a comment for this insert event 
                            if(playbackData.comments[minimalInsertEvent.id]) {

                                //store the array of comments to the collection that will go in the zipped playback data
                                playedEventInfo.allInsertAndCreateComments[minimalInsertEvent.id] = playbackData.comments[minimalInsertEvent.id];
                            }
                        }
                        
                    } else if(currentEvent.type === "Create File") { //create file

                        //make a copy of the current event (some of these properties may be changed by the code that uses this)
                        var minimalCreateFileEvent = {
                            id: currentEvent.id,
                            timestamp: currentEvent.timestamp,
                            type: currentEvent.type,
                            initialName: currentEvent.initialName,
                            fileId: currentEvent.fileId,
                            parentDirectoryId: currentEvent.parentDirectoryId,
                            createdByDevGroupId: currentEvent.createdByDevGroupId
                        };

                        //if this file has not been recorded
                        if(!playedEventInfo.allFiles[minimalCreateFileEvent.fileId]) {

                            //create a file entry for this new file using the event info
                            var newFile = {
                                id: currentEvent.fileId,
                                parentId: currentEvent.parentDirectoryId,
                                currentName: currentEvent.initialName,
                                isDeleted: false
                            };

                            //store the file
                            playedEventInfo.allFiles[minimalCreateFileEvent.fileId] = newFile;
                        }

                        //store the create file event
                        playedEventInfo.allCreateFileEvents[minimalCreateFileEvent.fileId] = minimalCreateFileEvent;

                        //if there is a comment for this create file event 
                        if(playbackData.comments[minimalCreateFileEvent.id]) {

                            //store the array of comments to the collection that will go in the zipped playback data
                            playedEventInfo.allInsertAndCreateComments[minimalCreateFileEvent.id] = playbackData.comments[minimalCreateFileEvent.id];
                        }
                        
                    } else if(currentEvent.type === "Create Directory") { //create dir

                        //make a copy of the current event (some of these properties may be changed by the code that uses this)
                        var minimalCreateDirEvent = {
                            id: currentEvent.id,
                            timestamp: currentEvent.timestamp,
                            type: currentEvent.type,
                            initialName: currentEvent.initialName,
                            directoryId: currentEvent.directoryId,
                            parentDirectoryId: currentEvent.parentDirectoryId,
                            createdByDevGroupId: currentEvent.createdByDevGroupId
                        };

                        //if this dir has not been recorded
                        if(!playedEventInfo.allDirs[minimalCreateDirEvent.directoryId]) {

                            //create a file entry for this new file using the event info
                            var newDirectory = {
                                id: currentEvent.directoryId,
                                parentId: currentEvent.parentDirectoryId,
                                currentName: currentEvent.initialName,
                                isDeleted: false
                            };

                            //store the dir id
                            playedEventInfo.allDirs[minimalCreateDirEvent.directoryId] = newDirectory;
                        }

                        //store the create dir event
                        playedEventInfo.allCreateDirEvents[minimalCreateDirEvent.directoryId] = minimalCreateDirEvent;          

                        //if there is a comment for this create dir event 
                        if(playbackData.comments[minimalCreateDirEvent.id]) {

                            //store the array of comments to the collection that will go in the zipped playback data
                            playedEventInfo.allInsertAndCreateComments[minimalCreateDirEvent.id] = playbackData.comments[minimalCreateDirEvent.id];
                        }              
                    }
                }

                return playedEventInfo;
            } 
            
            /*
             * Adds a developer group to an object if it isn't already present. It will also add each developer in the group to the object.
             */
            function addDeveloperGroupAndDevelopersToObject(playedEventInfo, devGroupId) {
                
                //get the dev group based on the id
                var devGroup = playbackData.allDeveloperGroups[devGroupId];

                //if the dev group was found
                if(devGroup) {

                    //store the dev group
                    playedEventInfo.allDeveloperGroups[devGroupId] = devGroup;

                    //get the memberIds in the dev group
                    var memberIdsInADevGroup = devGroup.memberIds;

                    //go through all of the memberIds 
                    for(var i = 0;i < memberIdsInADevGroup.length;i++) {

                        //get a member id from the dev group
                        var devIdInADevGroup = memberIdsInADevGroup[i];

                        //store the dev
                        playedEventInfo.allDevelopers[devIdInADevGroup] = playbackData.allDevelopers[devIdInADevGroup];
                    }

                }//else- dev group was not found
            }

            /*
             * This function gets the current state of the files and dirs in a playback. An array
             * of directory objects is returned that holds the single root dir. A dir object looks
             * like this: 
             * 
             * var currentDir = {
             *     dirId: dirId,       //id of the dir
             *     dirName: dirName,   //name of the dir
             *     dirPath: dirPath,   //path of the dir
             *     parentDirectoryId: "",    //id of the parent dir
             *     subDirs: [],        //list of all sub dirs (gets filled in after the recursive call)
             *     files: [],          //list of all files in the dir (gets filled in after the recursive call)
             * };
             * 
             * The array subDirs holds more child sub-directories. The array files holds the files in a dir. A
             * file object looks like this:
             *  var file = {
             *      fileId: fileId,          //id of the file
             *      fileName: fileName,      //name of the file
             *      filePath: filePath,      //path of the file
             *      parentDirectoryId: "",   //id of the parent dir
             *      insertsByPosition: [[]]  //all events in a file by position (a group of rows)
             * };
             */
            function getCurrentStateOfFileSystem(allInsertEventsOnTheScreen) {

                //get the html element that represents the active files/dirs that are in the 
                //current state of the playback (a ul with id playbackViewOfFileSystem)
                parentElement = document.querySelector("#playbackViewOfFileSystem");

                //contents of the dir that holds the root dir        
                var contentsWithRoot = [];

                //traverse the dom to get the state of the file system
                getCurrentStateOfFileSystemHelper(parentElement, "", contentsWithRoot, allInsertEventsOnTheScreen);

                //return the contents of the file system at this point
                return contentsWithRoot;
            }

            /*
             * Recursive helper that goes through the dom identifying files and dirs.
             */
            function getCurrentStateOfFileSystemHelper(parentElement, pathUpToParent, contents, allInsertEventsOnTheScreen) {

                //go through all of the children of the parent element (a ul with the contents of a dir)
                for(var i = 0;i < parentElement.children.length;i++) {

                    //the types we care about are playbackDirView and playbackFileView

                    //if the child li is a directory that is not hidden
                    if(parentElement.children[i].classList.contains("playbackDirView") && 
                       !parentElement.children[i].classList.contains("hiddenDirectory")) {  
                           
                        //every dir has an li in the playback view of the file system
                        var dirLi = parentElement.children[i];

                        //the dir name is the second child in the li
                        var dirName = dirLi.children[1].innerHTML;

                        //construct a relative path to the dir
                        var dirPath = pathUpToParent + "/" + dirName;
                        
                        //extract the dir id from the li
                        var dirId = dirLi.id.substr("playbackDirView-".length);

                        //build a dir object
                        var currentDir = {
                            dirId: dirId,           //id of the dir
                            dirName: dirName,       //name of the dir
                            dirPath: dirPath,       //path of the dir
                            parentDirectoryId: "",  //id of the parent
                            subDirs: [],            //list of all sub dirs (gets filled in after the recursive call)
                            files: [],              //list of all files in the dir (gets filled in after the recursive call)
                            contents: []            //list of all sub dirs and files (used to fill subDirs and files after the recursive call then deleted)
                        }; 

                        //add the dir object to the contents of the parent dir
                        contents.push(currentDir);

                        //every dir li's third child is a ul with the contents of the dir
                        var dirContentsUl = parentElement.children[i].children[2]; 

                        //recurse 
                        getCurrentStateOfFileSystemHelper(dirContentsUl, dirPath, currentDir.contents, allInsertEventsOnTheScreen);


                        //after the recursive call go through the contents of a directory and:
                        // - assign the parent dir id
                        // - move each file object to the 'files' array
                        // - move each sub dir object to the 'subDirs' array
                        //then remove the contents object altogether
                        //for every file/dir in contents
                        for(var j = 0;j < currentDir.contents.length;j++) {
                            
                            //if there is a 'dirId' property in the object then it is a directory
                            if(currentDir.contents[j]["dirId"]) {
                                
                                //get the dir object
                                var subDir = currentDir.contents[j];

                                //set the child's parent id to the current dir's id
                                subDir.parentDirectoryId = currentDir.dirId;

                                //move the sub dir to the current dir's subDirs array
                                currentDir.subDirs.push(subDir);

                            } else { //no dirId, it must be a file
                                
                                //get the file object
                                var file = currentDir.contents[j];

                                //set the child's parent id to the current dir's id
                                file.parentDirectoryId = currentDir.dirId;

                                //move the file to the current dir's files array
                                currentDir.files.push(file);
                            }
                        }

                        //get rid of the contents since they have all been moved to files and subDirs
                        delete currentDir.contents;

                    } else if(parentElement.children[i].classList.contains("playbackFileView") && //file name list item AND not hidden
                              !parentElement.children[i].classList.contains("hiddenFile")) {                                                    

                        //every file has an li in the playback view of the file system 
                        var fileLi = parentElement.children[i];

                        //the file name is inside an anchor and then the first child (a span with an icon (0) and a text name(1))
                        var fileName = fileLi.children[0].children[1].innerHTML;

                        //construct a relative path to the file
                        var filePath = pathUpToParent + "/" + fileName;

                        //the li has the id of the file in it, extract it and use it to get the id of the playback window
                        var fileId = fileLi.id.substr("playbackViewFile-".length);

                        //build a file object
                        var file = {
                            fileId: fileId,         //id of the file
                            fileName: fileName,     //name of the file
                            filePath: filePath,     //path of the file
                            parentDirectoryId: "",  //id of the parent dir
                            insertsByPosition: [[]] //all events in a file by position (a group of rows)
                        };
                        
                        //get the id of the playback window
                        var playbackWindowId = "playbackWindow-" + file.fileId;

                        //get the playback window associated with the file
                        var playbackWindow = document.querySelector("#" + playbackWindowId);

                        //holds the current row number
                        var row = 0;

                        //go through all the child elements (spans with code in them) in the playback window
                        for(var j = 0;j < playbackWindow.children.length;j++) {
                            
                            //a visible span that has a code character in it
                            var visibleCodeSpan = playbackWindow.children[j];

                            //if a child element is a code char (code, space, newline, or tab) AND
                            //is currently on the screen (not hidden)
                            if(visibleCodeSpan.classList.contains("codeChar") && !visibleCodeSpan.classList.contains("codeNotVisible")) {

                                //get the id of the span which matches the insert event's id
                                var eventId = visibleCodeSpan.getAttribute("id");

                                //use the event id to get the actual event from the map of visible events
                                var event = allInsertEventsOnTheScreen[eventId];

                                //store the event positionally in the correct row and column that it occupies on the screen
                                file.insertsByPosition[row].push(event);

	                            //if the code character is a newline
                                if(visibleCodeSpan.classList.contains("newLine")) {

                                    //moving to a new row
                                    row++;

                                    //add a new empty array for events
                                    file.insertsByPosition.push([]);
                                }
                            } 
                        }

                        //add it to the contents of the parent dir
                        contents.push(file);
                    }
                }
            }

            /*
             * This function gets the data necessary for the editorState.json file from the pause point. It uses
             * the view of the file system to create the pathToIdMap and the inserts by file map. Then it calculates
             * the auto generated numbers that are needed to assign ids.
             */
            function getEditorState(rootfileSystemViewAtPausePoint, playbackDataOnScreenAtPausePoint) {
                
                //editor state info needed for the editor to be able to work with the data in this zip file
                var editorStateJson = {
                    pathToIdMap: {},
                    allInsertEventsByFile: {},
                    autoGeneratedEventId: -1,
                    autoGeneratedFileId: -1,
                    autoGeneratedDirId: -1,
                    autoGeneratedDeveloperId: -1,
                    autoGeneratedDeveloperGroupId: -1,
                };

                //get the pathToIdMap data that goes in the editor state file
                getCurrentPathToIdMap(rootfileSystemViewAtPausePoint, editorStateJson);

                //get the insert events
                getAllInsertEventsByFile(rootfileSystemViewAtPausePoint, editorStateJson);
                
                //get the rest of the data in editorStateJson 
                getGeneratedValuesForEditorState(editorStateJson, playbackDataOnScreenAtPausePoint);

                return editorStateJson;
            }

            /*
             * This function gets the data for the pathToIdMap up to a point in a playback that will go in the editor state 
             */
            function getCurrentPathToIdMap(fileSystemViewAtPausePoint, editorStateJson) {

                //go through the contents of a dir
                for(var i = 0;i < fileSystemViewAtPausePoint.length;i++) {
                    
                    //get a directory
                    var dir = fileSystemViewAtPausePoint[i];

                    //strip the first part of the path, /rootOfProject, from the dir path
                    var alteredDirPath = stripRootFromPath(dir.dirPath);

                    //all dirs in pathToIdMap should end with a slash, if there is not one add it here
                    if(alteredDirPath[alteredDirPath.length - 1] !== "/") {

                        //add a trailing slash if needed
                        alteredDirPath = alteredDirPath + "/";
                    }

                    //store the path to id mapping
                    editorStateJson.pathToIdMap[alteredDirPath] = dir.dirId; 

                    //go through all the files in the dir
                    for(var j = 0;j < dir.files.length;j++) {
                        
                        //get a file from the dir
                        var file = dir.files[j];

                        //strip the first part of the path, /rootOfProject, from the file path
                        var alteredFilePath = stripRootFromPath(file.filePath);

                        //store the path to id mapping
                        editorStateJson.pathToIdMap[alteredFilePath] = file.fileId;
                    } 

                    //recurse
                    getCurrentPathToIdMap(dir.subDirs, editorStateJson);
                }
            }

            /*
             * Removes the root dir from a path. Stripping the root from the relative path is needed in the pathToIdMap.
             */
            function stripRootFromPath(path) {

                //get the position of the second path seperator in the path (first char should be a path separator, 
                //so start looking after the first char)
                var posOfSecondPathSeparator = path.indexOf("/", 1);

                //strip the first part of the path, /rootOfProject, from the dir path
                var alteredPath;
                
                //if there is no second path separator this is just the root
                if(posOfSecondPathSeparator === -1) {

                    //store just the path separator to indicate the root
                    alteredPath = "/";

                } else { //there is a second path separator

                    //get everything but the root
                    alteredPath = path.substr(posOfSecondPathSeparator);
                }

                return alteredPath;
            }

            /*
             * This function gets the data for the allInsertEventsByFile up to a point in a playback that will go in the editor state
             */
            function getAllInsertEventsByFile(fileSystemViewAtPausePoint, editorStateJson) {

                //go through the contents of a dir
                for(var i = 0;i < fileSystemViewAtPausePoint.length;i++) {
                    
                    //get a directory
                    var dir = fileSystemViewAtPausePoint[i];

                    //go through all the files in the dir
                    for(var j = 0;j < dir.files.length;j++) {
                        
                        //get a file from the dir
                        var file = dir.files[j];

                        //create a shadow 2D array of the file's file.insertsByPosition
                        var minimalInsertsByPosition = [];

                        //each file has its insert events, go through them
                        for(var row = 0;row < file.insertsByPosition.length;row++) {

                            //add an empty row
                            minimalInsertsByPosition.push([]);

                            //go through all of the full events in the row
                            for(var col = 0;col < file.insertsByPosition[row].length;col++) {
                                
                                //create a smaller version of the insert event (this matches what gets stored by the editor)
                                var minimalEvent = {
                                    id: file.insertsByPosition[row][col].id,
                                    character: file.insertsByPosition[row][col].character
                                };

                                //add it to the shadow array
                                minimalInsertsByPosition[row].push(minimalEvent);
                            }
                        }

                        //store the events for the file
                        editorStateJson.allInsertEventsByFile[file.fileId] = minimalInsertsByPosition;
                    } 
                    
                    //recurse
                    getAllInsertEventsByFile(dir.subDirs, editorStateJson)
                }
            }

            /*
             * This function looks at the playback data to get valid numbers for the autogenerated values in the editor:
             * - autoGeneratedEventId
             * - autoGeneratedFileId
             * - autoGeneratedDirId
             * - autoGeneratedDeveloperId
             * - autoGeneratedDeveloperGroupId
             */
            function getGeneratedValuesForEditorState(editorStateJson, playbackDataOnScreenAtPausePoint) {
                
                //autoGeneratedEventId
                //if no events have been played back
                if(playbackData.codeEventsIndex === -1) {

                    //set the next valid id to be 0
                    editorStateJson.autoGeneratedEventId = 0;
    
                } else { //there is at least one event played
    
                    //get the id of the last event played back
                    var lastPlaybackEvent = playbackData.codeEvents[playbackData.codeEventsIndex];
                    
                    //pick out the number at the end of the id
                    var lastEventIntId = parseInt(lastPlaybackEvent.id.substr("ev_".length), 10);
                    
                    //add one for the next valid auto generated number
                    editorStateJson.autoGeneratedEventId = lastEventIntId + 1;
                }


                //autoGeneratedFileId
                //largest int part of an id
                var largestFileIntId = 0;

                //go through all of the files
                for(var fileId in playbackDataOnScreenAtPausePoint.allFiles) {
                    if(playbackDataOnScreenAtPausePoint.allFiles.hasOwnProperty(fileId)) {

                        //pick out the number at the end of the id
                        var fileIntId = parseInt(fileId.substr("fileId-".length), 10);

                        //if the latest id is the largest so far
                        if(fileIntId > largestFileIntId) {

                            //store it as the largest
                            largestFileIntId = fileIntId;
                        }
                    }
                }

                //add one for the next valid auto generated number
                editorStateJson.autoGeneratedFileId = largestFileIntId + 1;


                //autoGeneratedDirId
                //largest int part of an id
                var largestDirIntId = 0;

                //go through all of the dirs
                for(var dirId in playbackDataOnScreenAtPausePoint.allDirs) {
                    if(playbackDataOnScreenAtPausePoint.allDirs.hasOwnProperty(dirId)) {

                        //pick out the number at the end of the id
                        var dirIntId = parseInt(dirId.substr("dirId-".length), 10);

                        //if the latest id is the largest so far
                        if(dirIntId > largestDirIntId) {

                            //store it as the largest
                            largestDirIntId = dirIntId;
                        }
                    }
                }

                //add one for the next valid auto generated number
                editorStateJson.autoGeneratedDirId = largestDirIntId + 1;


                //autoGeneratedDeveloperId
                //largest int part of an id
                var largestDevIntId = 0;

                //go through all of the devs
                for(var devId in playbackDataOnScreenAtPausePoint.allDevelopers) {
                    if(playbackDataOnScreenAtPausePoint.allDevelopers.hasOwnProperty(devId)) {

                        //pick out the number at the end of the id
                        var devIntId = parseInt(devId.substr("devId-".length), 10);

                        //if the latest id is the largest so far
                        if(devIntId > largestDevIntId) {

                            //store it as the largest
                            largestDevIntId = devIntId;
                        }
                    }
                }
                
                //add one for the next valid auto generated number
                editorStateJson.autoGeneratedDeveloperId = largestDevIntId + 1;


                //autoGeneratedDeveloperGroupId
                //largest int part of an id
                var largestDevGroupIntId = 0;

                //go through all of the devs
                for(var devGroupId in playbackDataOnScreenAtPausePoint.allDeveloperGroups) {
                    if(playbackDataOnScreenAtPausePoint.allDeveloperGroups.hasOwnProperty(devGroupId)) {
                
                        //get the dev group
                        var devGroup = playbackDataOnScreenAtPausePoint.allDeveloperGroups[devGroupId];

                        //pick out the number at the end of the id
                        var devGroupIntId = parseInt(devGroup.id.substr("devGroupId-".length), 10);

                        //if the latest id is the largest so far
                        if(devGroupIntId > largestDevGroupIntId) {

                            //store it as the largest
                            largestDevGroupIntId = devGroupIntId;
                        }
                    }
                }

                //add one for the next valid auto generated number
                editorStateJson.autoGeneratedDeveloperGroupId = largestDevGroupIntId + 1;
            }

            /*
             * Saves the state of the files/dirs at a certain point in a zip. The file/dir contents are gathered 
             * and added to a zip with the same file structure as the playback view.
             */
            function zipUpCurrentStateOfFiles(fileSystemViewAtPausePoint, zip) {

                //go through the contents of a dir
                for(var i = 0;i < fileSystemViewAtPausePoint.length;i++) {
                    
                    //get a directory
                    var dir = fileSystemViewAtPausePoint[i];

                    //create the folder in the zip (if it doesn't already exist)
                    zip.folder(dir.dirPath);

                    //go through all the files in the dir
                    for(var j = 0;j < dir.files.length;j++) {
                        
                        //get a file from the dir
                        var file = dir.files[j];

                        //holds the text in the file at the current point in the playback
                        var text = "";

                        //each file has its insert events, go through them
                        for(var row = 0;row < file.insertsByPosition.length;row++) {
                            for(var col = 0;col < file.insertsByPosition[row].length;col++) {

                                //add the code character to the text
                                text += file.insertsByPosition[row][col].character;
                            }
                        }

                        //add the text to a zip file
                        zip.file(file.filePath, text);
                    }

                    //recurse
                    zipUpCurrentStateOfFiles(dir.subDirs, zip);
                }
            }

            /*
             * Records all of the playback data for the playbackData.json file and zips it up. A playback may be
             * paused at any point in the middle and the user is given three options for storing the playback data:
             * - minimal history: all history is forgotten except for the code on the screen
             * - no future events: all history up to the pause point is maintained but any history after the pause point is abandoned
             * - future events undone: all history is maintained even events after the pause point but those future events are undone
             * 
             * The choice the user makes decides how mucgh history will be stored in any future development. 
             */
            function zipUpPlaybackData(fileSystemViewAtPausePoint, rootDirName, editorStateJson, playbackDataOnScreenAtPausePoint, zip, typeOfSave) {
                
                //empty object to hold playback data
                var playbackDataJson = {
                    codeEvents: [],
                    allDevelopers: {}, 
                    allDeveloperGroups: {},
                    allFiles: {},
                    allDirs: {},
                    currentDevGroupId: null,
                    comments: {}
                }; 

                //if this is a minimum history request
                if(typeOfSave === "minimal") {

                    //fill the playback data with the state required at the pause point
                    //only events on the screen and no past history- perfect programmer
                    getPlaybackDataMinimumHistory(playbackDataJson, fileSystemViewAtPausePoint, playbackDataOnScreenAtPausePoint);

                } else if (typeOfSave === "upToPausePoint") { //no future events request

                    //fill the playback data with the state required at the pause point
                    //only events up to the pause point including any past mistakes/changes but nothing beyond the pause point 
                    getPlaybackDataNoFutureEvents(playbackDataJson, playbackDataOnScreenAtPausePoint);
    
                } else { //typeOfSave === "full" all events with future events undone
    
                    //fill the playback data with the state required at the pause point
                    //all the history before and after the pause point with the events afterwar undone by inverse events
                    //inverse of insert is a delete, inverse of a create file is a delete file, etc.
                    getPlaybackDataFutureEventsUndone(playbackDataJson, editorStateJson);
                }

                //all code events that are stored on the disk should be compressed

                //compress the code events
                playbackDataJson.codeEvents = compressEvents(playbackDataJson.codeEvents);

                //create the hidden storyteller files and add them to the zip
                zip.file("/" + rootDirName + "/.storyteller/playbackData.json", JSON.stringify(playbackDataJson));
            }
            
            /*
             * Get the playback data with the minimal amount of history. This function gets the events for only
             * create file/dirs and inserts. All of the create dir events come first the create file events to build 
             * the file structure. Next, the events for each file are added.
             */
            function getPlaybackDataMinimumHistory(playbackDataJson, fileSystemViewAtPausePoint, playbackDataOnScreenAtPausePoint) {
                
                //playbackDataJson.codeEvents
                //create the create file/dir events for the files and dirs that exist
                var createDirEvents = [];
                getCreateDirEventsHelper(fileSystemViewAtPausePoint, createDirEvents, playbackDataOnScreenAtPausePoint.allCreateDirEvents);

                var createFileEvents = [];
                getCreateFileEventsHelper(fileSystemViewAtPausePoint, createDirEvents, playbackDataOnScreenAtPausePoint.allCreateFileEvents);

                //add the events on the screen and adjust their previous neighbor to be in order
                var insertEvents = [];
                getAllInsertEventsHelper(fileSystemViewAtPausePoint, insertEvents);

                //add all the events- create dirs, create files, and inserts to the playback object
                playbackDataJson.codeEvents = createDirEvents.concat(createFileEvents, insertEvents);

                //playbackDataJson.allDevelopers
                playbackDataJson.allDevelopers = playbackDataOnScreenAtPausePoint.allDevelopers;

                //playbackDataJson.allDeveloperGroups
                playbackDataJson.allDeveloperGroups = playbackDataOnScreenAtPausePoint.allDeveloperGroups;

                //playbackDataJson.allFiles
                playbackDataJson.allFiles = playbackDataOnScreenAtPausePoint.allFiles;
                
                //playbackDataJson.allDirs
                playbackDataJson.allDirs = playbackDataOnScreenAtPausePoint.allDirs;

                //playbackDataJson.currentDevGroupId
                playbackDataJson.currentDevGroupId = playbackData.currentDevGroupId;

                //playbackDataJson.comments    
                //only add the comments that are associated with the inserts/create file/create dir            
                playbackDataJson.comments = playbackDataOnScreenAtPausePoint.allInsertAndCreateComments;
            }
            
            /*
             * Gather all of the create dir events for the dirs that were present at the pause point.
             */
            function getCreateDirEventsHelper(fileSystemViewAtPausePoint, createDirEvents, allCreateDirEvents) {
                
                //go through the contents of a dir
                for(var i = 0;i < fileSystemViewAtPausePoint.length;i++) {
                    
                    //get a directory
                    var dir = fileSystemViewAtPausePoint[i];

                    //get the original create directory event
                    var createDirEvent = allCreateDirEvents[dir.dirId];

                    //rewrite the name and parent in case the dir moved or changed since creation 
                    createDirEvent.initialName = dir.dirName;
                    createDirEvent.parentDirectoryId = dir.parentDirectoryId;

                    //add the updated create dir event to the list
                    createDirEvents.push(createDirEvent);
                    
                    //recurse
                    getCreateDirEventsHelper(dir.subDirs, createDirEvents, allCreateDirEvents);
                }
            }

            /*
             * Gather all of the create file events for the files that were present at the pause point.
             */
            function getCreateFileEventsHelper(fileSystemViewAtPausePoint, createFileEvents, allCreateFileEvents) {
                
                //go through the contents of a dir
                for(var i = 0;i < fileSystemViewAtPausePoint.length;i++) {
                    
                    //get a directory
                    var dir = fileSystemViewAtPausePoint[i];

                    //go through all of the files in the directory
                    for(var j = 0;j < dir.files.length;j++) {

                        //get the file
                        var file = dir.files[j];

                        //get the original create file event
                        var createFileEvent = allCreateFileEvents[file.fileId];

                        //rewrite the name and parent in case the file moved or changed since creation 
                        createFileEvent.initialName = file.fileName;
                        createFileEvent.parentDirectoryId = file.parentDirectoryId;

                        //add the updated create file event to the list
                        createFileEvents.push(createFileEvent);
                    }
                    
                    //recurse
                    getCreateFileEventsHelper(dir.subDirs, createFileEvents, allCreateFileEvents);
                }
            }

            /*
             * Gather all of the insert events for the files that were present at the pause point. Each event will 
             * will get rewritten to back up to the event that is directly behind it on the screen. This will 
             * effectively erase all of the history in between the events on the screen.
             */
            function getAllInsertEventsHelper(fileSystemViewAtPausePoint, insertEvents) {
                
                //go through the contents of a dir
                for(var i = 0;i < fileSystemViewAtPausePoint.length;i++) {
                    
                    //get a directory
                    var dir = fileSystemViewAtPausePoint[i];

                    //go through all of the files in the directory
                    for(var j = 0;j < dir.files.length;j++) {

                        //get the file
                        var file = dir.files[j];

                        //holds the id of the previous neighbor (first in the file is "none")
                        var previousNeighborId = "none";

                        //go through all of the events in the file
                        for(var row = 0;row < file.insertsByPosition.length;row++) {
                            for(var col = 0;col < file.insertsByPosition[row].length;col++) {
                                
                                //get the event
                                var event = file.insertsByPosition[row][col];

                                //make each event on the screen refer to the one before it
                                event.previousNeighborId = previousNeighborId;

                                //update the location
                                event.lineNumber = row + 1;
                                event.column = col + 1;

                                //add the event to the list of all events
                                insertEvents.push(event);

                                //set the prev neighbor to this event's id
                                previousNeighborId = event.id; 
                            }
                        }                        
                    }
                    
                    //recurse
                    getAllInsertEventsHelper(dir.subDirs, insertEvents);
                }                
            }

            /*
             * Get all the events from the beginning up to the pause point. All events after the pause point
             * (and the history that goes with them) is gone forever.
             */
            function getPlaybackDataNoFutureEvents(playbackDataJson, playbackDataOnScreenAtPausePoint) {
                
                //playbackDataJson.codeEvents
                //grab all of the events up to the pause point
                playbackDataJson.codeEvents = playbackData.codeEvents.slice(0, playbackData.codeEventsIndex + 1);

                //playbackDataJson.allDevelopers
                playbackDataJson.allDevelopers = playbackDataOnScreenAtPausePoint.allDevelopers;

                //playbackDataJson.allDeveloperGroups
                playbackDataJson.allDeveloperGroups = playbackDataOnScreenAtPausePoint.allDeveloperGroups;

                //playbackDataJson.allFiles
                playbackDataJson.allFiles = playbackDataOnScreenAtPausePoint.allFiles;
                
                //playbackDataJson.allDirs
                playbackDataJson.allDirs = playbackDataOnScreenAtPausePoint.allDirs;

                //playbackDataJson.currentDevGroupId
                playbackDataJson.currentDevGroupId = playbackData.currentDevGroupId;

                //playbackDataJson.comments                
                //only comments up to the pause point
                playbackDataJson.comments = playbackDataOnScreenAtPausePoint.comments;
            }

            /*
             * This function gets all of the events in the playback but undoes each of the events after the pause
             * point. This keeps the history after the pause point but wipes it out in future playbacks in one 
             * big block.
             */
            function getPlaybackDataFutureEventsUndone(playbackDataJson, editorStateJson) {
                
                //playbackDataJson.codeEvents
                //undo all of the events from the end until the pause point
                var undoEvents = [];
                getUndoEvents(undoEvents, editorStateJson);

                //add the existing events from the playback and the undo events
                playbackDataJson.codeEvents = playbackData.codeEvents.concat(undoEvents);

                //playbackDataJson.allDevelopers
                playbackDataJson.allDevelopers = playbackData.allDevelopers;
                
                //playbackDataJson.allDeveloperGroups
                playbackDataJson.allDeveloperGroups = playbackData.allDeveloperGroups;
                
                //playbackDataJson.allFiles
                playbackDataJson.allFiles = playbackData.allFiles;
                
                //playbackDataJson.allDirs
                playbackDataJson.allDirs = playbackData.allDirs;

                //playbackData.currentDevGroupId
                playbackDataJson.currentDevGroupId = playbackData.currentDevGroupId;
                
                //playbackDataJson.comments
                //add all of the comments in the whole playback
                playbackDataJson.comments = playbackData.comments;                
            }

            /*
             * This function creates a series of events to undo or revert the code on the screen to a previous 
             * point. 
             * 
             * Each event has an inverse:
             * Insert ~ Delete
             * Create File ~ Delete File
             * Create Directory ~ Delete Directory
             * Move File ~ Move File
             * Move Directory ~ Move Directory
             * Rename File ~ Rename File
             * Rename Directory ~ Rename Directory
             * 
             * There is some complexity in this situation. All inserts after the pause point that are deleted after 
             * the pause point do not need to be undone because the inserts will naturally get removed from the deletes. 
             * The same is true of create and delete file/dir.
             * 
             * editorStateJson gets passed in because we are adding brand new events to the playbackData.json data 
             * and we need the autoGeneratedEventId to be updated to reflect the new events. The playbackData.json
             * file must be zipped before editorState.json because of this.
             */
            function getUndoEvents(undoEvents, editorStateJson) {
                
                //all the undo events will have the same timestamp
                var timestamp = new Date().getTime();

                //holds the full path of the files at the pause point keyed by their ids
                var idToPathMap = getIdToPathMap(editorStateJson.pathToIdMap);

                //get the last event so that we can create a new unique id
                var lastEvent = playbackData.codeEvents[playbackData.codeEvents.length - 1];

                //get the last event in the playback's id num and increase it
                editorStateJson.autoGeneratedEventId = parseInt(lastEvent.id.substr("ev_".length), 10) + 1;

                //holds the ids of the insert/delete events after the pause point
                var insertedAfterPausePoint = {};
                var deletedAfterPausePoint = {};

                var createdFilesAfterPausePoint = {};
                var deletedFilesAfterPausePoint = {};
                
                var createdDirsAfterPausePoint = {};
                var deletedDirsAfterPausePoint = {};

                //go through the events after the pause point to gather info about events after the pause point
                for(var i = playbackData.codeEventsIndex + 1;i < playbackData.codeEvents.length;i++) {
                
                    //grab the event after the pause point
                    var event = playbackData.codeEvents[i];

                    //if it is a insert
                    if(event.type === "Insert") {
                        
                        //record the id of the insert that is being added
                        insertedAfterPausePoint[event.id] = event.id;

                    } else if(event.type === "Delete") { //delete a character
                        
                        //record the id of the insert that the delete is getting rid of
                        deletedAfterPausePoint[event.previousNeighborId] = event.previousNeighborId;

                    } else if(event.type === "Create File") { //create a file
                        
                        //record the file id that it is getting created
                        createdFilesAfterPausePoint[event.fileId] = event.fileId;

                    } else if(event.type === "Delete File") { //delete a file
                        
                        //record the file id that it is getting rid of
                        deletedFilesAfterPausePoint[event.fileId] = event.fileId;

                    } else if(event.type === "Create Directory") { //create a dir
                        
                        //record the directory id that it is getting created
                        createdDirsAfterPausePoint[event.directoryId] = event.directoryId;

                    } else if(event.type === "Delete Directory") { //delete a dir
                        
                        //record the directory id that it is getting rid of
                        deletedDirsAfterPausePoint[event.directoryId] = event.directoryId;
                    }
                }

                //go through the events after the pause point in reverse to undo any events that aren't naturally 
                //undone by other events after the pause point
                for(var i = playbackData.codeEvents.length - 1;i > playbackData.codeEventsIndex;i--) {
                    
                    //grab the event to 'undo'
                    var event = playbackData.codeEvents[i];

                    //if it was inserted after the pause point AND it was NOT deleted after the pause point
                    if(event.type === "Insert" && deletedAfterPausePoint[event.id] === undefined) {

                        //the inverse of an insert is a delete
                        //fill in the rest of the event details
                        var inverseInsertEvent = {
                            id: "ev_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId,
                            type: "Delete",
                            character: event.character,
                            previousNeighborId: event.id,
                            lineNumber: -1, //don't know where the event is without an editor
                            column: -1,
                            fileId: event.fileId
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseInsertEvent);

                    //if it was deleted after the pause point AND it was NOT inserted after the pause point
                    } else if(event.type === "Delete" && insertedAfterPausePoint[event.previousNeighborId] === undefined) {

                        //the inverse of a delete is an insert
                        //fill in the rest of the event details
                        var inverseDeleteEvent = {
                            id: "ev_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId,
                            type: "Insert",
                            character: event.character,
                            previousNeighborId: event.previousNeighborId,
                            lineNumber: -1, //don't know where the event is without an editor
                            column: -1,
                            fileId: event.fileId
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseDeleteEvent);

                    } else if(event.type === "Create File" && deletedFilesAfterPausePoint[event.fileId] === undefined) {

                        //the inverse of a create file is a delete file
                        //fill in the rest of the event details
                        var inverseCreateFileEvent = {
                            id: "ev_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Delete File",
                            fileId: event.fileId,
                            fileName: event.initialName, 
                            parentDirectoryId: event.parentDirectoryId
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseCreateFileEvent);

                    } else if(event.type === "Delete File" && createdFilesAfterPausePoint[event.fileId] === undefined) {

                        //the inverse of a delete file is a create file
                        //fill in the rest of the event details
                        var inverseDeleteFileEvent = {
                            id: "ev_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Create File",
                            initialName: event.fileName, 
                            fileId: event.fileId,                            
                            parentDirectoryId: event.parentDirectoryId
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseDeleteFileEvent);

                    } else if(event.type === "Create Directory" && deletedDirsAfterPausePoint[event.directoryId] === undefined) {

                        //the inverse of a create dir is a delete dir
                        //fill in the rest of the event details
                        var inverseCreateDirectoryEvent = {
                            id: "ev_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Delete Directory",
                            directoryId: event.directoryId,
                            directoryName: event.initialName,
                            parentDirectoryId: event.parentDirectoryId
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseCreateDirectoryEvent);

                    } else if(event.type === "Delete Directory" && createdDirsAfterPausePoint[event.directoryId] === undefined) {

                        //the inverse of a delete dir is a create dir
                        //fill in the rest of the event details
                        var inverseDeleteDirectoryEvent = {
                            id: "ev_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Create Directory",
                            initialName: event.directoryName, 
                            directoryId: event.directoryId,                            
                            parentDirectoryId: event.parentDirectoryId
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseDeleteDirectoryEvent);

                    } else if(event.type === "Move File") {

                        //the inverse of a move file is another move file
                        //fill in the rest of the event details
                        var inverseMoveFileEvent = {
                            id: "ev_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Move File",
                            fileId: event.fileId,
                            fileName: event.fileName,
                            newParentDirectoryId: event.oldParentDirectoryId,
                            oldParentDirectoryId: event.newParentDirectoryId,
                            newParentDirectoryName: event.oldParentDirectoryName, 
                            oldParentDirectoryName: event.newParentDirectoryName
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseMoveFileEvent);

                    } else if(event.type === "Move Directory") {

                        //the inverse of a move dir is another move dir
                        //fill in the rest of the event details
                        var inverseMoveDirectoryEvent = {
                            id: "ev_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Move Directory",
                            directoryId: event.directoryId,
                            directoryName: event.directoryName, 
                            newParentDirectoryId: event.oldParentDirectoryId,
                            oldParentDirectoryId: event.newParentDirectoryId,
                            newParentDirectoryName: event.oldParentDirectoryName,
                            oldParentDirectoryName: event.newParentDirectoryName
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseMoveDirectoryEvent);

                    } else if(event.type === "Rename File") {

                        //the inverse of a rename file is another rename file
                        //fill in the rest of the event details
                        var inverseRenameFileEvent = {
                            id: "ev_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Rename File",
                            fileId: event.fileId,
                            newFileName: event.oldFileName, 
                            oldFileName: event.newFileName                            
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseRenameFileEvent);

                    } else if(event.type === "Rename Directory") {

                        //the inverse of a rename dir is another rename dir
                        //fill in the rest of the event details
                        var inverseRenameDirectoryEvent = {
                            id: "ev_" + editorStateJson.autoGeneratedEventId,
                            timestamp: timestamp,
                            createdByDevGroupId: playbackData.currentDevGroupId, 
                            type: "Rename Directory",
                            directoryId: event.directoryId,
                            newDirectoryName: event.oldDirectoryName,
                            oldDirectoryName: event.newDirectoryName
                        };

                        //increase for the next event
                        editorStateJson.autoGeneratedEventId++;

                        //add the inverse event
                        undoEvents.push(inverseRenameDirectoryEvent);
                    }
                }
            }

            /*
             * This function takes a map and inverts the key/value pairs
             */
            function getIdToPathMap(pathToIdMap) {

                //holds the paths of the files keyed by their id
                var idToPathMap = {};

                //go through each path 
                for (var path in pathToIdMap) {
                    if (pathToIdMap.hasOwnProperty(path)) {

                        //get the id of the entry
                        var id = pathToIdMap[path];

                        //store the path keyed by the id
                        idToPathMap[id] = path;
                    }
                }

                return idToPathMap;
            }

            /*
             * Adds the editor state json file to the zip so that someone can begin editing after unzipping.
             */
            function zipUpEditorState(rootDirName, editorStateJson, zip) {
                
                //create the hidden storyteller files and add them to the zip
                zip.file("/" + rootDirName + "/.storyteller/editorState.json", JSON.stringify(editorStateJson));
            }

            /*
             * Finalizes the zip and starts the download process.
             */
            function buildZip(zipFileName, zip) {

                //get the current date/time
                var fileCreationDate = new Date();

                //append the date/time in iso format and add a zip extension
                zipFileName = zipFileName + "-" + fileCreationDate.toISOString() + ".zip";

                //create a blob representation of the zip
                zip.folder("/").generateAsync({type:"blob"}).then(function (blobbedZip) {

                    //create a temp invisible anchor and add it to the page
                    var a = document.createElement("a");
                    document.body.appendChild(a);
                    a.style = "display: none";

                    //create a downloadable blob
                    var blob = new Blob([blobbedZip], {type: "application/zip"});

                    //create a url that holds the zip
                    url = window.URL.createObjectURL(blob);

                    //assign the new with zip data url to the anchor
                    a.href = url;

                    //add a name to the zip
                    a.download = zipFileName;

                    //simulate a click of the button
                    a.click();

                    //clean up the resources for the url
                    window.URL.revokeObjectURL(url);
                    
                    //remove the anchor
                    a.remove();
                });
            }

//*********************************************** experimental merging code *****************************************
            function merge(playbackDataEventsBranch1, playbackDataEventsBranch2) {
                
                console.log("Merging...");
                
                //an object with three sets of events- common to both branches and distinct events in both
                var eventsBySourceSets = {
                    common: {},     //events that are common to both branches
                    branch1: {},    //events that are only in branch 1
                    branch2: {}     //events that are only in branch 2
                };

                //build the sets of events
                getEventsBySourceSets(playbackDataEventsBranch1, playbackDataEventsBranch2, eventsBySourceSets);

                //each file has a 'conflict' array to identify conflicts
                var conflictArraysByFile = {};

                //add the common events to the conflict arrays
                addCommonEvents(playbackDataEventsBranch1, eventsBySourceSets.common, conflictArraysByFile);

                //add the events from branch 1 to the conflict arrays
                addBranchEvents(playbackDataEventsBranch1, "branch1", eventsBySourceSets.branch1, conflictArraysByFile);
                
                //add the events from branch 2 to the conflict arrays
                addBranchEvents(playbackDataEventsBranch2, "branch2", eventsBySourceSets.branch2, conflictArraysByFile);

                //each file may have one or more conflict events
                var insertConflictsByFile = {};
                var deleteConflictsByFile = {};

                //identify the conflicts
                identifyConflicts(conflictArraysByFile, insertConflictsByFile, deleteConflictsByFile);

                //build up the events for the new playbackData file.

                //create a file with the two branches and the conflict detection events
            }
 
            /*
             * Assign each event into one of the sets- common, branch1, or branch2. This is used to identify
             * what group each event belongs to.
             */
            function getEventsBySourceSets(playbackDataEventsBranch1, playbackDataEventsBranch2, eventsBySourceSets) {
                
                var event;

                //go through all of the events in the first branch
                for(var i = 0;i < playbackDataEventsBranch1.length;i++) {

                    //get the event
                    event = playbackDataEventsBranch1[i];

                    //add the event to the branch1 map
                    eventsBySourceSets.branch1[event.id] = event;
                }

                //go through all of the events in the second branch
                for(var i = 0;i < playbackDataEventsBranch2.length;i++) {

                    //get the event
                    event = playbackDataEventsBranch2[i];
                    
                    //if there is an entry in the branch 1 set and it is the exact same event (two events from different branches
                    //can have the same id but be different)
                    //if this event from the second branch is also in the first, it is a common event
                    if(eventsBySourceSets.branch1[event.id] && compareEvents(event, eventsBySourceSets.branch1[event.id])) {
                        
                        //add the event to the common map
                        eventsBySourceSets.common[event.id] = event;

                        //since it is not unique to branch 1, remove it from that map
                        delete eventsBySourceSets.branch1[event.id];

                    } else { //this event is not in the first branch, it is unique to branch2

                        //add the event to the correct map
                        eventsBySourceSets.branch2[event.id] = event;
                    }
                }
            }

             /*
             * Compares if two events are the same. Since we are not using truly unique UUIDs we check the 
             * id, the timestamp, and the dev group id. The idea is that it is extremely unlikely that the
             * exact same developer group can generate two events at exactly the same time.  
             */
            function compareEvents(ev1, ev2) {

                //assume the two events are not the same
                var retVal = false;

                //if the event ids are the same (two different events from different branches could have the same id) AND 
                //the timestamps are the same AND
                //the events were created by the same dev group
                if(ev1.id === ev2.id && 
                   ev1.timestamp === ev2.timestamp && 
                   ev1.createdByDevGroupId === ev2.createdByDevGroupId) {

                    //the events are the same
                    retVal = true;
                }

                return retVal;
            }

           /*
             * This function adds events that are common to both branches to each file's 'conflict array' which is used
             * to identify conflicts. Each file has its own conflict array. The common events are added in the order that
             * they appear in the original branches. 
             */
            function addCommonEvents(playbackDataEvents, commonEventSet, conflictArraysByFile) {
                
                //go through all of the events in the branch
                for(var i = 0;i < playbackDataEvents.length;i++) {
                    
                    //get the event
                    var event = playbackDataEvents[i];                    

                    //if there is an entry in the common set and it is the exact same event (two events from different branches
                    //can have the same id but be different)
                    //if it is a common event
                    if(commonEventSet[event.id] && compareEvents(event, commonEventSet[event.id])) {

                        //if this is an insert event
                        if(event.type === "Insert") {

                            //if there is not already an array of conflict events for this file
                            if(!conflictArraysByFile[event.fileId]) {

                                //create an empty array
                                conflictArraysByFile[event.fileId] = [];
                            }

                            //get the conflict array for a file
                            var conflictArray = conflictArraysByFile[event.fileId];

                            //create a special representation of the event
                            var commonConflictEvent = {
                                event: event,
                                type: "common",
                                branch1InsertBacksUpToThis: false,
                                branch2InsertBacksUpToThis: false,
                                deletedbyBranch1: false,
                                deletedbyBranch2: false,
                                nextCommon: null
                            };

                            //add it to the conflict array
                            conflictArray.push(commonConflictEvent);

                            //if we are past the first event
                            if(conflictArray.length > 1) {

                                //make the previous event have a reference to the next
                                conflictArray[conflictArray.length - 2].nextCommon = commonConflictEvent; 
                            } 
                        }
                    }
                }
            }

            /*
             * This function adds events that are specific to each branch to each file's 'conflict array' which is used
             * to identify conflicts. Each file has its own conflict array. The branch events are added in the order that
             * they appear in the original branches.
             */
            function addBranchEvents(playbackDataEvents, branchName, branchEventSet, conflictArraysByFile) {
                
                //go through all of the events in the branch
                for(var i = 0;i < playbackDataEvents.length;i++) {
                    
                    //get the event
                    var event = playbackDataEvents[i];

                    //if there is an entry in the branch set and it is the exact same event (two events from different branches
                    //can have the same id but be different)
                    //if it is a branch event (not a common one)
                    if(branchEventSet[event.id] && compareEvents(event, branchEventSet[event.id])) {

                        //if this is an insert event
                        if(event.type === "Insert") {

                            //if there is not already an array of conflict events for this file
                            if(!conflictArraysByFile[event.fileId]) {

                                //create an empty array
                                conflictArraysByFile[event.fileId] = [];
                            }

                            //get the conflict array for a file
                            var conflictArray = conflictArraysByFile[event.fileId];

                            //create a special representation of the event
                            var conflictEvent = {
                                event: event,
                                type: branchName
                            };

                            //get the index of the insert event's previous neighbor
                            var prevNeighborIndex = findEventInConflictArray(event.previousNeighborId, branchName, conflictArray);

                            //add the event to the conflict array so that it backs up to its previous neighbor
                            conflictArray.splice(prevNeighborIndex + 1, 0, conflictEvent);

                            //get the previous neighbor conflict event
                            var prevNeighborEvent = conflictArray[prevNeighborIndex];

                            //if the previous neighbor is a common event, a branch insert backs up to a common insert event
                            if(prevNeighborEvent.type === "common") {

                                //if it is branch 1
                                if(branchName === "branch1") {
                                    
                                    //indicate that an insert from branch 1 backs up to a common insert event
                                    prevNeighborEvent.branch1InsertBacksUpToThis = true;

                                } else { //its from branch 2
                                    
                                    //indicate that an insert from branch 1 backs up to a common insert event
                                    prevNeighborEvent.branch2InsertBacksUpToThis = true;
                                }

                            } //else- the previous neighbor is not common, it comes from the same branch

                        } else if (event.type === "Delete") {

                            //get the index of the insert event's previous neighbor
                            var prevNeighborIndex = findEventInConflictArray(event.previousNeighborId, branchName, conflictArray);

                            //get the previous neighbor conflict event
                            var prevNeighborEvent = conflictArray[prevNeighborIndex];

                            //if the previous neighbor is a common event, a branch insert backs up to a common insert event
                            if(prevNeighborEvent.type === "common") {

                                //if it is branch 1
                                if(branchName === "branch1") {
                                    
                                    //indicate that a delete from branch 1 is deleting a common event                                    
                                    prevNeighborEvent.deletedbyBranch1 = true;

                                } else { //its from branch 2
                                    
                                    //indicate that a delete from branch 1 is deleting a common event
                                    prevNeighborEvent.deletedbyBranch2 = true;
                                }

                            } else { //the previous neighbor is not common, it comes from the same branch

	                            //remove it from the conflict array since this will cause no conflicts
                                conflictArray.splice(prevNeighborIndex, 1);
                            }
                        }
                    }
                }
            }

            /*
             * Finds the index of an event based on an event id in a given branch or in the common group. 
             */
            function findEventInConflictArray(eventId, branchName, conflictArray) {
                
                //index of event in the conflict array
                var retVal = -1;

                //go through all of the events in the conflict array
                for(var i = 0;i < conflictArray.length;i++) {

                    //if the event id matches and it is either from the common events or the same branch 
                    if(conflictArray[i].event.id === eventId && (conflictArray[i].type === "common" || conflictArray[i].type === branchName)) {
                        
                        //store the index and stop looking
                        retVal = i;
                        break;
                    }
                }

                return retVal;
            }

            /*
             * Identifies conflicts in each file's conflict array 
             */
            function identifyConflicts(conflictArraysByFile, insertConflictsByFile, deleteConflictsByFile) {

                //go through each file's conflict array
                for (var fileId in conflictArraysByFile) {
                    if (conflictArraysByFile.hasOwnProperty(fileId)) {

                        //get the conflict array for a file
                        var conflictArray = conflictArraysByFile[fileId];

                        //go through all the events in the conflict array
                        for(var i = 0;i < conflictArray.length;i++) {
                            
                            //get the conflict event
                            var conflictEvent = conflictArray[i];

                            //conflicts only happen at common events, so check on each one
                            if(conflictEvent.type === "common") {
                                
                                //if this common event has a new insert that backs up to it
                                if(conflictEvent.branch1InsertBacksUpToThis === true) {
                                    
                                    //if the common event was also deleted by the other branch
                                    if(conflictEvent.deletedbyBranch2 === true) {

                                        //delete conflict
                                        getDeleteConflict(conflictArray, i);

                                    } else if(conflictEvent.nextCommon.deletedbyBranch2 === true) { //the common event after this one was deleted by the other branch

                                        //delete conflict
                                        getDeleteConflictNeighbor();
                                    }

                                } else if (conflictEvent.branch2InsertBacksUpToThis === true) { //if this common event has a new insert that backs up to it

                                    //if the common event was also deleted by the other branch                                    
                                    if(conflictEvent.deletedbyBranch1 === true) {

                                        //delete conflict
                                        getDeleteConflict();

                                    } else if(conflictEvent.nextCommon.deletedbyBranch1 === true) { //the common event after this one was deleted by the other branch

                                        //delete conflict
                                        getDeleteConflictNeighbor();
                                    }
                                } 
                                
                                //there are inserts from both branches backing up to a single common event
                                if(conflictEvent.branch1InsertBacksUpToThis === true && conflictEvent.branch2InsertBacksUpToThis === true) { 
                                
                                    //if there isn't an array of insert conflicts for this file yet
                                    if(!insertConflictsByFile[fileId]) {

                                        //create an empty one
                                        insertConflictsByFile[fileId] = [];
                                    }

                                    //get the array of insert conflicts for the file 
                                    var insertConflicts = insertConflictsByFile[fileId];

                                    //create and insert conflict
                                    var insertConflict = getInsertConflict(conflictArray, i);

                                    //add it to the collection
                                    insertConflicts.push(insertConflict);
                                }

                                //there are deletes from both branches backing up to a single common event
                                if(conflictEvent.deletedbyBranch1 === true && conflictEvent.deletedbyBranch2 === true) { 
                                
                                    //delete conflict
                                    //getConflictInsert();
                                }

                            } //else- not a common event, no conflicts can happen in non-common events
                        }
                    }
                }
            }

            /*
             *
             */
            function getDeleteConflict(conflictArray, posOfConflict) {
                
                console.log("delete conflict- common event added to in one branch and deleted in the other");

                var deleteBranchName = conflictArray[posOfConflict].deletedbyBranch1 ? "branch1" : "branch2";

                var lookBackPos = posOfConflict - 1;

                while(lookBackPos >= 0 && conflictArray[lookBackPos].type === "common") {

                    //if()

                }

            }

            /*
             *
             */
            function getDeleteConflictNeighbor(conflictArray, posOfConflict) {
                
                console.log("delete conflict");

            }
            
            /*
             *
             */
            function getInsertConflict(conflictArray, posOfConflict) {

                console.log("Insert conflict");

                //holds the positions where the first branch's conflict begins and ends 
                var firstBranchStartPos = posOfConflict + 1;
                var firstBranchEndPos;
                //get the name of the first branch (could be 'branch1' or 'branch2')
                var firstBranchName = conflictArray[firstBranchStartPos].type;

                //move through all of the branch events in the same branch
                var i = posOfConflict + 1;

                //while we are within the bounds of the array AND the names are the same, we are in the same branch
                while(i < conflictArray.length && conflictArray[i].type === firstBranchName) {
                    i++;
                }

                //when we get here we will have moved from one branch to the next

                //get the index of the last event in the branch
                firstBranchEndPos = i - 1;

                //holds the positions where the second branch's conflict begins and ends 
                var secondBranchStartPos = i;
                var secondBranchEndPos;
                //get the name of the second branch (could be 'branch1' or 'branch2')
                var secondBranchName = conflictArray[i].type;

                //move through all of the branch events in the same branch
                //while we are within the bounds of the array AND the names are the same, we are in the same branch
                while(i < conflictArray.length && conflictArray[i].type === secondBranchName) {
                    i++;
                }

                //get the index of the last event in the branch
                secondBranchEndPos = i - 1;

                //create an insert conflict
                var insertConflict = {
                    firstBranchStartPos: firstBranchStartPos,
                    firstBranchEndPos: firstBranchEndPos,
                    firstBranchName: firstBranchName,
                    secondBranchStartPos: secondBranchStartPos,
                    secondBranchEndPos: secondBranchEndPos,
                    secondBranchName: secondBranchName
                };

                return insertConflict;
            }
//*********************************************** experimental merging code *****************************************

            //*****************************************************************************
            //                    Line number/highlighting related code
            //                    -------------------------------------
            // This code has to do with showing and hiding line numbers
            //*****************************************************************************
            /*
             * Adds a line number if the passed in element is a newline. It doesn't matter what the value of the line number 
             * is since they are increasing automatically. This is called when making code visible.
             */
            function addLineNumberIfNecessary(codeElement, fileId) {

                //if we are displaying a new newline character, add a new line number
                if(codeElement.tagName === "BR") {

                    //get the gutter
                    var lineNumberGutter = document.querySelector("#lineNumberGutter-" + fileId);

                    //create a div with the lineNum class
                    var newLineNumberSpan = document.createElement("div");
                    newLineNumberSpan.classList.add("lineNum");

                    //add a new line number to the end of the gutter
                    lineNumberGutter.appendChild(newLineNumberSpan);
                }
            }

            /*
             * Removes a line number if the passed in element is a newline. It doesn't matter that we remove the line number div 
             * where the event happened since they are constantly increasing. This is called when making code invisible.
             */
            function removeLineNumberIfNecessary(codeElement, fileId) {

                //if we are hiding a newline, remove a new line number
                if(codeElement.tagName === "BR") {

                    //get the line number gutter and remove a line number
                    //(any one if fine, removing last is probably quickest)
                    var lineNumberGutter = document.querySelector("#lineNumberGutter-" + fileId);
                    lineNumberGutter.removeChild(lineNumberGutter.lastChild);
                }
            }

            /*
             * Highlights a given line number.
             */
            function highlightLine(lineNumber, fileId) {

                //get the line number gutter for a file
                var lineNumberGutter = document.querySelector("#lineNumberGutter-" + fileId);

                //if the latest event happened on a different line than the last one OR in a different file
                if(playbackData.activeLineNumber !== lineNumber || playbackData.activeFileId !== fileId) {

                    //remove the previously highlighted line in the current file
                    var allCurrentLines = document.querySelectorAll("#lineNumberGutter-" + fileId + " .currentLine");
                    for(var i = 0;i < allCurrentLines.length;i++) {
                        allCurrentLines[i].classList.remove("currentLine");
                    }

                    //store the new active line number
                    playbackData.activeLineNumber = lineNumber;                    

                    //add a style to highlight the active line
                    lineNumberGutter.children[lineNumber - 1].classList.add("currentLine");
                }
            }
           //*****************************************************************************
            //                         Scrolling related code
            //                         ----------------------
            // This code has to do with scrolling to the active code event during a playback
            //*****************************************************************************
            /*
             * Handle the situation when a piece of code is off of the playback window. This
             * function will scroll (vertically and horizontally) to make sure the code element
             * can be seen on the screen.
             * 
             * Handles scrolling by looking at the height of the #playbackWindows
             * div which owns the scroll bars. Find the distance from the top of the
             * #playbackWindows div where the code element is and if the code element is off
             * the #playbackWindows div it scrolls down.
             * 
             * Similar for horizontal scroll, look for a position near the character and scroll there
             *
             * all <br>'s seem to have an offsetTop of 0, this requires us to not scroll
             * for <br>'s otherwise we would bounce up and down at every line break.
             */
            function handleScroll(codeElement) {

                //if the element is not a BR
                if(codeElement.tagName !== "BR") {
                
                    //get the playback container (the parent of the playback windows, playback tabs and the owner of the scroll bars)
                    var scrollablePlaybackContainer = document.querySelector("#playbackWindows");

                    //get the height of the owner of the scrollbars, #playbackWindows
                    var parentNodeClientHeight = scrollablePlaybackContainer.clientHeight;

                    //get the width of the parent to this code element, a playbackWindow
                    var parentNodeClientWidth = codeElement.parentNode.clientWidth;

                    //get the distance from the top edge of the parent 
                    //get the amount of pixels that the element is underneath the scrollablePlaybackContainer's height
                    var verticalDiff = codeElement.offsetTop - parentNodeClientHeight;
                    
                    //get the distance from the left edge of the parent
                    //get the amount of pixels that the element is to the right of the playback window's width
                    var horizontalDiff = codeElement.offsetLeft - parentNodeClientWidth;
 
                    //create a vertical scroll position that will place the character in the middle of the screen
                    var targetScrollTop = verticalDiff + (parentNodeClientHeight / 2);

                    //create a horizontal scroll position that will place some space after the character if it is at the end of a line
                    var targetScrollLeft = horizontalDiff + 100;
                    
                    //object that says where to scroll to
                    var properties = {
                        scrollTop: targetScrollTop, 
                        scrollLeft: targetScrollLeft
                    };

                    //make the scrollablePlaybackContainer scroll to the difference plus a little extra
                    $(scrollablePlaybackContainer).animate(properties, playbackData.delay, "linear");
                
                } //else- can't scroll to a BR (TODO can we scroll to a line number div??)
            }
            
            //*****************************************************************************
            //                         Filter related code
            //                         ----------------------
            // This code has to do with filtering code events to find the relevant ones for
            // playback. There is a filter function that filters by time, developer group
            // id, and file. There is another filter function that filters by the selected
            // text on the screen.
            //*****************************************************************************
            /*
             * Filters the events of a playback by time, dev group id, and by file.
             */
            function filterPlayback(timeFilters, devGroupFilter, fileDirFilter) {

                //flags indicating whether each filter type has been satisfied
                var satisfyTimeFilter;
                var satisfyDevGroupFilter;
                var satisfyFileFilter;

                //event info for filtering
                var currentEventTimestamp;
                var currentEventDevGroupId;
                var currentEventType;
                var currentEventFileId;
                var currentEventDirectoryId;

                //set the number of relevant events back to 0
                playbackData.numberOfRelevantEvents = 0;

                //clear statistics
                clearStatisticsData();

                //go through all of the code events
                for(var i = 0;i < playbackData.codeEvents.length;i++) {

                    //reset the flags, assume each event is not relevant
                    satisfyTimeFilter = false;
                    satisfyDevGroupFilter = false;
                    satisfyFileFilter = false;

                    //grab the current event's relevant data
                    currentEventTimestamp = playbackData.codeEvents[i].timestamp;
                    currentEventDevGroupId = playbackData.codeEvents[i].createdByDevGroupId;
                    currentEventType = playbackData.codeEvents[i].type;
                    currentEventFileId = playbackData.codeEvents[i].fileId;
                    currentEventDirectoryId = playbackData.codeEvents[i].directoryId;

                    //if there is at least one time filter
                    if(timeFilters.length > 0) {

                        //go through each of the time filters
                        for(var j = 0;j < timeFilters.length;j++) {
                            
                            //get each time filter
                            var timeFilter = timeFilters[j];

                            //if the current timestamp comes after the filter's start timestamp AND before the filter's end timestamp
                            if(currentEventTimestamp >= timeFilter.startTimestamp && currentEventTimestamp <= timeFilter.endTimestamp) {

                                //this event is within at least one of the time filter parameters
                                satisfyTimeFilter = true;

                                break;
                            }
                        }
                    }

                    //if there is a dev group filter
                    if(devGroupFilter) {

                        //if the event's dev group is in the array of selected dev group ids
                        if(devGroupFilter.devGroupIds.indexOf(currentEventDevGroupId) !== -1) {

                            //event's dev group id is in the selected dev groups filter
                            satisfyDevGroupFilter = true;
                        }
                    }

                    //if there is a file/dir filter
                    if(fileDirFilter) {

                        //some events have a fileId and some have a directoryId
                        if(currentEventType === "Insert" || currentEventType === "Delete" ||
                           currentEventType === "Create File" || currentEventType === "Rename File" ||
                           currentEventType === "Move File" || currentEventType === "Delete File") {
                           //these events have a fileId

                            //if the event's file id is in the array of selected files
                            if(fileDirFilter.fileDirIds.indexOf(currentEventFileId) !== -1) {

                                //the user has wants to see it
                                satisfyFileFilter = true;
                            }

                        } else if (currentEventType === "Create Directory" || currentEventType === "Rename Directory" ||
                                   currentEventType === "Move Directory" || currentEventType === "Delete Directory") {
                                   //these events have a directoryId

                            //if the event's directory id is NOT in the array of selected directories
                            if(fileDirFilter.fileDirIds.indexOf(currentEventDirectoryId) !== -1) {

                                //the user wants to see it
                                satisfyFileFilter = true;
                            }
                        }
                    }

                    //if the event satisfies all of the filter info
                    if(satisfyTimeFilter === true && satisfyDevGroupFilter === true && satisfyFileFilter === true) {

                        //mark the event as relevant
                        playbackData.codeEvents[i].relevant = true;

                        //increase the number of relevant events
                        playbackData.numberOfRelevantEvents++;

                    } else { //one or more filter were not satisfied

                        //mark the event as NOT relevant
                        playbackData.codeEvents[i].relevant = false;
                    }
                }
            }

            /*
             * Marks all of the selected code elements on the screen as relevant but also goes deeper.
             * For each of the selected code elements, if there are any events that at one time backed
             * up to a selected element but were then deleted, those are marked as relevant too. If any
             * events that backed up to those deleted elements and were deleted too, they are marked as
             * relevant too.
             *
             * In the dom, because of the way we add all of the code elements by previous neighbor id,
             * all events that ever backed up to an element are right in front of it along with the
             * events that ever backed up to those.
             *
             * So, we can go through the first selected element until the last selected element and we
             * should be able to see all the related history (events that were added and deleted but
             * backed up to one of the selected events)
             */
            function selectedTextFilter() {

                //get the ids of all of the selected code elements
                var selectedCodeIds = getSelectedCodeIds(true);

                //reset the entire playback
                getPlaybackWindowsReadyForAnimation(false);

                //if there are some selected events
                if(selectedCodeIds.length > 0) {

                    //in the dom, because of the way we add all of the code elements by previous
                    //neighbor id, all events that ever backed up to an element are right in front
                    //of it along with the events that ever backed up to those.
                    //So, we can go through the first selected element until the last selected
                    //element and we should be able to see all the related history (events that
                    //were added and deleted but backed up to one of the selected events)

                    //hold the ids of the relevant elements in the history if the selected code
                    var relevantIds = {};

                    //get the first and last selected elements
                    var firstSelectedEventId = selectedCodeIds[0];
                    var lastSelectedEventId = selectedCodeIds[selectedCodeIds.length - 1];

                    //get the first selected element in the dom
                    var relevantElement = document.querySelector("#" + firstSelectedEventId);

                    //while there are more relevant elements
                    while(relevantElement) {

                        //get the id from the element
                        var relevantId = relevantElement.getAttribute("id");

                        //add the element's id to a set
                        relevantIds[relevantId] = relevantId;

                        //if we have reached the last selected element we are done recording relevant event ids
                        if(relevantId === lastSelectedEventId) {

                            //stop looking for relevant elements in the history
                            break;
                        }

                        //move to the next element
                        relevantElement = relevantElement.nextElementSibling;
                    }

                    //reset the number of relevant events
                    playbackData.numberOfRelevantEvents = 0;

                    //go through all of the events and mark them as relevant or not
                    for(var i = 0;i < playbackData.codeEvents.length;i++) {

                        //if the event is an insert AND it has one of the relevant ids
                        if(playbackData.codeEvents[i].type === "Insert" && relevantIds[playbackData.codeEvents[i].id]) {

                            //mark the event as relevant
                            playbackData.codeEvents[i].relevant = true;

                            //count it as relevant
                            playbackData.numberOfRelevantEvents++;

                        //if the event is a delete AND its previous neighbor is one of the relevant ids
                        } else if(playbackData.codeEvents[i].type === "Delete" && relevantIds[playbackData.codeEvents[i].previousNeighborId]) {

                            //the delete is relevant
                            playbackData.codeEvents[i].relevant = true;

                            //count it as relevant
                            playbackData.numberOfRelevantEvents++;

                        } else { //not a selected event and not in the history of selected events

                            //mark as not relevant
                            playbackData.codeEvents[i].relevant = false;
                        }
                    }
                }
            }
            //*****************************************************************************
            //                         File system related filtering
            //                         -----------------------------
            // This code has to do with setting up a selectable view of the file system
            // for file/directory filtering. All files and directories are selectable
            // even if they were deleted in the past.
            //*****************************************************************************            
            /*
             * Get the root directory in the file system.
             */
            function getRootDir() {

                //find the root dir of the project directory
                var rootDir = null;

                //go through all of the dirs
                for(var dirId in playbackData.allDirs) {
                    if(playbackData.allDirs.hasOwnProperty(dirId)) {

                        //the root dir has a null parent id
                        if(playbackData.allDirs[dirId].parentId === null) {

                            //store the root and stop looking for it
                            rootDir = playbackData.allDirs[dirId];

                            break;
                        }
                    }
                }

                return rootDir;
            }

            /*
             * Uses the file and directory info in the playback data to build a list of checkboxes
             * so the user can select which ones to include in playback.
             */
            function displayFileSystemForFiltering() {

                //find the root dir of the project directory
                var parentDir = getRootDir();                

                //get the ul that holds this view of the file system
                var parentElement = document.querySelector("#viewOfFileSystemForFiltering");

                //clear it out
                parentElement.innerHTML = "";

                //create the file system view
                createDirectoryInTreeForFiltering(parentDir, parentElement, false);
            }

            /*
             * Adds checkboxes (and file/dir names next to them) in a hierarchical list so the user
             * can filter by file/directory.
             */
            function createDirectoryInTreeForFiltering(dir, parentElement, hasBeenDeleted) {

                //create an id for the new checkbox and list item to hold it
                var newDirCheckBoxId = "fsFilterCheckBoxDirId_" + dir.id;
                var newDirListItemId = "fsFilterListItemDirId_" + dir.id;

                //create a check box and add it to the parent element
                var dirFilterCheckBox = document.createElement("input");
                dirFilterCheckBox.setAttribute("type", "checkbox");
                dirFilterCheckBox.setAttribute("name", "fsFilter");

                //hold the id of the directory to use when it is selected
                dirFilterCheckBox.setAttribute("value", dir.id);
                dirFilterCheckBox.setAttribute("id", newDirCheckBoxId);
                dirFilterCheckBox.setAttribute("checked", "");
                
                //a class that allows us to select directory checkboxes
                dirFilterCheckBox.classList.add("filterCheckBox");
                
                //add an event handler 
                dirFilterCheckBox.addEventListener("click", function(e){

                    //when the checkbox is checked, get a reference to the ul that is holding the dir
                    var dirUL = document.querySelector("#dirUL_" + dir.id);

                    //get all the children checkboxes in this list with the class dirFilterCheckBox
                    var allCheckBoxesBelowAnother = dirUL.querySelectorAll(".filterCheckBox");

                    //if there are any checkboxes underneath the selected one
                    if(allCheckBoxesBelowAnother) {

                        //set all of the checkboxes below the selected one to whether the selected one is checked or not
                        for(var i = 0;i < allCheckBoxesBelowAnother.length;i++) {

                            //all child checkboxes will have the same value
                            allCheckBoxesBelowAnother[i].checked = e.target.checked;
                        }
                    }
                });

                //add a directory icon
                var dirIcon = document.createElement("span");
                dirIcon.innerHTML = "+"
                //dirIcon.classList.add("glyphicon");
                //dirIcon.classList.add("glyphicon-folder-open");
                dirIcon.classList.add("dirIcon");

                //create a label to select
                var dirNameLabel = document.createElement("label");
                dirNameLabel.setAttribute("for", newDirCheckBoxId);
                dirNameLabel.appendChild(dirIcon);
                dirNameLabel.appendChild(document.createTextNode(dir.currentName));

                //add the radio button and label to a list item
                var dirLI = document.createElement("li");
                dirLI.setAttribute("id", newDirListItemId);
                dirLI.appendChild(dirFilterCheckBox);
                dirLI.appendChild(dirNameLabel);

                //if the dir has been deleted we will highlight it wait a class
                if(dir.isDeleted) {
                    dirLI.classList.add("deletedFileOrDirectory");
                }

                //add the list item to the parent
                parentElement.appendChild(dirLI);

                //now handle subdirectories by adding them all underneath the parent element
                var subList = null;

                //go through all of the dir ids in the object of all directories
                for (var dirId in playbackData.allDirs) {
                    if (playbackData.allDirs.hasOwnProperty(dirId)) {

                        //if another directory has this one as its parent
                        if(playbackData.allDirs[dirId].parentId === dir.id) {

                            //if a new sub list has not already been created
                            if(subList === null) {

                                //add a new list and append it to the parent list
                                subList = document.createElement("ul");
                                subList.setAttribute("id", "dirUL_" + dir.id);
                                subList.classList.add("fileOrDirListForFiltering");
                                parentElement.appendChild(subList);
                            }

                            //recurse and add the subdirectory
                            createDirectoryInTreeForFiltering(playbackData.allDirs[dirId], subList, playbackData.allDirs[dirId].isDeleted);
                        }
                    }
                }

                //add any files in this directory to the tree
                //go through all of the file ids in the object of all files
                for (var fileId in playbackData.allFiles) {
                    if (playbackData.allFiles.hasOwnProperty(fileId)) {

                        //if a file's parent is this directory
                        if(playbackData.allFiles[fileId].parentId === dir.id) {

                            //if a new sub list has not already been created
                            if(subList === null) {

                                //add a new list and append it to the parent list
                                subList = document.createElement("ul");
                                subList.setAttribute("id", "dirUL_" + dir.id);
                                subList.classList.add("fileOrDirListForFiltering");
                                parentElement.appendChild(subList);
                            }

                            //add the file in the list
                            addUnderDirectoryForFiltering(playbackData.allFiles[fileId], subList, playbackData.allFiles[fileId].isDeleted)
                        }
                    }
                }
            }

            /*
             * Add file info to the structure that holds the entire file system for filtering.
             */
            function addUnderDirectoryForFiltering(file, parentElement, hasBeenDeleted) {

                //create an id for the file checkbox
                var newFileCheckBoxId = "fsFilterCheckBoxFileId_" + file.id;

                //create a checkbox and add it to the parent element
                var fileCheckBox = document.createElement("input");
                fileCheckBox.setAttribute("type", "checkbox");
                fileCheckBox.setAttribute("name", "fsFilter");

                //store the value of the file id so we can get it when it is selected
                fileCheckBox.setAttribute("value", file.id);
                fileCheckBox.setAttribute("id", newFileCheckBoxId);
                fileCheckBox.setAttribute("checked", "");
                
                //add a class so we can determine which file was selected
                fileCheckBox.classList.add("filterCheckBox");

                //add a file icon
                var fileIcon = document.createElement("span");
                fileIcon.innerHTML = "-"
                //fileIcon.classList.add("glyphicon");
                //fileIcon.classList.add("glyphicon-file");

                //create a label to select
                var fileNameLabel = document.createElement("label");
                fileNameLabel.setAttribute("for", newFileCheckBoxId);
                fileNameLabel.appendChild(fileIcon);
                fileNameLabel.appendChild(document.createTextNode(file.currentName));

                //add the checkbox and label to a list item
                var fileLI = document.createElement("li");
                fileLI.appendChild(fileCheckBox);
                fileLI.appendChild(fileNameLabel);

                //if the file has been deleted we will highlight it wait a class
                if(file.isDeleted) {
                    fileLI.classList.add("deletedFileOrDirectory");
                }

                //add the file to the correct list
                parentElement.appendChild(fileLI);
            }

            /*
            <ul id="playbackViewOfFileSystem" class="playbackViewFileOrDirList">
                <li>
                    <span class="glyphicon glyphicon-folder-open"></span>
                    <span class="playbackDirNameLabel">root</span>
                </li>
                <ul id="playbackViewDir-0" class="playbackViewFileOrDirList">
                    <li id="playbackViewFile-1">
                        <span class="glyphicon glyphicon-file"></span>
                        <span>untitled.txt</span>
                    </li>
                </ul>
            </ul>
            */

            //*****************************************************************************
            //                         Selection related code
            //                         ----------------------
            // This code has to do with selecting lines and characters. The code allows
            // one to get the selected code characters from the playback window. There is a
            // function to get the selected code's text and the selected code's id's
            //*****************************************************************************
            /*
             * This function looks for selected elements in the document that are
             * code characters (class 'codeChar') and returns a list of them.
             */
            function getSelectedCodeElements(shouldDeselectCode) {

                //holds all of the selected code characters
                var allSelectedCodeCharacters = [];

                //get the document's selected elements
                var selection = document.getSelection();

                //if there are some selected elements in the dom
                if(selection.rangeCount > 0) {

                    //this is a very special case where one code character is selected, the code
                    //in the else block doesn't work with one character of code selected

                    //if there is a single element selected and its parent is a visible code char
                    if(selection.anchorNode === selection.focusNode &&
                       selection.anchorNode.parentElement.classList.contains("codeChar") &&
                       !selection.anchorNode.parentElement.classList.contains("codeNotVisible")) {

                        //add the parent element (selected code) to the array
                        allSelectedCodeCharacters.push(selection.anchorNode.parentElement);

                    } else {
                        //go through each selection (there may be more than one)
                        for(var i = 0;i < selection.rangeCount;i++) {

                            //find all the selected code characters in a range that are currently visible on the screen
                            var range = selection.getRangeAt(i).cloneContents().querySelectorAll(".codeChar:not(.codeNotVisible)");

                            //iterate through all of the selected code characters
                            for(var j = 0;j < range.length;j++) {

                                //add the current selected element to the return array
                                allSelectedCodeCharacters.push(range[j]);
                            }
                        }
                    }
                }

                //if the user wants the code deselected
                if(shouldDeselectCode) {

                    //deselect
                    selection.removeAllRanges();
                }

                return allSelectedCodeCharacters;
            }

            /*
             * This function gets all of the selected code character elements and returns
             * a string with all of the unadorned text.
             */
            function getSelectedCodeText(shouldDeselectCode) {

                //just the text of the selected elements
                var codeText = "";

                //holds all of the selected code characters
                var allSelectedCodeCharacters = getSelectedCodeElements(shouldDeselectCode);

                //go through all the selected elements
                for(var i = 0;i < allSelectedCodeCharacters.length;i++) {

                    //if the selected item is a newline character
                    if(allSelectedCodeCharacters[i].classList.contains("newLine")) {

                        //add a newline
                        codeText += "\n";

                    } else { //non-newline code

                        //add the text to the return string
                        codeText += allSelectedCodeCharacters[i].textContent;
                    }
                }

                return codeText;
            }

            /*
             * This function gets all of the selected code character elements and returns
             * their ids.
             */
            function getSelectedCodeIds(shouldDeselectCode) {

                //all the ids of the selected elements
                var codeIds = [];

                //holds all of the selected code characters
                var allSelectedCodeCharacters = getSelectedCodeElements(shouldDeselectCode);

                //go through the selected elements
                for(var i = 0;i < allSelectedCodeCharacters.length;i++) {

                    //add the ids of the elements to the return array
                    codeIds.push(allSelectedCodeCharacters[i].id);
                }

                return codeIds;
            }

            //*****************************************************************************
            //                         Date/time related code
            //                         ---------------------
            // This code has to do with formatting dates and times
            //*****************************************************************************
            /*
             * Get a date string DAYOFWEEK, MM/DD/YY HH:MM:SS
             */
            function formatDateShortWithDayOfWeek(dateTime) {

                //date formatting options
                var options = {
                    weekday: 'short',
                    year: '2-digit',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                };

                //use the options
                return dateTime.toLocaleString('en-US', options);
            }

            /*
             * Get a date string MM/DD/YY HH:MM:SS
             */
            function formatDateShort(dateTime) {

                //date formatting options
                var options = {
                    year: '2-digit',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                };

                //use the options
                return dateTime.toLocaleString('en-US', options);
            }

            //*****************************************************************************
            //                         Dev/dev group related code
            //                         ---------------------
            // This code has to do with working with devs and dev groups
            //*****************************************************************************
            /*
             * Get all of the dev's info based on a dev group id
             */
            function getDevelopersInDevGroup(devGroupId) {

                //holds all of the developers in the dev group with the passed in id
                var allDevsInGroup = [];

                //get the dev group
                var devGroup = playbackData.allDeveloperGroups[devGroupId];

                //if the dev group was found
                if(devGroup) {

                    //go through all of the member ids of the matched dev group
                    for(var i = 0;i < devGroup.memberIds.length;i++) {

                        //use the hash of all devs (keyed by their id) to retrieve a dev based on the group's member ids
                        var dev = playbackData.allDevelopers[devGroup.memberIds[i]];

                        //add the found member
                        allDevsInGroup.push(dev);
                    }
                }//else- no dev group with that id was found, return an empty array

                return allDevsInGroup;
            }

            /*
             * This function returns an array of all developer groups in the system. The format for the
             * elements in the array looks like this:
             * [
             *   {devGroupId: 123, memberIds: [ {id: 1, firstName: "Mark", lastName: "Mahoney", email: "mmahoney@carthage.edu"} ]}
             *   {devGroupId: 234, memberIds: [ {id: 2, firstName: "Laura", lastName: "Mahoney", email: "laura#mail.com"}, {id: 1, firstName: "Mark", lastName: "Mahoney", email: "mmahoney@carthage.edu"} ]},
             * ]
             */
            function getAllDevelopersInEachGroup() {

                //holds all the dev groups and all of their members
                var allDevGroups = [];

                //go through all of the dev groups in the system
                for(var devGroupId in playbackData.allDeveloperGroups) {
                    if(playbackData.allDeveloperGroups.hasOwnProperty(devGroupId)) {

                        var existingDevGroup = playbackData.allDeveloperGroups[devGroupId];

                        //create an object to hold the dev group info
                        var devGroup = {
                            devGroupId: existingDevGroup.id,
                            members: []
                        };

                        //go through all of the member ids of the matched dev group
                        for(var i = 0;i < existingDevGroup.memberIds.length;i++) {

                            //use the hash of all devs (keyed by their id) to retrieve a dev based on the group's member ids
                            var dev = playbackData.allDevelopers[existingDevGroup.memberIds[i]];

                            //add the dev to the groups list of members
                            devGroup.members.push(dev);
                        }

                        //sort the members by their names
                        sortArrayOfDevsByName(devGroup.members);

                        //add the group
                        allDevGroups.push(devGroup)
                    }
                }

                //sort the dev groups by number of members
                allDevGroups.sort(function(devGroup1, devGroup2) {
                    return devGroup1.members.length - devGroup2.members.length;
                });

                return allDevGroups;
            }

            /*
             * Sort a passed in array of developers by their names. Sort by last name, if two
             * devs have the same last name then sort by their first names.
             */
            function sortArrayOfDevsByName(devs) {

                //sort the dev array by name
                devs.sort(function (dev1, dev2) {

                    //if the developers' last names are the same
                    if(dev1.lastName.toLowerCase() === dev2.lastName.toLowerCase()) {

                        //sort by their first names
                        if(dev1.firstName.toLowerCase() < dev2.firstName.toLowerCase()) {

                            return -1;

                        } else if (dev1.firstName.toLowerCase() > dev2.firstName.toLowerCase()) {

                            return 1;

                        } else {

                            return 0;
                        }

                    } else { //last names are different

                        //sort by last name
                        if(dev1.lastName.toLowerCase() < dev2.lastName.toLowerCase()) {

                            return -1;

                        } else if(dev1.lastName.toLowerCase() > dev2.lastName.toLowerCase()) {

                            return 1;

                        } else {

                            return 0;
                        }
                    }
                });
            }

            /*
             * Displays all of the dev groups and their members to select for filtering
             */
            function displayAllDevGroupMembersForFiltering() {

                //get the element that holds all of the developer groups
                var devGroupFilter = document.querySelector("#devGroupFilter");

                //clear the contents of the div
                devGroupFilter.innerHTML = "";

                //get all the dev groups and their members
                var allGroups = getAllDevelopersInEachGroup();

                //go through each developer group
                for(var i = 0;i < allGroups.length;i++) {

                    //create a checkbox
                    var devCheckbox = document.createElement("input");
                    devCheckbox.setAttribute("type", "checkbox");
                    devCheckbox.setAttribute("name", "devGroupSelect");
                    devCheckbox.setAttribute("value", allGroups[i].devGroupId);
                    devCheckbox.setAttribute("checked", "");
                    devCheckbox.classList.add("devGroupSelectCheckbox");

                    //create a label and add the checkbox and a dev name
                    var devLabel = document.createElement("label");
                    devLabel.appendChild(devCheckbox);

                    //store the names of all the devs in the group
                    var devName = document.createElement("span");

                    //go through all of the members in the group
                    for(var j = 0;j < allGroups[i].members.length;j++) {

                        //add a dev group member name
                        devName.innerHTML += " " + allGroups[i].members[j].firstName + " " + allGroups[i].members[j].lastName;

                        //if there are more add a comma
                        if(j < allGroups[i].members.length - 1) {

                            devName.innerHTML += ", ";
                        }
                        //else- last one nothing needed
                    }

                    //add the names to the label
                    devLabel.appendChild(devName);

                    //add the label to the div of all developers and a newline
                    devGroupFilter.appendChild(devLabel);
                    devGroupFilter.appendChild(document.createElement("br"));
                }
            }

            /*
             * Checks to see if the latest event was created by a dev group that is different than
             * the last event's dev group and if so updates the dev info images to display who is
             * responsible for this character of code.
             */
            function showDevsInDevGroup(codeEvent) {

                //if the latest code character was created by a dev group that is different than
                //the current dev group (current dev group is the last one responsible for an event)
                if(playbackData.latestPlaybackEventDevGroupId !== codeEvent.createdByDevGroupId) {

                    //get the info about all of the dev's in the new dev group who made the latest change
                    var devs = getDevelopersInDevGroup(codeEvent.createdByDevGroupId);

                    //get the element to fill with dev info
                    var eventDevInfo = document.querySelector("#eventDevInfo");

                    //clear out the old dev info
                    eventDevInfo.innerHTML = "";

                    //go through each of the developers
                    for(var j = 0;j < devs.length;j++) {

                        //add some dev info to the page
                        eventDevInfo.appendChild(getDevElement(devs[j], 50));
                    }

                    //store the new dev group id as the latest one
                    playbackData.latestPlaybackEventDevGroupId = codeEvent.createdByDevGroupId;
                }
                //else- this code character was made by the same dev group that was responsible for the last one
            }

            /*
             * Creates an element with devloper info in it. Creates an image with a gravatar and
             * contact info.
             */
            function getDevElement(dev, sizeOfImage) {

                //add the name and the link to a span
                var devSpan = document.createElement("span");

                //hash the developer's email
                var emailHash = md5(dev.email.trim().toLowerCase());

                //create the img and add attributes for a bootstrap popover
                var devAvatar = document.createElement("img");

                //ask for sizeOfImageXsizeOfImage pixel images and identicons if the dev doesn't have a gravatar
                devAvatar.setAttribute("src", "http://www.gravatar.com/avatar/" + emailHash + "?s=" + sizeOfImage + "&d=identicon");
                devAvatar.setAttribute("data-toggle", "popover");
                devAvatar.setAttribute("data-placement", "top");
                devAvatar.setAttribute("data-html", "true");
                devAvatar.setAttribute("data-trigger", "hover click focus");
                devAvatar.setAttribute("data-title", dev.firstName + "'s Contact Info");
                devAvatar.setAttribute("data-content", "<strong>" + dev.firstName + " " + dev.lastName + "</strong><br><a href='mailto:" + dev.email + "'>" + dev.email + "</a>");
                devAvatar.classList.add("devImage");
                devAvatar.classList.add("img-thumbnail");

                //add the img
                devSpan.appendChild(devAvatar);

                //make the popups with additional info work correctly
                $(devAvatar).popover();

                return devSpan;
            }

            //*****************************************************************************
            //                         Comment related code
            //                         --------------------
            //*****************************************************************************
            /*
             * Clear out the comment div and un-highlight previous comment text
             */
            function clearPreviousComment() {

                //get the container of code comments
                var codeCommentContainer = document.querySelector("#codeCommentContainer");

                //empty out the old comment info
                codeCommentContainer.innerHTML = "--";
                
                //remove any previously highlighted code
                removeCommentCodeHighlights();

                //revoke any audio comments
                revokeActualAudioComments(); 
            }

            /*
             * Display one or more comments for the passed in event.
             */
            function displayComments(commentsForAnEvent) {
                
                //revoke any previous audio comments before adding new ones
                revokeActualAudioComments();                 

                //get the container of code comments and clear out all of the old comment info
                var codeCommentContainer = document.querySelector("#codeCommentContainer");
                codeCommentContainer.innerHTML = "";

                //make sure the playback comments tab is active to display the comment
                makePlaybackCommentTabActive();

                //go through each comment
                for(var i = 0;i < commentsForAnEvent.length;i++) {

                    //get the current comment
                    var comment = commentsForAnEvent[i];

                    //build up the ui for the comment
                    buildCommentUI(comment, codeCommentContainer);
                }

                //if there are any highlighted code characters make sure the playback tab is visible and the highlighted code is visible
                focusOnHighlightedCommentCode(commentsForAnEvent[0]);
            }

            /*
             * This function makes sure that if there is any highlighted code in a comment that the highlighted code
             * is visible on the screen. It first makes sure the playback tab is active and then scrolls to the first
             * highlighted character. 
             */
            function focusOnHighlightedCommentCode(comment) {
                    
                //if there is at least one highlighted code
                if(comment.selectedCodeIds.length > 0) {
                    
                    //remove any previous highlights
                    removeCommentCodeHighlights();

                    //add the new highlights
                    addCommentCodeHighlights(comment);

                    //get the first highlighted code character
                    var firstHighlightedCodeCharacter = document.querySelector("#" + comment.selectedCodeIds[0]);

                    //get the file that this code is in
                    var firstHighlightedCodeCharacterFileId = firstHighlightedCodeCharacter.parentElement.getAttribute("id").substr("playbackWindow-".length);

                    //make sure the tab is active
                    makePlaybackTabActive(firstHighlightedCodeCharacterFileId);

                    //move the cursor 
                    handleScroll(firstHighlightedCodeCharacter);
                }
            }

            /*
             * Highlights code associated with a comment
             */
            function addCommentCodeHighlights(comment) {
                
                //go through all of the code that is to be highlighted
                for(var i = 0;i < comment.selectedCodeIds.length;i++) {

                    //get the code on the screen
                    var code = document.querySelector("#" + comment.selectedCodeIds[i]);

                    //hihglight the code
                    code.classList.add("commentRelevant");
                }
            }

            /*
             * Makes any highlighted comment code un-highlighted
             */ 
            function removeCommentCodeHighlights() {
                
                //remove any existing previously highlighted elements
                var previouslyHighlightedCodeComments = document.querySelectorAll(".commentRelevant");

                //go through the highlighted code 
                for(var i = 0;i < previouslyHighlightedCodeComments.length;i++) {
                    
                    //remove the class that highlights comments on each element
                    previouslyHighlightedCodeComments[i].classList.remove("commentRelevant");
                }
            }

            /*
             * Make the tab that displays comments active.
             */
            function makePlaybackCommentTabActive() {

                //make the add new comment list item inactive
                var addNewCommentListItem = document.querySelector("#addNewCommentListItem");
                addNewCommentListItem.classList.remove("active");

                //make the playback comment list item active
                var playbackCommentsListItem = document.querySelector("#playbackCommentsListItem");
                playbackCommentsListItem.classList.add("active");

                //make the add new comment tab inactive
                var addNewCommentTab = document.querySelector("#addNewCommentTab");
                addNewCommentTab.classList.remove("active");
                addNewCommentTab.classList.remove("in");

                //make the playback comments tab active
                var playbackCommentsTab = document.querySelector("#playbackCommentsTab");
                playbackCommentsTab.classList.add("active");
                playbackCommentsTab.classList.add("in");
            }

            /*
             * Build a UI for the comment.
             */
            function buildCommentUI(comment, codeCommentContainer) {

                //grab the relevant info from the comment
                var text = comment.commentText;
                var devGroup = comment.developerGroupId;
                var timestamp = formatDateShortWithDayOfWeek(new Date(comment.timestamp));

                //create the div to hold the comment info and make it clickable
                var outerDiv = document.createElement("div");
                outerDiv.classList.add("well");
                outerDiv.classList.add("well-lg");
                
                //when someone clicks the comment
                outerDiv.addEventListener("click", function(e){

                    //get the active comment
                    activeCommentContainer = document.querySelector(".activeComment");

                    //if there is an active comment that is different than the one clicked
                    if(activeCommentContainer && activeCommentContainer !== outerDiv) {

                        //remove the active style
                        activeCommentContainer.classList.remove("activeComment");
                    }

                    //make the clicked comment active
                    outerDiv.classList.add("activeComment");

                    //if there are any highlighted code characters make sure the playback tab is visible and the highlighted code is visible
                    focusOnHighlightedCommentCode(comment);

                });

                //for each of the comment images
                for(var i = 0;i < comment.images.length;i++) {
                    
                    //get a small pic of the image 
                    var smallImage = getCommentImagePreview(286, 225, comment.images[i]);

                    //create a link so users can click the small image and bring up the comment pic modal
                    var smallImageLink = document.createElement("a");
                    smallImageLink.setAttribute("href", "#");
                    smallImageLink.setAttribute("data-toggle", "modal");
                    smallImageLink.setAttribute("data-target", "#commentPictureDisplayModal");
                    smallImageLink.appendChild(smallImage);

                    //add the event handler
                    smallImageLink.addEventListener("click", function(e){
                        
                        //add the image to the large display
                        var largeImageDisplay = document.querySelector("#largeImageDisplay");
                        largeImageDisplay.src = e.target.getAttribute("src");

                        //re-display the comment text to the modal also
                        var commentTextInLargeDisplay = document.querySelector("#commentTextInLargeDisplay");
                        commentTextInLargeDisplay.innerHTML = comment.commentText;
                    });

                    outerDiv.appendChild(smallImageLink);
                }

                //for each of the audio comments
                for(var i = 0;i < comment.audioComments.length;i++) {

                    //create an audio control element
                    var audio = document.createElement("audio");
                    audio.setAttribute("controls", "");
                    audio.classList.add("actualAudioClip");

                    //get the data url that contains the audio and convert it back to a blob (http://stackoverflow.com/questions/12168909/blob-from-dataurl)
                    var audioCommentDataURL = comment.audioComments[i];

                    //get the base64 encoded data portion of the data url and decode it back to raw data 
                    var rawAudioData = atob(audioCommentDataURL.split(",")[1]);
                    //buffer the data 
                    var arrBuff = new ArrayBuffer(rawAudioData.length);
                    var uintArr = new Uint8Array(arrBuff);
                    for (var j = 0; j < rawAudioData.length; j++) {
                        uintArr[j] = rawAudioData.charCodeAt(j);
                    }
                    //turn the buffer into an audio blob
                    var blob = new Blob([arrBuff], {"type": "audio/ogg; codecs=opus"});

                    //create a data url and load the audio control with it
                    var audioURL = window.URL.createObjectURL(blob);
                    audio.setAttribute("src", audioURL);

                    outerDiv.appendChild(audio);
                }

                var divPanel = document.createElement("div");
                divPanel.classList.add("panel");
                divPanel.classList.add("panel-default");

                //add the comment text
                var commentTextDiv = document.createElement("div");
                commentTextDiv.classList.add("codeCommentText");
                commentTextDiv.classList.add("panel-body");
                commentTextDiv.appendChild(document.createTextNode(text === "" ? "--" : text));
                
                //add the comment author and timestamp
                var commentInfoDiv = document.createElement("div");
                commentInfoDiv.classList.add("panel-footer");

                //display the developers who made the comment
                //get the info about all of the dev's in the dev group who made the comment
                var devs = getDevelopersInDevGroup(devGroup);

                //go through each of the developers
                for(var j = 0;j < devs.length;j++) {

                    //add the dev group who made the comment
                    commentInfoDiv.appendChild(getDevElement(devs[j], 30));
                }

                //add the comment timestamp
                var commentTimestamp = document.createElement("span");
                commentTimestamp.classList.add("codeCommentTimestamp");
                commentTimestamp.appendChild(document.createTextNode(timestamp));
                commentInfoDiv.appendChild(commentTimestamp);

                divPanel.appendChild(commentTextDiv);
                divPanel.appendChild(commentInfoDiv);
                outerDiv.appendChild(divPanel);

                //TODO edit the comment
            	// var editCommentButton = document.createElement("button");
            	// editCommentButton.innerHTML = "Edit";
            	// editCommentButton.classList.add("btn");
            	// editCommentButton.classList.add("btn-default");
            	// editCommentButton.classList.add("btn-xs");
            	// editCommentButton.addEventListener("click", function(e) {console.log("edit");});


                //build a dropdown list of options to delete from the playback only or the playback and the db
                // <div class="btn-group">
                //     <button type="button" class="btn">Delete</button>
                //     <button type="button" class="btn dropdown-toggle" data-toggle="dropdown">
                //         <span class="caret"></span>
                //     </button>
                //     <ul class="dropdown-menu">
                //         <li><a href="#">Delete in the browser only</a></li>
                //         <li><a href="#">Delete in the browser and in the editor's database</a></li>
                //     </ul>
                // </div>

                var deleteCommentButtonGroup = document.createElement("div");
                deleteCommentButtonGroup.classList.add("btn-group"); 
                //deleteCommentButtonGroup.classList.add("pull-right");

                var deleteCommentButton = document.createElement("button");
                deleteCommentButton.classList.add("btn");
                deleteCommentButton.classList.add("btn-xs");
                deleteCommentButton.innerHTML = "Delete";
                deleteCommentButton.addEventListener("click", function(e) {
                    
                    //by default if the either of the options is not selected then do a full delete

                    //delete the comment in the browser
                    deleteCommentInBrowserOnly(comment, outerDiv);

                    //delete the comment in the editor's database
                    deleteCommentInEditorsDB(comment);
                });

                var deleteCommentButtonToggle = document.createElement("button");
                deleteCommentButtonToggle.classList.add("btn");
                deleteCommentButtonToggle.classList.add("btn-xs");
                deleteCommentButtonToggle.classList.add("dropdown-toggle");
                deleteCommentButtonToggle.setAttribute("data-toggle", "dropdown");

                var toggleButtonSpan = document.createElement("span");
                toggleButtonSpan.classList.add("caret");
                deleteCommentButtonToggle.appendChild(toggleButtonSpan);

                var deleteCommentListOptions = document.createElement("ul");
                deleteCommentListOptions.classList.add("dropdown-menu");

                var deleteInBrowserOnlyListItem = document.createElement("li");
                var deleteInBrowserOnlyAnchor = document.createElement("a");
                deleteInBrowserOnlyAnchor.setAttribute("href", "#");
                deleteInBrowserOnlyAnchor.innerHTML = "Delete in the browser only";
                deleteInBrowserOnlyAnchor.addEventListener("click", function(e) {

                    //delete in the browser, do not send a request to delete to the editor
                    deleteCommentInBrowserOnly(comment, outerDiv);
                });
                deleteInBrowserOnlyListItem.appendChild(deleteInBrowserOnlyAnchor);

                var deleteInBrowserAndEditorDBListItem = document.createElement("li");
                var deleteInBrowserAndEditorDBAnchor = document.createElement("a");
                deleteInBrowserAndEditorDBAnchor.setAttribute("href", "#");
                deleteInBrowserAndEditorDBAnchor.innerHTML = "Delete in the browser and in the editor's database";
                deleteInBrowserAndEditorDBAnchor.addEventListener("click", function(e) {
                    
                    //delete in the browser and in the db
                    deleteCommentInBrowserOnly(comment, outerDiv);
                    deleteCommentInEditorsDB(comment);
                });
                deleteInBrowserAndEditorDBListItem.appendChild(deleteInBrowserAndEditorDBAnchor);

                deleteCommentListOptions.appendChild(deleteInBrowserOnlyListItem);
                deleteCommentListOptions.appendChild(deleteInBrowserAndEditorDBListItem);

                deleteCommentButtonGroup.appendChild(deleteCommentButton);
                deleteCommentButtonGroup.appendChild(deleteCommentButtonToggle);
                deleteCommentButtonGroup.appendChild(deleteCommentListOptions);

                var deleteCommentDiv = document.createElement("div");
                deleteCommentDiv.appendChild(deleteCommentButton);
                deleteCommentDiv.appendChild(deleteCommentButtonGroup);
                outerDiv.appendChild(deleteCommentDiv);

                codeCommentContainer.appendChild(outerDiv);
            }

            function deleteCommentInBrowserOnly(comment, outerDiv) {
                
                //get the array of events at the event id
                var arrayOfCommentsAtThisEvent = playbackData.comments[comment.displayCommentEvent.id];
                var indexOfComment = arrayOfCommentsAtThisEvent.indexOf(comment);

                //if the comment was found
                if(indexOfComment >= 0) {

                    //remove the comment container
                    outerDiv.parentNode.removeChild(outerDiv);

                    //remove the comment
                    arrayOfCommentsAtThisEvent.splice(indexOfComment, 1);
                    
                    //if there are no more comments at this event
                    if(arrayOfCommentsAtThisEvent.length === 0) {

                        //remove the whole collection for this event
                        delete playbackData.comments[comment.displayCommentEvent.id];
                    }
                }
            }

            function deleteCommentInEditorsDB(deletedComment) {
                
                //delete the comment on the server
                var xmlhttp = new XMLHttpRequest();   
                xmlhttp.addEventListener("load", function(){

                    //TODO add something to the UI
                    console.log("successfully deleted a comment and receieved a response");
                });

                xmlhttp.addEventListener("error", function(){

                    //TODO add a message to the UI indicating that there is no server to respond
                    console.log("was not able to delete a comment");
                });

                xmlhttp.open("DELETE", "/comment");
                xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                xmlhttp.send(JSON.stringify(deletedComment));
            }

            /*
             * Get an img element for the image
             */
            function getCommentImagePreview(width, height, dataURL) {

                var commentImage = document.createElement("img");
                commentImage.setAttribute("height", height);
                commentImage.setAttribute("width", width);
                commentImage.classList.add("commentImage");
                commentImage.classList.add("img-thumbnail");

                //make the image source the canvas image
                commentImage.src= dataURL;

                return commentImage;
            }

            /*
             * Get an image with a checkbox in a table
             */
            function getSelectableCommentImagePreview(commentImage, imgId, className) {

                var table = document.createElement("table");
                table.classList.add("selectableCommentImageTable");

                table.appendChild(document.createElement("tr"));
                table.appendChild(document.createElement("tr"));

                var chBox = document.createElement("input");
                chBox.setAttribute("type", "checkbox");
                chBox.setAttribute("value", imgId);
                chBox.setAttribute("checked", "checked");
                chBox.classList.add(className);

                var td = document.createElement("td");
                td.appendChild(commentImage);
                table.children[0].appendChild(td);

                td = document.createElement("td");
                td.appendChild(document.createTextNode(""));
                table.children[1].appendChild(td);

                td = document.createElement("td");
                td.appendChild(chBox);
                table.children[1].appendChild(td);

                return table;
            }

            /*
             * Get the drawing canvas ready for drawing
             */
            function setUpDrawingCanvas()
            {
                //store the canvas
                canvasData.commentCanvas = document.querySelector("#commentCanvas");
                //store the 2D context
                canvasData.commentCanvasContext = commentCanvas.getContext("2d");

                //set the drawing line parameters
                canvasData.commentCanvasContext.lineWidth = 3;
                canvasData.commentCanvasContext.lineJoin = 'round';
                canvasData.commentCanvasContext.lineCap = 'round';
                canvasData.commentCanvasContext.strokeStyle = 'blue';

                //get the modal that holds the canvas
                var editCommentPictureModal = document.querySelector("#editCommentPictureModal");

                //capture mouse moves
                canvasData.commentCanvas.addEventListener("mousemove", function(e){

                    //store the old current mouse position and the previous mouse position
                    canvasData.previousMousePosition.x = canvasData.currentMousePosition.x;
                    canvasData.previousMousePosition.y = canvasData.currentMousePosition.y;

                    //get the bounding rectangle
                    var boundingRectangle = canvasData.commentCanvas.getBoundingClientRect();

                    //get the new mouse position
                    canvasData.currentMousePosition.x = e.clientX - boundingRectangle.left;
                    canvasData.currentMousePosition.y = e.clientY - boundingRectangle.top;
                });

                //mouse down
                canvasData.commentCanvas.addEventListener('mousedown', function(e) {

                    //add an additional listener to draw
                    commentCanvas.addEventListener('mousemove', onPaint);
                });

                //mouse up
                commentCanvas.addEventListener('mouseup', function() {

                    //remove the additional mouse move listener
                    canvasData.commentCanvas.removeEventListener('mousemove', onPaint);
                });

                //an additional mouse listener to paint part of a line
                var onPaint = function() {

                    //draw the line
                    canvasData.commentCanvasContext.beginPath();
                    canvasData.commentCanvasContext.moveTo(canvasData.previousMousePosition.x, canvasData.previousMousePosition.y);
                    canvasData.commentCanvasContext.lineTo(canvasData.currentMousePosition.x, canvasData.currentMousePosition.y);
                    canvasData.commentCanvasContext.closePath();
                    canvasData.commentCanvasContext.stroke();
                };
            }

            /*
             * Sets up the page for recording audio comments
             */
            function setUpAudioRecordingOfComments() {
                
                //get the user media or an alternative if it doesn't exist
                navigator.getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);

                //if there is media support
                if (navigator.getUserMedia && window.MediaRecorder) {

                    //record audio only
                    var constraints = { 
                        audio: true
                    };

                    //holds the raw audio data
                    var chunks = [];

                    //if the media object can be configured
                    var onSuccess = function(stream) {

                        //use the stream to make a media recorder
                        var mediaRecorder = new MediaRecorder(stream);

                        //the function that will be called once the audio data is ready to be stored                        
                        mediaRecorder.onstop = function(e) {

                            //holds every audio clip
                            var audioClipDiv = document.createElement("div");
                            
                            var audio = document.createElement("audio");
                            audio.setAttribute("controls", "");
                            audio.classList.add("potentialAudioClip");

                            //create a blob of the audio data
                            var blob = new Blob(chunks, {"type": "audio/ogg; codecs=opus"});
                            
                            //use a reader to read the blob to turn it into a data url that can be stored in the json file
                            var reader = new FileReader();

                            //function to be called after reading as a data url
                            reader.addEventListener("load", function () {
                                    
                                //add the data url to the collection of audio comments
                                audioComments.push(reader.result);

                            }, false);

                            //begin the read process
                            reader.readAsDataURL(blob);

                            //empty out the chunks, they aren't needed anymore for this bit of audio
                            chunks = [];
                            
                            //create a data url and set the audio control to point to it
                            var audioURL = window.URL.createObjectURL(blob);
                            audio.setAttribute("src", audioURL);
                            
                            var deleteButton = document.createElement("button");
                            deleteButton.textContent = "Delete";
                            deleteButton.classList.add("btn");
                            deleteButton.classList.add("btn-default");
                            deleteButton.classList.add("btn-xs");
                            
                            deleteButton.addEventListener("click", function(e) {
                                
                                //remove the whole audio clip div
                                evtTgt = e.target;
                                evtTgt.parentNode.parentNode.removeChild(evtTgt.parentNode);
                            });

                            //add the elements to a div
                            audioClipDiv.appendChild(audio);
                            audioClipDiv.appendChild(deleteButton);

                            audioCommentClips = document.querySelector("#audioCommentClips");
                            audioCommentClips.appendChild(audioClipDiv);
                        }

                        mediaRecorder.ondataavailable = function(e) {
                            
                            //add a new chunk of raw audio data 
                            chunks.push(e.data);

                            //console.log("Added chunk: data:" + e.data);
                        }

                        //add a click handler to control recording
                        document.querySelector("#addNewAudioComment").addEventListener("click", function(e) {

                            //get the button that was pressed                
                            var audioRecordButton = e.target;

                            //get the state of recording from an attribute in the button itself
                            var recordingState = audioRecordButton.getAttribute("audioRecording") === "true" ? "recording" : "idle";

                            //if we are in the recording state
                            if(recordingState === "recording") {

                                //change to idle in the button attribute
                                audioRecordButton.setAttribute("audioRecording", "false");

                                //set the text of the button from 'Stop Recording' to 'Start Recording' (keep the span next to the text in the button) 
                                audioRecordButton.innerHTML = audioRecordButton.innerHTML.replace("Stop Recording", "Start Recording");

                                //get the recording icon next to the text
                                var recordingIcon = document.querySelector("#audioRecordingStateIcon");
                                
                                //update the UI
                                recordingIcon.classList.remove("audio-button-recording");
                                //recordingIcon.classList.remove("glyphicon-record");
                                //recordingIcon.classList.add("glyphicon-stop");

                                //stop the timer that makes the recording icon blink
                                window.clearInterval(audioRecordBlinkTimer);

                                //stop recording
                                mediaRecorder.stop();

                            } else { //we are in the idle state
                                
                                //change to the recording state in the button attribute
                                audioRecordButton.setAttribute("audioRecording", "true");

                                //set the text of the button from 'Start Recording' to 'Stop Recording' (keep the span next to the text in the button) 
                                audioRecordButton.innerHTML = audioRecordButton.innerHTML.replace("Start Recording", "Stop Recording")
                                
                                //get the recording icon next to the text
                                var recordingIcon = document.querySelector("#audioRecordingStateIcon");
                                
                                //update the UI
                                recordingIcon.classList.add("audio-button-recording");
                                //remove the class in a short time for the first blink
                                window.setTimeout(function() {
                                    recordingIcon.classList.remove("audio-button-recording");
                                }, 1000);
                                //recordingIcon.classList.remove("glyphicon-stop");
                                //recordingIcon.classList.add("glyphicon-record");

                                //set a timed interval to turn on the blink
                                audioRecordBlinkTimer = window.setInterval(function() {

                                    //add a blink class
                                    recordingIcon.classList.add("audio-button-recording");
                                    
                                    //in the future, turn off the blink
                                    window.setTimeout(function() {
                                        recordingIcon.classList.remove("audio-button-recording");
                                    }, 1000);
                                }, 1500);

                                //start the recording process
                                mediaRecorder.start();
                            }                    
                        });
                    }

                    //if the media object cannot be configured
                    var onError = function(err) {

                        console.log('The following error occured: ' + err);
                    }
                    
                    //configure the user media object
                    navigator.getUserMedia(constraints, onSuccess, onError);

                } else { //audio recording is not supported in this browser

                    //get the button that adds an audio comment
                    var addNewAudioCommentButton = document.querySelector("#addNewAudioComment");

                    //disable the button
                    addNewAudioCommentButton.disabled = true;    
                }
            }
            
            /*
             * Revokes any actual audio comments
             */
            function revokeActualAudioComments() {
                
                //get all of the previous actual audio comment controls to revoke the object url
                var actualAudioClips = document.querySelectorAll("actualAudioClip");
                
                //go through each one and revoke the object url for it
                for(var i = 0;i < actualAudioClips.length;i++) {

                    var actualAudioClip = actualAudioClips[i];

                    //the browser is holding onto the audio object, free it up
                    window.URL.revokeObjectURL(actualAudioClip.getAttribute("src"));
                }
            }

            /*
             * Revokes any potential audio comments
             */
            function revokePotentialAudioComments() {
                //get each potential clip audio control and revoke the object url
                var potentialAudioClips = document.querySelectorAll("potentialAudioClip");
                
                //go through each one and revoke the object url for it
                for(var i = 0;i < potentialAudioClips.length;i++) {

                    var potentialAudioClip = potentialAudioClips[i];
                    
                    //the browser is holding onto the audio object, free it up
                    window.URL.revokeObjectURL(potentialAudioClip.getAttribute("src"));
                }
            }

            //*****************************************************************************
            //                      Statistics-related code
            //                      -----------------------
            //*****************************************************************************
            
            /*//Object to hold statistics:
            //numInserts, numDeletes, numFileDirEvents: the number of each event type we've encountered during playback
            //eventsByDevGroup: a list of objects representing contributing developer groups in the format:
            //  {id: developer group's id, numInserts: inserts by this dev group, numDeletes: deletes by this group, numEvents: total events from this group}
            //lastDevGroupId, lastDevGroupIndex: the active developer group shouldn't change too often, so these ensure we only calculate the index for a dev group if we change groups
            //modifiedFiles: files that have been changed
            var statisticsData = {
                numInserts: 0,
                numDeletes: 0,
                numFileDirEvents: 0,
                eventsByDevGroup: [],
                lastDevGroupId: "none",
                lastDevGroupIndex: -1,
                modifiedFiles: [],
            };*/

            /*
             *  Looks for the specified dev group id in eventsByDevGroup. If found, returns the index for that group's object.
             *  Otherwise, adds an object for them and returns the index to that.
             */
            function getDevGroupIndex(devGroupId) {
                 //Set the position to an impossible value so we can know whether it was found
                 var retVal = -1;
                 
                //If the list is empty, of course we're adding a new dev group
                if(statisticsData.eventsByDevGroup.length === 0) {
                    var newDevGroup = {
                        id: devGroupId,
                        numInserts: 0,
                        numDeletes: 0,
                        numEvents: 0
                    };
                    statisticsData.eventsByDevGroup.push(newDevGroup);
                    //This is a one-item list, so 0 is the only valid index
                    retVal = 0;
                }
                else { //There's already at least one dev group in the list
                    //Find out if this dev group has done anything yet. If so, set currentDevGroupPosition accordingly
                    //TODO: See if there's a better way to do this
                    for(var i = 0; i < statisticsData.eventsByDevGroup.length; i++) {
                        if(statisticsData.eventsByDevGroup[i].id === devGroupId) {
                            retVal = i;
                            break;
                        }
                    }
                    //If this dev group hasn't done anything before, add them to the list and set their index as
                    //the current position
                    if(retVal === -1) {
                        var newDevGroup = {
                            id: devGroupId,
                            numInserts: 0,
                            numDeletes: 0,
                            numEvents: 0
                        };
                        statisticsData.eventsByDevGroup.push(newDevGroup);
                        //This dev group got pushed to the end of the list, so their position will be at the end of the list
                        retVal = statisticsData.eventsByDevGroup.length - 1;
                    }
                }
                //Give the people what they want
                return retVal;
            }

            /*
             *  When we take a step, update the counter for the appropriate event type
             */
            function updateStatisticsOneStep(direction, newEvent) {
                //debug
                //console.log("New Event's type: " + newEvent.type);
                //make a short, sweet variable for the current step's type (trust step to keep us in bounds for now)
                //var currentType = playbackData.codeEvents[playbackData.codeEventsIndex].type;
                var currentType = newEvent.type;

                //The file this event concerns (so we can check if this file has been modified before)
                var currentFile = newEvent.fileId;
                
                //Make a variable for which index of the eventsByDevGroup list we're using
                var currentDevGroupPosition = -1;

                //The index in modifiedFiles for the file this event relates to
                var currentModifiedFilePosition = -1;

                //If the active dev group hasn't changed since the last event, then the index we're accessing hasn't changed either
                if(newEvent.createdByDevGroupId === statisticsData.lastDevGroupId) {
                    currentDevGroupPosition = statisticsData.lastDevGroupIndex;
                }
                else { //The active dev group changed
                    //Get the new active dev group's index in eventsByDevGroup and update lastDevGroupId and Index
                    currentDevGroupPosition = getDevGroupIndex(newEvent.createdByDevGroupId);
                    statisticsData.lastDevGroupId = newEvent.createdByDevGroupId;
                    statisticsData.lastDevGroupIndex = currentDevGroupPosition;
                }

                //If we know of any modified files and this event has a fileId (excludes directories)
                if(statisticsData.modifiedFiles.length > 0 && newEvent.fileId !== undefined) {
                    //We haven't started looking yet, so of course there's no match
                    var found = false;
                    //Go through the list and check for this file id
                    for(var i = 0; i < statisticsData.modifiedFiles.length; i++) {
                        //If we find a match, we can stop looking. We found a match
                        if(statisticsData.modifiedFiles[i].id === newEvent.fileId) {
                            found = true;
                            currentModifiedFilePosition = i;
                            break;
                        }
                    }
                    //If we didn't find a match, this file isn't in the list yet. Add it.
                    if(!found) {
                        //We start the event counter at zero because it'll get incremented later. Otherwise events will never be 0
                        //If events never hits 0, files will never be removed from the list going backwards
                        statisticsData.modifiedFiles.push({name: newEvent.initialName, id: newEvent.fileId, events: 0});
                        currentModifiedFilePosition = statisticsData.modifiedFiles.length - 1;
                        //debug
                        console.log('Added new file: ' + newEvent.fileId + ' : ' + newEvent.initialName);
                    }
                } 
                //fileId is undefined for directory events, so we'll just ignore those
                else if(newEvent.fileId === undefined) {
                    //Do nothing
                }
                else { //The list is empty and we have a file id
                    //We know this file is new, so just add it to the list
                    statisticsData.modifiedFiles.push({name: newEvent.initialName, id: newEvent.fileId, events: 0});
                    //This is the only file at this point, so of course it's at index 0
                    currentModifiedFilePosition = 0;
                    //debug
                        console.log('Added new file: ' + newEvent.fileId + ' : ' + newEvent.initialName);
                }

                //If we're going forward, then figure out the new event's type and increment the
                //appropriate counter (there's a new insert, delete, or whatever)
                if(direction === "forward") {
                    if(currentType === "Insert") {
                        statisticsData.numInserts++;
                        //This is an Insert Event for this dev group, so increments the insert and event counters 
                        statisticsData.eventsByDevGroup[currentDevGroupPosition].numInserts++;
                        statisticsData.eventsByDevGroup[currentDevGroupPosition].numEvents++;
                        //debug
                        //console.log("Plus one insert for " + eventsByDevGroup[currentDevGroupPosition].id);
                    }
                    else if(currentType === "Delete") {
                        statisticsData.numDeletes++;
                        //This is a Delete Event, so increment both counters
                        statisticsData.eventsByDevGroup[currentDevGroupPosition].numDeletes++;
                        statisticsData.eventsByDevGroup[currentDevGroupPosition].numEvents++;
                        //debug
                        //console.log("Plus one delete for " + eventsByDevGroup[currentDevGroupPosition].id);
                    }
                    else { //Either a file or directory event
                        statisticsData.numFileDirEvents++;
                        //The spec makes no mention of tracking file/dir events by dev, so ust up the total event counter
                        statisticsData.eventsByDevGroup[currentDevGroupPosition].numEvents++;
                        //debug
                        //console.log("Plus one file/dir event");
                    }
                    //Make sure this event concerns a file
                    if(currentModifiedFilePosition > -1) {
                        statisticsData.modifiedFiles[currentModifiedFilePosition].events++;
                    }
                }
                else { //We're going backwards, decrement the appropriate counter
                    if(currentType === "Insert") {
                        statisticsData.numInserts--;
                        statisticsData.eventsByDevGroup[currentDevGroupPosition].numInserts--;
                        statisticsData.eventsByDevGroup[currentDevGroupPosition].numEvents--;
                        //debug
                        //console.log("Minus one insert");
                    }
                    else if(currentType === "Delete") {
                        statisticsData.numDeletes--;
                        statisticsData.eventsByDevGroup[currentDevGroupPosition].numDeletes--;
                        statisticsData.eventsByDevGroup[currentDevGroupPosition].numEvents--;
                        //debug
                        //console.log("Minus one delete");
                    }
                    else { //Either a file or directory event
                        statisticsData.numFileDirEvents--;
                        statisticsData.eventsByDevGroup[currentDevGroupPosition].numEvents--;
                        //debug
                        //console.log("Minus one file/dir event");
                    }

                    //If we've gone to a point before this dev group contributed anything, remove them from the contributor list
                    if(statisticsData.eventsByDevGroup[currentDevGroupPosition].numEvents === 0) {
                        statisticsData.eventsByDevGroup.splice(currentDevGroupPosition, 1);
                        statisticsData.lastDevGroupIndex = -1;
                        statisticsData.lastDevGroupId = "none";
                    }
                    //Make sure we're working with a valid index
                    if(currentModifiedFilePosition > -1) {
                        statisticsData.modifiedFiles[currentModifiedFilePosition].events--;
                        //If we've gone back to before this file was modified, forget this file
                        if(statisticsData.modifiedFiles[currentModifiedFilePosition].events === 0) {
                            statisticsData.modifiedFiles.splice(currentModifiedFilePosition, 1);
                            currentModifiedFilePosition = -1;
                        }
                    }
                }
                //debug
                //printAllStatistics();
                //printEachDevGroupEventCount();
            }

            /*
             *  If we're going back to the beginning and/or changing filters, we need to be able to reset
             *  counters and such. This function does that.
             */
            function clearStatisticsData() {
                //Zero out all statistics data
                statisticsData = {
                    numInserts: 0,
                    numDeletes: 0,
                    numFileDirEvents: 0,
                    eventsByDevGroup: [],
                    lastDevGroupId: "none",
                    lastDevGroupIndex: -1,
                    modifiedFiles: [],
                };
            }

            /*
             *  Prints the total number of inserts, deletes, and file/dir events. Used for debugging
             */
            function printAllStatistics() {
                console.log("Total inserts: " + statisticsData.numInserts);
                console.log("Total deletes: " + statisticsData.numDeletes);
                console.log("Total file and directory events: " + statisticsData.numFileDirEvents);
                if(statisticsData.modifiedFiles.length === 0) {
                    console.log("No files have been modified");
                }
                else {
                    console.log("All files with changes:");
                    for(var i = 0; i < statisticsData.modifiedFiles.length; i++) {
                        console.log("    " + statisticsData.modifiedFiles[i]);
                    }
                }

            }

            /*
             *  For each dev group that contributed, prints the id along with the number of inserts, deletes, and
             *  total events
             */
            function printEachDevGroupEventCount() {
                for(var i = 0; i < statisticsData.eventsByDevGroup.length; i++) {
                    console.log("Dev Group ID: " + statisticsData.eventsByDevGroup[i].id);
                    console.log("    Inserts: " + statisticsData.eventsByDevGroup[i].numInserts);
                    console.log("    Deletes: " + statisticsData.eventsByDevGroup[i].numDeletes);
                    console.log("    Total Events: " + statisticsData.eventsByDevGroup[i].numEvents);
                    //Add a blank line between dev groups
                    console.log(" ");
                }
            }
        </script>
	</body>
</html>