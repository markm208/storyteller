const Developer = require('./Developer.js');
const DeveloperGroup = require('./DeveloperGroup.js');
const FileBackedCollection = require('../FileBackedCollection.js');

/*
 * This class manages all devs and dev groups in the system. The data is stored
 * in a json file in the hidden storyteller directory. The class keeps track
 * of all developers in allDevelopers, all developer groups in 
 * allDeveloperGroups, and the active developer group in currentDeveloperGroup.
 * 
 * It creates two developers/groups- one for devs who want to remain anonymous
 * and one for events generated by the system. 
 */
class DeveloperManager extends FileBackedCollection {
    constructor(storytellerDirPath) {
        //init the base class
        super(storytellerDirPath, 'devs', 'devs.json');

        //if the json file exists
        if(this.fileExists()) {
            //read the data from the file and load the dev info
            this.read();
        } else { //no json file exists
            //create a system developer and an anonymous developer
            this.systemDeveloper = new Developer('Storyteller System', 'system@ourcodestories.com');
            this.anonymousDeveloper = new Developer('Anonymous Developer', 'anon@ourcodestories.com');

            //create a system and anon dev group
            this.systemDeveloperGroup = new DeveloperGroup();
            this.systemDeveloperGroup.addDeveloper(this.systemDeveloper);

            this.anonymousDeveloperGroup = new DeveloperGroup();
            this.anonymousDeveloperGroup.addDeveloper(this.anonymousDeveloper);

            //stores the developers created so far
            this.allDevelopers = {};
            this.allDevelopers[this.systemDeveloper.id] = this.systemDeveloper;
            this.allDevelopers[this.anonymousDeveloper.id] = this.anonymousDeveloper;

            //stores all of the developer groups
            this.allDeveloperGroups = {};
            this.allDeveloperGroups[this.systemDeveloperGroup.id] = this.systemDeveloperGroup;
            this.allDeveloperGroups[this.anonymousDeveloperGroup.id] = this.anonymousDeveloperGroup;

            //make the default dev group the anonymous one
            this.currentDeveloperGroupId = this.anonymousDeveloperGroup.id;

            //init the auto generating values (start at 2 for the anon and sys devs)
            Developer.nextId = 2;
            DeveloperGroup.nextId = 2;

            //write the relevant data to the file
            this.write();
        }
    }

    write() {
        //pass in an object to be written to a json file
        super.write({
            systemDeveloper: this.systemDeveloper, 
            anonymousDeveloper: this.anonymousDeveloper, 
            systemDeveloperGroup: this.systemDeveloperGroup,
            anonymousDeveloperGroup: this.anonymousDeveloperGroup,
            allDevelopers: this.allDevelopers,
            allDeveloperGroups: this.allDeveloperGroups,
            currentDeveloperGroupId: this.currentDeveloperGroupId,
            developerAutoGeneratedId: Developer.nextId,
            developerGroupAutoGeneratedId: DeveloperGroup.nextId
        });
    }

    read() {
        //read the data from the file
        const anObject = super.read();

        //store the data from the file back into this object
        //the objects have lost their types so I copy the objects into new instances of the classes
        this.systemDeveloper = new Developer(anObject.systemDeveloper.userName, anObject.systemDeveloper.email, anObject.systemDeveloper.avatarURL, anObject.systemDeveloper.id);
        this.anonymousDeveloper = new Developer(anObject.anonymousDeveloper.userName, anObject.anonymousDeveloper.email, anObject.anonymousDeveloper.avatarURL, anObject.anonymousDeveloper.id);
        this.systemDeveloperGroup = new DeveloperGroup(anObject.systemDeveloperGroup.id, anObject.systemDeveloperGroup.memberIds);
        this.anonymousDeveloperGroup = new DeveloperGroup(anObject.anonymousDeveloperGroup.id, anObject.anonymousDeveloperGroup.memberIds);

        //store the raw objects here and convert them below
        this.allDevelopers = anObject.allDevelopers;
        this.allDeveloperGroups = anObject.allDeveloperGroups;

        //set the auto-generated ids for the two classes
        Developer.nextId = anObject.developerAutoGeneratedId;
        DeveloperGroup.nextId = anObject.developerGroupAutoGeneratedId; 

        //go through and make all of the objects true developers
        for(let devId in this.allDevelopers) {
            //get the dev data
            const dev = this.allDevelopers[devId];
            //create the Developer object
            this.allDevelopers[devId] = new Developer(dev.userName, dev.email, dev.avatarURL, dev.id);
        }

        //go through and make all of the objects true developer groups
        for(let devGroupId in this.allDeveloperGroups) {
            //get the dev group data
            const devGroup =  this.allDeveloperGroups[devGroupId];
            //create the Developer object
            this.allDeveloperGroups[devGroupId] = new DeveloperGroup(devGroup.id, devGroup.memberIds);
        }

        //retrieve the current developer group id from the dev group object
        this.currentDeveloperGroupId = anObject.currentDeveloperGroupId;
    }

    /*
     * Creates a new developer (and one-person developer group) for new 
     * developers.
     */
    createNewDeveloper(userName, email) {
        //trim the strings
        userName = userName.trim();
        email = email.toLowerCase().trim();

        //if the user name doesn't already exist
        if(this.getDeveloperByUserName(userName) === null) {
            //create the developer
            const newDeveloper = new Developer(userName, email);
            //create a one person dev group
            const newDeveloperGroup = new DeveloperGroup();
            newDeveloperGroup.addDeveloper(newDeveloper);

            //add the new dev and dev group
            this.allDevelopers[newDeveloper.id] = newDeveloper;
            this.allDeveloperGroups[newDeveloperGroup.id] = newDeveloperGroup;
            
            //update the data
            this.write();
            
            return newDeveloper;
        } else {
            throw `Developer with the user name: ${userName} already exists`;
        }
    }

    /*
     * Creates a new developer group from a collection of developer ids. If
     * a dev group already exists with the ids then a new group will not be
     * created.
     */
    createNewDeveloperGroupByDevIds(devIds) {
        //refers to the new developer group if one can be created
        let retVal = null;

        //search through all dev groups to see if one already exists with all 
        //the passed in devs in it
        const existingDevGroup = Object.values(this.allDeveloperGroups).filter(devGroup => devGroup.containsAllDevelopers(devIds));

        //if there are no identical groups then we have to create a new group
        //and add the dev ids to it
        if(existingDevGroup.length === 0) {
            //create the new dev group, add the devs, and add it to the collection
            const newDevGroup = new DeveloperGroup();
            newDevGroup.addDeveloperByIds(devIds);
            this.allDeveloperGroups[newDevGroup.id] = newDevGroup;
            
            //update the data
            this.write();
            
            retVal = newDevGroup;
        } else {
            //store the existing dev group
            retVal = existingDevGroup[0];
        }

        return retVal;
    }

    /*
     * Creates a new developer group from a collection of developer user names.
     */
    createNewDeveloperGroupByDevUserName(devUserNames) {
        //create a new group from existing dev user names
        return this.createNewDeveloperGroupByDevIds(devUserNames.map(userName => this.getDeveloperByUserName(userName).id))
    }

    /*
     * Creates a new developer group from a collection of developer objects.
     */
    createNewDeveloperGroup(devs) {
        //create a new group from existing dev ids
        return this.createNewDeveloperGroupByDevIds(devs.map(dev => dev.id))
    }

    /*
     * Indicates whether all of the passed in dev ids match developers in the 
     * system.
     */
    allDevsExist(devIds) {
        //returns whether all of the developers were created and are stored in this object
        const allMatchingDevs = devIds.filter(devId => !this.allDevelopers[devId]);

        return allMatchingDevs.length > 0;
    }

    /*
     * Indicates whether all of the user names exist in the system
     */
    allDevUserNamesExist(devUserNames) {
        //default that all the dev user names exist
        let retVal = true;

        //go through the passed in dev user names
        for(let i = 0;i < devUserNames.length;i++) {
            //if the user name does not exists
            if(this.getDeveloperByUserName(devUserNames[i]) === false) {
                //indicate there is at least one non-existent user name
                retVal = false;

                //stop looking
                break;
            }
        }
        return retVal;
    }

    /*
     * Returns all of the developers in the active dev group.
     */
    getActiveDevelopers() {
        //return a collection of dev objects who are in the current dev group
        return this.allDeveloperGroups[this.currentDeveloperGroupId].memberIds.map(devId => this.getDeveloperById(devId));
    }

    /*
     * Returns all of the developers that are not in the active dev group.
     */
    getInactiveDevelopers() {
        //holds the inactive devs
        const inactiveDevs = [];

        //go through all the devs
        for(const devId in this.allDevelopers) {
            //if the dev ids is not in the current dev group
            if(this.allDeveloperGroups[this.currentDeveloperGroupId].memberIds.includes(devId) === false) {
                //add the inactive dev to the array
                inactiveDevs.push(this.allDevelopers[devId]);
            }
        }
        return inactiveDevs;
    }

    /*
     * Ensures that two groups of dev ids has no duplicates.
     */
    combineDevIdsNoDuplicates(group1, group2) {
        //combine the current devs and the proposed into an object to handle duplicates
        const proposedGroupObject = {};
        group1.forEach(devId => proposedGroupObject[devId] = devId);
        group2.forEach(devId => proposedGroupObject[devId] = devId);

        //retrieve the duplicate free dev ids 
        return Object.keys(proposedGroupObject);
    }

    /*
     * Removes one group of dev ids from another.
     */
    removeDevIds(existingGroup, removalGroup) {
        //add all of the existing group member ids to an object to handle duplicates
        const proposedGroupObject = {};
        existingGroup.forEach(devId => proposedGroupObject[devId] = devId);

        //go through the removal group
        removalGroup.forEach(devId => {
            //if the dev is in the existing group
            if(proposedGroupObject[devId]) {
                //remove them
                delete proposedGroupObject[devId];
            }
        });

        //retrieve the duplicate free dev ids 
        return Object.keys(proposedGroupObject);
    }

    /*
     * Sets the current developer group based on a passed in set of ids (possibly creating a new group).
     */
    setCurrentDevGroupWithDevIds(proposedGroup) {
        //find all the groups with that exact membership
        const existingGroups = [];
        for(let devGroupId in this.allDeveloperGroups) {
            //if a group has all of the proposed developer ids in it
            const devGroup = this.allDeveloperGroups[devGroupId];
            if(devGroup.containsAllDevelopers(proposedGroup)) {
                //store the existing group and stop looking
                existingGroups.push(devGroup);
                break;
            }
        }

        //if there is an existing group with all of the members (there should either zero or one)
        if(existingGroups.length > 0) {
            //store the existing group as the current one
            this.currentDeveloperGroupId = existingGroups[0].id;
        } else { //there are no groups with the exact membership 
            //create a new group, add the devs, and store it
            const newDevGroup = new DeveloperGroup();
            newDevGroup.addDeveloperByIds(proposedGroup);
            this.allDeveloperGroups[newDevGroup.id] = newDevGroup;
            this.currentDeveloperGroupId = newDevGroup.id;
        }
        //update the data
        this.write();
    }

    /*
     * Add developers to the active dev group based on dev id (possibly creating a new group).
     */
    addDevelopersToActiveGroup(devIds) {
        //combine the current active devs and the passed in array of devs to add
        const proposedGroup = this.combineDevIdsNoDuplicates(this.allDeveloperGroups[this.currentDeveloperGroupId].memberIds, devIds);
        //store the new group as the current one
        this.setCurrentDevGroupWithDevIds(proposedGroup);
    }

    /*
     * Add developers to the active dev group based on user name (possibly creating a new group).
     */
    addDevelopersToActiveGroupByUserName(devUserNames) {
        //if all of the dev user names exist
        if(this.allDevUserNamesExist(devUserNames)) {
            //store the new group as the current one
            this.addDevelopersToActiveGroup(devUserNames.map(devUserName => this.getDeveloperByUserName(devUserName).id));
        }
    }

    /*
     * Remove some ids from the active dev group (possibly creating a new group).
     */
    removeDevelopersFromActiveGroup(devIds) {
        //get the dev ids by removing the passed in ones from the current dev group
        const proposedGroup = this.removeDevIds(this.allDeveloperGroups[this.currentDeveloperGroupId].memberIds, devIds);
        //if there are any devs to add after removing
        if(proposedGroup.length > 0) {
            //store the new group as the current one
            this.setCurrentDevGroupWithDevIds(proposedGroup);
        }
    }

    /*
     * Remove some ids from the active dev group (possibly creating a new group).
     */
    removeDevelopersFromActiveGroupByUserName(devUserNames) {
        //if all of the dev user names exist
        if(this.allDevUserNamesExist(devUserNames)) {
            //store the new group as the current one
            this.removeDevelopersFromActiveGroup(devUserNames.map(devUserName => this.getDeveloperByUserName(devUserName).id));
        }
    }

    /*
     * Set the current dev group by using a dev group id.
     */
    setCurrentDeveloperGroupById(devGroupId) {
        //if the dev group exists
        if(this.allDeveloperGroups[devGroupId]) {
            //store it
            this.currentDeveloperGroupId = devGroupId;
            //update the data
            this.write();
        } else { //no dev group with that id exists
            throw 'Cannot change the developer group to one that is not being tracked';
        }
    }

    replaceAnonymousDeveloperWithNewDeveloper(userName, email) {
        //create a new developer group (and developer group)
        const newDev = this.createNewDeveloper(userName, email);

        //set the new dev's group as the current dev group
        this.setCurrentDevGroupWithDevIds([newDev.id]);
    }

    /*
     * Gets the current developer group
     */
    getCurrentDeveloperGroup() {
        return this.allDeveloperGroups[this.currentDeveloperGroupId];
    }
    /*
     * Sets the current dev group.
     */
    setCurrentDeveloperGroup(devGroup) {
        //set the dev group
        this.setCurrentDeveloperGroupById(devGroup.id);
    }

    /*
     * Retrieves a developer.
     */
    getDeveloperById(devId) {
        //retrieve the dev
        return this.allDevelopers[devId];
    }

    /*
     * Retrieves a developer.
     */
    getDeveloperByUserName(userName) {
        let retVal = null;

        //go through all of the dev
        for(const existingDevId in this.allDevelopers) {
            //look for a matching user name
            if(this.allDevelopers[existingDevId].userName === userName) {
                retVal = this.allDevelopers[existingDevId];
                break;
            }
        }

        return retVal;
    }

    /*
     * Retrieves a developer.
     */
    getDeveloper(dev) {
        //search by id
        return this.getDeveloperById(dev.id);
    }

    /*
     * Retrieves a developer group.
     */
    getDeveloperGroupById(devGroupId) {
        //retrieve the dev group by id
        return this.allDeveloperGroups[devGroupId];
    }

    /*
     * Retrieves a developer group.
     */
    getDeveloperGroup(devGroup) {
        //retrieve the dev group using its id
        return this.getDeveloperGroupById(devGroup.id);
    }
    /*
     * Retrieves a developer group with all of the passed in member ids.
     */
    getDeveloperGroupByMemberIds(devIds) {
        let retVal = null;
        //go through all of the dev groups
        for(const devGroupId in this.allDeveloperGroups) {
            //if the length is exactly the same as the requested group of ids
            if(devIds.length === this.allDeveloperGroups[devGroupId].memberIds.length) {
                //collect all the devs that match the passed in ids
                const matchingDevGroup = devIds.filter(devId => this.allDeveloperGroups[devGroupId].memberIds.contains(devId));
                //if the length is the same then there is a match
                if(matchingDevGroup.length === devIds.length) {
                    //store the matching group and stop looking
                    retVal = matchingDevGroup;
                    break;
                }
            }
        }
        return retVal;
    }
}

module.exports = DeveloperManager;