const md5 = require('md5');
const Developer = require('./Developer.js');
const DeveloperGroup = require('./DeveloperGroup.js');

/*
 * This class manages all devs and dev groups in the system. The class 
 * keeps track of all developers in allDevelopers, all developer groups in 
 * allDeveloperGroups, and the active developer group id with activeDeveloperGroupId.
 * 
 * It creates two developers/groups- one for devs who want to remain anonymous
 * and one for events generated by the system. 
 */
class DeveloperManager {
    constructor() {
        this.allDevelopers = {};
        this.allDeveloperGroups = {};
        this.activeDeveloperGroupId = null;
        this.systemDeveloperGroupId = null;
        this.systemDeveloperId = null
        this.anonymousDeveloperGroupId = null;
        this.anonymousDeveloperId = null;
    }

    load(devInfo) {
        this.allDevelopers = devInfo.allDevelopers;
        this.allDeveloperGroups = devInfo.allDeveloperGroups;
        this.activeDeveloperGroupId = devInfo.activeDeveloperGroupId;
        this.systemDeveloperGroupId = devInfo.systemDeveloperGroupId;
        this.anonymousDeveloperGroupId = devInfo.anonymousDeveloperGroupId;
        this.systemDeveloperId = devInfo.systemDeveloperId;
        this.anonymousDeveloperId = devInfo.anonymousDeveloperId;
    }

    init() {
        //create the system developer and an anonymous developer
        const systemDeveloper = new Developer('Storyteller System', 'no-email', 'https://www.gravatar.com/avatar/');
        const anonymousDeveloper = new Developer('Anonymous System', 'no-email', 'https://www.gravatar.com/avatar/');
        //add the new devs to the collections
        this.allDevelopers[systemDeveloper.id] = systemDeveloper;
        this.allDevelopers[anonymousDeveloper.id] = anonymousDeveloper;

        //create a system dev group (default active) and an anon dev group
        const systemDeveloperGroup = new DeveloperGroup([systemDeveloper.id]);
        const anonymousDeveloperGroup = new DeveloperGroup([anonymousDeveloper.id]);
        //add the dev groups to the collection
        this.allDeveloperGroups[systemDeveloperGroup.id] = systemDeveloperGroup;
        this.allDeveloperGroups[anonymousDeveloperGroup.id] = anonymousDeveloperGroup;

        //set the active dev group to be the system dev
        this.activeDeveloperGroupId = systemDeveloperGroup.id;
        this.systemDeveloperGroupId = systemDeveloperGroup.id;
        this.systemDeveloperId = systemDeveloper.id;
        this.anonymousDeveloperGroupId = anonymousDeveloperGroup.id;
        this.anonymousDeveloperId = anonymousDeveloper.id;
    }

    getAnonymousDeveloper() {
        return this.allDevelopers[this.anonymousDeveloperId];
    }

    getSystemDeveloper() {
        return this.allDevelopers[this.systemDeveloperId];
    }

    getAnonymousDeveloperGroup() {
        return this.allDeveloperGroups[this.anonymousDeveloperGroupId];
    }

    getSystemDeveloperGroup() {
        return this.allDeveloperGroups[this.systemDeveloperGroupId];
    }
    
    /*
     * Creates a new developer (and one-person developer group) for new 
     * developers.
     */
    createNewDeveloper(userName, email) {
        let retVal = null;

        //trim the strings
        userName = userName.trim();
        email = email.toLowerCase().trim();
        //create a link to a user pic
        const avatarURL = `https://www.gravatar.com/avatar/${md5(email)}`;

        //if the user name doesn't already exist
        if(this.getDeveloperByUserName(userName) === null) {
            //create a new developer 
            const newDeveloper = new Developer(userName, email, avatarURL);
            
            //create a one-person dev group and link the new dev to it
            const newDeveloperGroup = new DeveloperGroup([newDeveloper.id]);
            
            //add the new dev and one-person dev group
            this.allDevelopers[newDeveloper.id] = newDeveloper;
            this.allDeveloperGroups[newDeveloperGroup.id] = newDeveloperGroup;

            //return the new dev and one-person dev group
            retVal = {newDeveloper, newDeveloperGroup};
        }
        return retVal;
    }

    /*
     * Creates a new developer group from a collection of developer ids. If
     * a dev group already exists with the ids then a new group will not be
     * created.
     */
    createNewDeveloperGroupByDevIds(devIds) {
        let retVal = null;

        //search through all dev groups to see if one already exists with all 
        //the passed in devs in it
        const existingDevGroupsWithDevIds = Object.values(this.allDeveloperGroups).filter(devGroup => devGroup.containsAllDevelopers(devIds));

        //if there are no identical dev groups
        if(existingDevGroupsWithDevIds.length === 0) {
            //create a new dev group 
            const newDeveloperGroup = new DeveloperGroup(devIds);
                                
            //add the new dev group to the collection in memory
            this.allDeveloperGroups[newDeveloperGroup.id] = newDeveloperGroup;
            
            //return the new dev group
            retVal = newDeveloperGroup;
        } else { //there is an existing group with those devs
            //return the existing dev group (should only be one)
            retVal = existingDevGroupsWithDevIds[0];
        }

        return retVal;
    }

    /*
     * Creates a new developer group from a collection of developer user names.
     */
    createNewDeveloperGroupByDevUserName(devUserNames) {
        //create a new group from existing dev user names
        return this.createNewDeveloperGroupByDevIds(devUserNames.map(userName => this.getDeveloperByUserName(userName).id))
    }

    /*
     * Creates a new developer group from a collection of developer objects.
     */
    createNewDeveloperGroup(devs) {
        //create a new group from existing dev ids
        return this.createNewDeveloperGroupByDevIds(devs.map(dev => dev.id))
    }

    /*
     * Indicates whether all of the user names exist in the system
     */
    allDevUserNamesExist(devUserNames) {
        //default that all the dev user names exist
        let retVal = true;

        //go through the passed in dev user names
        for(let i = 0;i < devUserNames.length;i++) {
            //if the user name does not exists
            if(this.getDeveloperByUserName(devUserNames[i]) === false) {
                //indicate there is at least one non-existent user name
                retVal = false;

                //stop looking
                break;
            }
        }
        return retVal;
    }

    /*
     * Returns all of the developers in the active dev group.
     */
    getActiveDevelopers() {
        //return a collection of dev objects who are in the current dev group
        return this.allDeveloperGroups[this.activeDeveloperGroupId].memberIds.map(devId => this.getDeveloperById(devId));
    }

    /*
     * Returns all of the developers that are not in the active dev group.
     */
    getInactiveDevelopers() {
        //holds the inactive devs
        const inactiveDevs = [];

        //go through all the devs
        for(const devId in this.allDevelopers) {
            //if the dev ids is not in the current dev group
            if(this.allDeveloperGroups[this.activeDeveloperGroupId].memberIds.includes(devId) === false) {
                //add the inactive dev to the array
                inactiveDevs.push(this.allDevelopers[devId]);
            }
        }
        return inactiveDevs;
    }

    /*
     * Ensures that two groups of dev ids has no duplicates.
     */
    combineDevIdsNoDuplicates(group1, group2) {
        //combine the current devs and the proposed into an object to handle duplicates
        const proposedGroupObject = {};
        group1.forEach(devId => proposedGroupObject[devId] = devId);
        group2.forEach(devId => proposedGroupObject[devId] = devId);

        //retrieve the duplicate free dev ids 
        return Object.keys(proposedGroupObject);
    }

    /*
     * Removes one group of dev ids from another.
     */
    removeDevIds(existingGroup, removalGroup) {
        //add all of the existing group member ids to an object to handle duplicates
        const proposedGroupObject = {};
        existingGroup.forEach(devId => proposedGroupObject[devId] = devId);

        //go through the removal group
        removalGroup.forEach(devId => {
            //if the dev is in the existing group
            if(proposedGroupObject[devId]) {
                //remove them
                delete proposedGroupObject[devId];
            }
        });

        //retrieve the duplicate free dev ids 
        return Object.keys(proposedGroupObject);
    }

    /*
     * Sets the current developer group based on a passed in set of ids (possibly creating a new group).
     */
    setCurrentDevGroupWithDevIds(proposedGroup) {
        //find all the groups with that exact membership
        let matchingDevGroup = null;
        for(let devGroupId in this.allDeveloperGroups) {
            //if a group has all of the proposed developer ids in it
            const devGroup = this.allDeveloperGroups[devGroupId];
            if(devGroup.containsAllDevelopers(proposedGroup)) {
                //store the existing group and stop looking
                matchingDevGroup = devGroup;
                break;
            }
        }

        //if there is an existing group with all of the members
        if(matchingDevGroup) {
            //store the existing group as the current one
            this.setActiveDeveloperGroup(matchingDevGroup);                    
        } else { //there are no groups with the exact membership 
            //create a new group, add the devs, and store it
            matchingDevGroup = this.createNewDeveloperGroupByDevIds(proposedGroup);
            this.setActiveDeveloperGroup(matchingDevGroup);
        }

        return matchingDevGroup;
    }

    /*
     * Add developers to the active dev group based on dev id (possibly creating a new group).
     */
    addDevelopersToActiveGroup(devIds) {
        //combine the current active devs and the passed in array of devs to add
        const proposedGroup = this.combineDevIdsNoDuplicates(this.allDeveloperGroups[this.activeDeveloperGroupId].memberIds, devIds);
        //store the new group as the current one
        return this.setCurrentDevGroupWithDevIds(proposedGroup);
    }

    /*
     * Add developers to the active dev group based on user name (possibly creating a new group).
     */
    addDevelopersToActiveGroupByUserName(devUserNames) {
        //if all of the dev user names exist
        if(this.allDevUserNamesExist(devUserNames)) {
            //store the new group as the current one
            return this.addDevelopersToActiveGroup(devUserNames.map(devUserName => this.getDeveloperByUserName(devUserName).id));
        }
    }

    /*
     * Remove some ids from the active dev group (possibly creating a new group).
     */
    removeDevelopersFromActiveGroup(devIds) {
        //get the dev ids by removing the passed in ones from the current dev group
        const proposedGroup = this.removeDevIds(this.allDeveloperGroups[this.activeDeveloperGroupId].memberIds, devIds);
        //if there are any devs to add after removing
        if(proposedGroup.length > 0) {
            //store the new group as the current one
            this.setCurrentDevGroupWithDevIds(proposedGroup);
        }
    }

    /*
     * Remove some ids from the active dev group (possibly creating a new group).
     */
    removeDevelopersFromActiveGroupByUserName(devUserNames) {
        //if all of the dev user names exist
        if(this.allDevUserNamesExist(devUserNames)) {
            //store the new group as the current one
            this.removeDevelopersFromActiveGroup(devUserNames.map(devUserName => this.getDeveloperByUserName(devUserName).id));
        }
    }

    /*
     * Set the current dev group.
     */
    setActiveDeveloperGroup(devGroup) {
        //if the dev group exists
        if(this.allDeveloperGroups[devGroup.id]) {
            //store it
            this.activeDeveloperGroupId = devGroup.id;
        } else { //no dev group with that id exists
            throw 'Cannot change the developer group to one that is not being tracked';
        }
    }

    replaceAnonymousDeveloperWithNewDeveloper(userName, email) {
        //create a new developer group (and developer group)
        const newDev = this.createNewDeveloper(userName, email);

        //set the new dev's group as the current dev group
        this.setCurrentDevGroupWithDevIds([newDev.newDeveloper.id]);
        
    }

    /*
     * Gets the currently active developer group
     */
    getActiveDeveloperGroup() {
        return this.allDeveloperGroups[this.activeDeveloperGroupId];
    }

    /*
     * Gets the currently active developer group's id
     */
    getActiveDeveloperGroupId() {
        return this.activeDeveloperGroupId;
    }

    /*
     * Retrieves a developer.
     */
    getDeveloperById(devId) {
        //retrieve the dev
        return this.allDevelopers[devId];
    }

    /*
     * Retrieves a developer.
     */
    getDeveloperByUserName(userName) {
        let retVal = null;

        //go through all of the dev
        for(const existingDevId in this.allDevelopers) {
            //look for a matching user name
            if(this.allDevelopers[existingDevId].userName === userName) {
                retVal = this.allDevelopers[existingDevId];
                break;
            }
        }

        return retVal;
    }

    /*
     * Retrieves a developer.
     */
    getDeveloper(dev) {
        //search by id
        return this.getDeveloperById(dev.id);
    }

    /*
     * Retrieves a developer group.
     */
    getDeveloperGroupById(devGroupId) {
        //retrieve the dev group by id
        return this.allDeveloperGroups[devGroupId];
    }

    /*
     * Retrieves a developer group.
     */
    getDeveloperGroup(devGroup) {
        //retrieve the dev group using its id
        return this.getDeveloperGroupById(devGroup.id);
    }

    /*
     * Retrieves a developer group with all of the passed in member ids.
     */
    getDeveloperGroupByMemberIds(devIds) {
        let retVal = null;
        //go through all of the dev groups
        for(const devGroupId in this.allDeveloperGroups) {
            //if the length is exactly the same as the requested group of ids
            if(devIds.length === this.allDeveloperGroups[devGroupId].memberIds.length) {
                //collect all the devs that match the passed in ids
                const matchingDevGroup = devIds.filter(devId => this.allDeveloperGroups[devGroupId].memberIds.contains(devId));
                //if the length is the same then there is a match
                if(matchingDevGroup.length === devIds.length) {
                    //store the matching group and stop looking
                    retVal = matchingDevGroup;
                    break;
                }
            }
        }
        return retVal;
    }
}

module.exports = DeveloperManager;