const md5 = require('md5');
const Developer = require('./Developer.js');
const DeveloperGroup = require('./DeveloperGroup.js');

/*
 * This class manages all devs and dev groups in the system. The class 
 * keeps track of all developers in allDevelopers, all developer groups in 
 * allDeveloperGroups, and the active developer group id with activeDeveloperGroupId.
 * 
 * It creates two developers/groups- one for devs who want to remain anonymous
 * and one for events generated by the system. 
 */
class DeveloperManager {
    constructor(db) {
        this.db = db;
        this.allDevelopers = {};
        this.allDeveloperGroups = {};
        this.activeDeveloperGroupId = null;
        this.systemDeveloperGroup = null;
        this.anonymousDeveloperGroup = null;
    }

    init(isNewProject) {
        return new Promise(async (resolve, reject) => {
            try {
                if(isNewProject) {
                    //create the system developer and an anonymous developer
                    //the ids of the two default devs/dev groups are 1 and 2
                    //from the auto-generated ids in the db
                    const results = await Promise.all([
                        this.createNewDeveloper('Storyteller System', 'no-email'), 
                        this.createNewDeveloper('Anonymous Developer', 'no-email')
                    ]);

                    //store the system and anon dev group
                    this.systemDeveloperGroup = results[0].newDeveloperGroup;
                    this.anonymousDeveloperGroup = results[1].newDeveloperGroup;
            
                    //set the system developer to be the default active dev group
                    await this.setActiveDeveloperGroup(this.systemDeveloperGroup);
                } else { //existing project
                    //get all devs and store them in a map keyed by id
                    const allDevelopersArray = await this.db.getAllDevelopers();
                    for(const dev of allDevelopersArray) {
                        this.allDevelopers[dev.id] = new Developer(dev.userName, dev.email, dev.avatarURL, dev.id); 
                    }

                    //get all dev groups and store them in a map keyed by id
                    const allDeveloperGroupsArray = await this.db.getAllDeveloperGroups();
                    for(const devGroup of allDeveloperGroupsArray) {
                        this.allDeveloperGroups[devGroup.id] = new DeveloperGroup([], devGroup.isActiveDeveloperGroup, devGroup.id);
                    }

                    //match all of the devs/dev groups in memory using the data from the db
                    await this.db.matchDevelopersToDeveloperGroups(this.allDevelopers, this.allDeveloperGroups);

                    //create a system and anon dev group
                    this.systemDeveloperGroup = this.allDevelopers[1]; //1 is the system dev id
                    this.anonymousDeveloperGroup = this.allDevelopers[2]; //2 is the anon dev id
                    
                    //get the active dev group from the db and store it
                    const activeDevGroup = await this.db.getActiveDeveloperGroup();
                    this.activeDeveloperGroupId = activeDevGroup.id;
                }
                resolve();
            } catch(err) {
                reject(err);
            }
        });
    }

    /*
     * Creates a new developer (and one-person developer group) for new 
     * developers.
     */
    createNewDeveloper(userName, email) {
        return new Promise(async (resolve, reject) => {
            try {
                //trim the strings
                userName = userName.trim();
                email = email.toLowerCase().trim();
                //create a link to a user pic
                const avatarURL = `https://www.gravatar.com/avatar/${md5(email)}`;

                //if the user name doesn't already exist
                if(this.getDeveloperByUserName(userName) === null) {
                    //create a new developer and add it to the db
                    const newDeveloper = await this.db.createDeveloper(userName, email, avatarURL);
                    
                    //create a one-person dev group and link the new dev to it
                    const newDeveloperGroup = await this.db.createDeveloperGroup();
                    newDeveloperGroup.addDeveloper(newDeveloper);
                    //connect the dev and dev group in the db
                    await this.db.linkDeveloperToDeveloperGroup(newDeveloper, newDeveloperGroup);

                    //add the new dev and one-person dev group
                    this.allDevelopers[newDeveloper.id] = newDeveloper;
                    this.allDeveloperGroups[newDeveloperGroup.id] = newDeveloperGroup;

                    //return the new dev and one-person dev group
                    resolve({newDeveloper, newDeveloperGroup});
                } else {
                    console.log(`Developer with the user name: ${userName} already exists`);
                    reject();
                }
            } catch(err) {
                reject(err);
            }
        });
    }

    /*
     * Creates a new developer group from a collection of developer ids. If
     * a dev group already exists with the ids then a new group will not be
     * created.
     */
    createNewDeveloperGroupByDevIds(devIds) {
        return new Promise(async (resolve, reject) => {
            try {
                let retVal = null;

                //search through all dev groups to see if one already exists with all 
                //the passed in devs in it
                const existingDevGroupsWithDevIds = Object.values(this.allDeveloperGroups).filter(devGroup => devGroup.containsAllDevelopers(devIds));

                //if there are no identical dev groups
                if(existingDevGroupsWithDevIds.length === 0) {
                    //create a new dev group in the db
                    const newDeveloperGroup = await this.db.createDeveloperGroup();
                    
                    //link all of the devs to the new group in memory and the db
                    newDeveloperGroup.addDeveloperByIds(devIds);
                    await this.db.linkDevelopersToDeveloperGroup(devIds, newDeveloperGroup);
                    
                    //add the new dev group to the collection in memory
                    this.allDeveloperGroups[newDeveloperGroup.id] = newDeveloperGroup;
                    
                    //return the new dev group
                    retVal = newDeveloperGroup;
                } else { //there is an existing group with those devs
                    //return the existing dev group
                    retVal = existingDevGroupsWithDevIds[0];
                }

                resolve(retVal);
            } catch(err) {
                reject(err);
            }
        });
    }

    /*
     * Creates a new developer group from a collection of developer user names.
     */
    createNewDeveloperGroupByDevUserName(devUserNames) {
        //create a new group from existing dev user names
        return this.createNewDeveloperGroupByDevIds(devUserNames.map(userName => this.getDeveloperByUserName(userName).id))
    }

    /*
     * Creates a new developer group from a collection of developer objects.
     */
    createNewDeveloperGroup(devs) {
        //create a new group from existing dev ids
        return this.createNewDeveloperGroupByDevIds(devs.map(dev => dev.id))
    }

    /*
     * Indicates whether all of the user names exist in the system
     */
    allDevUserNamesExist(devUserNames) {
        //default that all the dev user names exist
        let retVal = true;

        //go through the passed in dev user names
        for(let i = 0;i < devUserNames.length;i++) {
            //if the user name does not exists
            if(this.getDeveloperByUserName(devUserNames[i]) === false) {
                //indicate there is at least one non-existent user name
                retVal = false;

                //stop looking
                break;
            }
        }
        return retVal;
    }

    /*
     * Returns all of the developers in the active dev group.
     */
    getActiveDevelopers() {
        //return a collection of dev objects who are in the current dev group
        return this.allDeveloperGroups[this.activeDeveloperGroupId].memberIds.map(devId => this.getDeveloperById(devId));
    }

    /*
     * Returns all of the developers that are not in the active dev group.
     */
    getInactiveDevelopers() {
        //holds the inactive devs
        const inactiveDevs = [];

        //go through all the devs
        for(const devId in this.allDevelopers) {
            //if the dev ids is not in the current dev group
            if(this.allDeveloperGroups[this.activeDeveloperGroupId].memberIds.includes(Number(devId)) === false) {
                //add the inactive dev to the array
                inactiveDevs.push(this.allDevelopers[devId]);
            }
        }
        return inactiveDevs;
    }

    /*
     * Ensures that two groups of dev ids has no duplicates.
     */
    combineDevIdsNoDuplicates(group1, group2) {
        //combine the current devs and the proposed into an object to handle duplicates
        const proposedGroupObject = {};
        group1.forEach(devId => proposedGroupObject[devId] = devId);
        group2.forEach(devId => proposedGroupObject[devId] = devId);

        //retrieve the duplicate free dev ids 
        return (Object.keys(proposedGroupObject)).map(key => Number(key));
    }

    /*
     * Removes one group of dev ids from another.
     */
    removeDevIds(existingGroup, removalGroup) {
        //add all of the existing group member ids to an object to handle duplicates
        const proposedGroupObject = {};
        existingGroup.forEach(devId => proposedGroupObject[devId] = devId);

        //go through the removal group
        removalGroup.forEach(devId => {
            //if the dev is in the existing group
            if(proposedGroupObject[devId]) {
                //remove them
                delete proposedGroupObject[devId];
            }
        });

        //retrieve the duplicate free dev ids 
        return (Object.keys(proposedGroupObject)).map(key => Number(key));
    }

    /*
     * Sets the current developer group based on a passed in set of ids (possibly creating a new group).
     */
    setCurrentDevGroupWithDevIds(proposedGroup) {
        return new Promise(async (resolve, reject) => {
            try {
                //find all the groups with that exact membership
                let matchingDevGroup = null;
                for(let devGroupId in this.allDeveloperGroups) {
                    //if a group has all of the proposed developer ids in it
                    const devGroup = this.allDeveloperGroups[devGroupId];
                    if(devGroup.containsAllDevelopers(proposedGroup)) {
                        //store the existing group and stop looking
                        matchingDevGroup = devGroup;
                        break;
                    }
                }

                //if there is an existing group with all of the members
                if(matchingDevGroup) {
                    //store the existing group as the current one
                    await this.setActiveDeveloperGroup(matchingDevGroup);                    
                } else { //there are no groups with the exact membership 
                    //create a new group, add the devs, and store it
                    matchingDevGroup = await this.createNewDeveloperGroupByDevIds(proposedGroup);
                    await this.setActiveDeveloperGroup(matchingDevGroup);
                }
                resolve(matchingDevGroup);
            } catch(err) {
                reject(err);
            }
        });
    }

    /*
     * Add developers to the active dev group based on dev id (possibly creating a new group).
     */
    addDevelopersToActiveGroup(devIds) {
        //combine the current active devs and the passed in array of devs to add
        const proposedGroup = this.combineDevIdsNoDuplicates(this.allDeveloperGroups[this.activeDeveloperGroupId].memberIds, devIds);
        //store the new group as the current one
        return this.setCurrentDevGroupWithDevIds(proposedGroup);
    }

    /*
     * Add developers to the active dev group based on user name (possibly creating a new group).
     */
    addDevelopersToActiveGroupByUserName(devUserNames) {
        //if all of the dev user names exist
        if(this.allDevUserNamesExist(devUserNames)) {
            //store the new group as the current one
            return this.addDevelopersToActiveGroup(devUserNames.map(devUserName => this.getDeveloperByUserName(devUserName).id));
        }
    }

    /*
     * Remove some ids from the active dev group (possibly creating a new group).
     */
    removeDevelopersFromActiveGroup(devIds) {
        //get the dev ids by removing the passed in ones from the current dev group
        const proposedGroup = this.removeDevIds(this.allDeveloperGroups[this.activeDeveloperGroupId].memberIds, devIds);
        //if there are any devs to add after removing
        if(proposedGroup.length > 0) {
            //store the new group as the current one
            this.setCurrentDevGroupWithDevIds(proposedGroup);
        }
    }

    /*
     * Remove some ids from the active dev group (possibly creating a new group).
     */
    removeDevelopersFromActiveGroupByUserName(devUserNames) {
        //if all of the dev user names exist
        if(this.allDevUserNamesExist(devUserNames)) {
            //store the new group as the current one
            this.removeDevelopersFromActiveGroup(devUserNames.map(devUserName => this.getDeveloperByUserName(devUserName).id));
        }
    }

    /*
     * Set the current dev group.
     */
    async setActiveDeveloperGroup(devGroup) {
        //if the dev group exists
        if(this.allDeveloperGroups[devGroup.id]) {
            //store it
            this.activeDeveloperGroupId = devGroup.id;
            await this.db.updateActiveDeveloperGroup(this.allDeveloperGroups[devGroup.id]);
        } else { //no dev group with that id exists
            throw 'Cannot change the developer group to one that is not being tracked';
        }
    }

    replaceAnonymousDeveloperWithNewDeveloper(userName, email) {
        return new Promise(async (resolve, reject) => {
            try {
                //create a new developer group (and developer group)
                const newDev = await this.createNewDeveloper(userName, email);

                //set the new dev's group as the current dev group
                await this.setCurrentDevGroupWithDevIds([newDev.newDeveloper.id]);
                
                resolve();
            } catch(err) {
                reject(err);
            }
        });
    }

    /*
     * Gets the currently active developer group
     */
    getActiveDeveloperGroup() {
        return this.allDeveloperGroups[this.activeDeveloperGroupId];
    }

    /*
     * Gets the currently active developer group's id
     */
    getActiveDeveloperGroupId() {
        return this.activeDeveloperGroupId;
    }

    /*
     * Retrieves a developer.
     */
    getDeveloperById(devId) {
        //retrieve the dev
        return this.allDevelopers[devId];
    }

    /*
     * Retrieves a developer.
     */
    getDeveloperByUserName(userName) {
        let retVal = null;

        //go through all of the dev
        for(const existingDevId in this.allDevelopers) {
            //look for a matching user name
            if(this.allDevelopers[existingDevId].userName === userName) {
                retVal = this.allDevelopers[existingDevId];
                break;
            }
        }

        return retVal;
    }

    /*
     * Retrieves a developer.
     */
    getDeveloper(dev) {
        //search by id
        return this.getDeveloperById(dev.id);
    }

    /*
     * Retrieves a developer group.
     */
    getDeveloperGroupById(devGroupId) {
        //retrieve the dev group by id
        return this.allDeveloperGroups[devGroupId];
    }

    /*
     * Retrieves a developer group.
     */
    getDeveloperGroup(devGroup) {
        //retrieve the dev group using its id
        return this.getDeveloperGroupById(devGroup.id);
    }

    /*
     * Retrieves a developer group with all of the passed in member ids.
     */
    getDeveloperGroupByMemberIds(devIds) {
        let retVal = null;
        //go through all of the dev groups
        for(const devGroupId in this.allDeveloperGroups) {
            //if the length is exactly the same as the requested group of ids
            if(devIds.length === this.allDeveloperGroups[devGroupId].memberIds.length) {
                //collect all the devs that match the passed in ids
                const matchingDevGroup = devIds.filter(devId => this.allDeveloperGroups[devGroupId].memberIds.contains(devId));
                //if the length is the same then there is a match
                if(matchingDevGroup.length === devIds.length) {
                    //store the matching group and stop looking
                    retVal = matchingDevGroup;
                    break;
                }
            }
        }
        return retVal;
    }
}

module.exports = DeveloperManager;