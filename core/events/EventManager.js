const fs = require('fs');
const path = require('path');
const utilities = require('../utilities.js');

const FileBackedCollection = require('../FileBackedCollection.js');

//holds the number of events to store in memory before writing the events to
//an intermediate file of events 
const MAX_BUFFER_SIZE = 10;

class EventManager extends FileBackedCollection {
    constructor(storytellerDirPath) {
        //init the base class
        super(storytellerDirPath, 'events', 'events.json');
        
        //create a path to a file in a new sub-directory to hold events that 
        //have been moved from memory but are not yet stored in the json file
        this.fullPathToIntermediateEventsFile = path.join(this.fullPathToParentDir, 'intermediate', 'events.txt');

        //create a collection to hold the latest events in memory
        this.latestEvents = [];

        //if the json file exists
        if(this.fileExists()) {
            //if there is an intermediate file because of a previous crash
            if(fs.existsSync(this.fullPathToIntermediateEventsFile)) {
                //add the events in the intermediate file to the json file
                this.readWriteHelper();
            } //else- no intermediate file

            //read the contents of the json file and turn it into an object
            const eventsData = JSON.parse(fs.readFileSync(this.fullPathToJSONFile, 'utf8'));
            
            //store the auto generated id
            EventManager.nextId = eventsData['eventAutoGeneratedId'];
        } else { //no json file exists
            //make the intermediate directory
            fs.mkdirSync(path.join(this.fullPathToParentDir, 'intermediate'), {recursive: true});

            //init the auto-generated id to zero
            EventManager.nextId = 0;

            //pass in an object to be written to a json file
            super.write({
                events: [],
                eventAutoGeneratedId: EventManager.nextId
            });
        }
    }

    /*
     * Generates an id for events.
     */
    generateId() {
        const newId = `ev-${EventManager.nextId}`;
        EventManager.nextId++;
        return newId;
    }

    /*
     * Writes the data in memory (and possibly in the intermediate file) to
     * the file.
     */
    write() {
        //use the helper to write the most up to date group of events to the 
        //json file
        this.readWriteHelper();
    }

    /*
     * Reads data in from the file (and possibly the intermediate file) in to
     * memory. The method returns an array of all of the events.
     */
    read() {
        //use the helper to write the most up to date group of events to the
        //json file and return the array of event objects
        const eventData = this.readWriteHelper();

        return eventData.events; 
    }

    /*
     * Helper that reads in the json file, extracts the events from the object,
     * gets any events in the intermediate file and adds them to the collection
     * of all events. Finally, it adds any events in memory to the collection
     * of all events. Then it writes all of the events back to the json file.
     * The method returns the array of all events. 
     */
    readWriteHelper() {
        //read the object from the json file into memory
        const eventsData = super.read();
        
        //isolate the array of all events stored in the json file
        const events = eventsData.events;

        //read in any buffered events in the intermediate file
        const bufferedEvents = this.readEventsBufferFromFileSystem();
        
        for(let i = 0;i < bufferedEvents.length;i++) {
            //add the buffered events to the array of all events
            events.push(bufferedEvents[i]);
        }
        
        for(let i = 0;i < this.latestEvents.length;i++) {
            //add any fresh events in memory
            events.push(this.latestEvents[i]);
        }

        //clear out the latest events in memory since they have been added to the list
        this.latestEvents = [];

        //write the latest events to the json file
        super.write({
            events: events,
            eventAutoGeneratedId: EventManager.nextId
        });

        return eventsData;
    }

    /*
     * Writes events in memory to the intermediate file if there are enough
     * or if it is explicitly requested.
     */
    writeEventsBufferToFileSystem(forceWrite=false) {
        try {
            //if there has been a build up of events in memory OR
            //if one wishes to force a write no matter what
            if(this.latestEvents.length > 0 && (this.latestEvents.length >= this.getMaxBufferSize() || forceWrite)) {
                //convert the events into a newline separated string of events
                let eventsString = this.latestEvents.map(event => JSON.stringify(event)).join('\n');
                
                //if the file exists that means it has some data in it
                if(fs.existsSync(this.fullPathToIntermediateEventsFile)) {
                    //add a newline to the beginning to separate the existing file contents and these new event lines
                    eventsString = '\n' + eventsString;
                }

                //append the latest events to the intermediate file
                fs.appendFileSync(this.fullPathToIntermediateEventsFile, eventsString);
                
                //empty out the collection of current events since they are stored on the disk
                this.latestEvents = [];
            } //else- not enough events in the buffer, ignore for now
        } catch(ex) {
            console.log(`Error on writeEventsBufferToFileSystem: ${ex}`);
            console.log(`latestEvents: ${this.latestEvents}`);
        }
    }

    /*
     * Reads the events from the intermeidate file and then deletes it.
     */
    readEventsBufferFromFileSystem() {
        let bufferedEvents = [];
    
        //if the intermediate file exists
        if(fs.existsSync(this.fullPathToIntermediateEventsFile)) {
            //read the entire file and place it in one string
            const eventsString = fs.readFileSync(this.fullPathToIntermediateEventsFile, 'utf8');
            
            //if there was anything in the file
            if(eventsString.length > 0) {
                //split on the lines and convert to js objects
                bufferedEvents = eventsString.split('\n').map(eventString => JSON.parse(eventString));
            }

            //delete the intermediate file
            fs.unlinkSync(this.fullPathToIntermediateEventsFile);
        }

        //return the events read from the file
        return bufferedEvents;
    }

    /*
     * Returns the maximum buffer size.
     */
    getMaxBufferSize() {
        return MAX_BUFFER_SIZE;
    }
    /***********************************************
     * Event creation functions.
     ***********************************************/
    /*
     * Adds a collection of events to memory and checks if there are enough
     * to put them in the intermediate file.
     */
    addEvents(events) {
        for(let i = 0;i < events.length;i++) {
            //add the passed in array of events so they are all added
            this.latestEvents.push(events[i]);
        }

        //check if the latest events should be written to the intermediate file
        this.writeEventsBufferToFileSystem(false);
    }

    /*
     * Adds a single event and checks if there are enough to put them in the
     * intermediate file.
     */
    addEvent(event) {
        //add the latest event
        this.latestEvents.push(event);

        //check if the latest event should be written to the intermediate file
        this.writeEventsBufferToFileSystem(false);
    }

    /*
     * Creates the core part of a storyteller events.
     */
    fillCoreEvent(id, eventSequenceNumber, timestamp, createdByDevGroupId, branchId, isRelevant=true) {
        //return an object with the properties common to every event
        const retVal = {
            id,
            timestamp,
            createdByDevGroupId,
            eventSequenceNumber: eventSequenceNumber - 1, //to account for an increment when making ids
            branchId 
        };

        //if this event is not relevant to a playback
        if(isRelevant === false) {
            retVal['permanentRelevance'] = 'never relevant';
        }
        return retVal;
    }
    
    /*
     * Creates a 'CREATE FILE' event.
     */
    insertCreateFileEvent(fileObj, timestamp, createdByDevGroupId, branchId, isRelevant=true) {
        //create an event id
        const eventId = this.generateId();
        
        //create core event
        const createFileEvent = this.fillCoreEvent(eventId, EventManager.nextId, timestamp, createdByDevGroupId, branchId, isRelevant);
        
        //add specific properties
        createFileEvent['type'] = 'CREATE FILE';
        createFileEvent['fileId'] = fileObj.id;
        createFileEvent['filePath'] = fileObj.currentPath
        createFileEvent['parentDirectoryId'] = fileObj.parentDirectoryId;

        //add the new event
        this.addEvent(createFileEvent);
    }
    
    /*
     * Creates a 'DELETE FILE' event.
     */
    insertDeleteFileEvent(fileObj, timestamp, createdByDevGroupId, branchId) {
        //create an event id
        const eventId = this.generateId();
        
        //create core event
        const deleteFileEvent = this.fillCoreEvent(eventId,EventManager.nextId, timestamp, createdByDevGroupId, branchId);
        
        //add specific properties
        deleteFileEvent['type'] = 'DELETE FILE';
        deleteFileEvent['fileId'] = fileObj.id;
        deleteFileEvent['filePath'] = fileObj.currentPath
        deleteFileEvent['parentDirectoryId'] = fileObj.parentDirectoryId;

        //add the new event
        this.addEvent(deleteFileEvent);
    }
    
    /*
     * Creates a 'MOVE FILE' event.
     */
    insertMoveFileEvent(timestamp, createdByDevGroupId, branchId, fileId, newParentDirectoryId, oldParentDirectoryId, newFilePath, oldFilePath) {
        //create an event id
        const eventId = this.generateId();
        
        //create core event
        const moveFileEvent = this.fillCoreEvent(eventId,EventManager.nextId, timestamp, createdByDevGroupId, branchId);
        
        //add specific properties
        moveFileEvent['type'] = 'MOVE FILE';
        moveFileEvent['fileId'] = fileId;
        moveFileEvent['newParentDirectoryId'] = newParentDirectoryId;
        moveFileEvent['oldParentDirectoryId'] = oldParentDirectoryId;
        moveFileEvent['newFilePath'] = newFilePath;
        moveFileEvent['oldFilePath'] = oldFilePath;

        //add the new event
        this.addEvent(moveFileEvent);
    }
    
    /*
     * Creates a 'RENAME FILE' event.
     */
    insertRenameFileEvent(timestamp, createdByDevGroupId, branchId, fileId, parentDirectoryId, newFilePath, oldFilePath) {
        //create an event id
        const eventId = this.generateId();
        
        //create core event
        const renameFileEvent = this.fillCoreEvent(eventId,EventManager.nextId, timestamp, createdByDevGroupId, branchId);
        
        //add specific properties
        renameFileEvent['type'] = 'RENAME FILE';
        renameFileEvent['fileId'] = fileId;
        renameFileEvent['parentDirectoryId'] = parentDirectoryId;
        renameFileEvent['newFilePath'] = newFilePath;
        renameFileEvent['oldFilePath'] = oldFilePath;
        
        //add the new event
        this.addEvent(renameFileEvent);
    }
    
    /*
     * Creates a 'CREATE DIRECTORY' event.
     */
    insertCreateDirectoryEvent(dirObj, timestamp, createdByDevGroupId, branchId, isRelevant=true) {
        //create an event id
        const eventId = this.generateId();
        
        //create core event
        const createDirectoryEvent = this.fillCoreEvent(eventId,EventManager.nextId, timestamp, createdByDevGroupId, branchId, isRelevant);
        
        //add specific properties
        createDirectoryEvent['type'] = 'CREATE DIRECTORY';
        createDirectoryEvent['directoryId'] = dirObj.id;
        createDirectoryEvent['directoryPath'] = dirObj.currentPath
        createDirectoryEvent['parentDirectoryId'] = dirObj.parentDirectoryId;

        //add the new event
        this.addEvent(createDirectoryEvent);
    }
    
    /*
     * Creates a 'DELETE DIRECTORY' event.
     */
    insertDeleteDirectoryEvent(dirObj, timestamp, createdByDevGroupId, branchId) {
        //create an event id
        const eventId = this.generateId();
        
        //create core event
        const deleteDirectoryEvent = this.fillCoreEvent(eventId,EventManager.nextId, timestamp, createdByDevGroupId, branchId);
        
        //add specific properties
        deleteDirectoryEvent['type'] = 'DELETE DIRECTORY';
        deleteDirectoryEvent['directoryId'] = dirObj.id;
        deleteDirectoryEvent['directoryPath'] = dirObj.currentPath
        deleteDirectoryEvent['parentDirectoryId'] = dirObj.parentDirectoryId;

        //add the new event
        this.addEvent(deleteDirectoryEvent);
    }
    
    /*
     * Creates a 'MOVE DIRECTORY' event.
     */
    insertMoveDirectoryEvent(timestamp, createdByDevGroupId, branchId, dirId, newParentDirectoryId, oldParentDirectoryId, newDirectoryPath, oldDirectoryPath) {
        //create an event id
        const eventId = this.generateId();
        
        //create core event
        const moveDirectoryEvent = this.fillCoreEvent(eventId,EventManager.nextId, timestamp, createdByDevGroupId, branchId);
        
        //add specific properties
        moveDirectoryEvent['type'] = 'MOVE DIRECTORY';
        moveDirectoryEvent['directoryId'] = dirId;
        moveDirectoryEvent['newParentDirectoryId'] = newParentDirectoryId;
        moveDirectoryEvent['oldParentDirectoryId'] = oldParentDirectoryId;
        moveDirectoryEvent['newDirectoryPath'] = newDirectoryPath;
        moveDirectoryEvent['oldDirectoryPath'] = oldDirectoryPath;

        //add the new event
        this.addEvent(moveDirectoryEvent);
    }
    
    /*
     * Creates a 'RENAME DIRECTORY' event.
     */
    insertRenameDirectoryEvent(timestamp, createdByDevGroupId, branchId, dirId, parentDirectoryId, newDirPath, oldDirPath) {
        //create an event id
        const eventId = this.generateId();
        
        //create core event
        const renameDirectoryEvent = this.fillCoreEvent(eventId,EventManager.nextId, timestamp, createdByDevGroupId, branchId);
        
        //add specific properties
        renameDirectoryEvent['type'] = 'RENAME DIRECTORY';
        renameDirectoryEvent['directoryId'] = dirId;
        renameDirectoryEvent['parentDirectoryId'] = parentDirectoryId;
        renameDirectoryEvent['newDirectoryPath'] = newDirPath;
        renameDirectoryEvent['oldDirectoryPath'] = oldDirPath;

        //add the new event
        this.addEvent(renameDirectoryEvent);
    }

    /*
     * Creates one or more 'INSERT' events.
     */
    insertTextEvents(file, timestamp, createdByDevGroupId, branchId, insertedText, row, col, pastedInsertEventIds, isRelevant=true) {
        try {
            //holds a collection of inserts
            const bulkInserts = [];

            //go through each new character being inserted
            for(let i = 0;i < insertedText.length;i++) {
                //the next character to insert
                let newText = insertedText[i];
                //if the character is a windows carriage return (CR)
                if(insertedText[i] === '\r') {
                    //look at the character next to it to see if it is a newline (LF) 
                    const nextPos = i + 1;
                    if(nextPos < insertedText.length && insertedText[nextPos] === '\n') {
                        //store both as the new text to insert
                        newText = '\r\n';
                        //handling two characters as one, \r followed by \n, 
                        //so move i forward to the the newline's position
                        i++;
                    }
                }
                //create an event id and store it in the object
                const eventId = this.generateId();
                
                //create core event
                const insertTextEvent = this.fillCoreEvent(eventId,EventManager.nextId, timestamp, createdByDevGroupId, branchId, isRelevant);

                //holds the id of the pasted event (if this is a paste)
                let pastedEventId = null;
                //if this character is pasted then store the event id of the original insert event
                if(pastedInsertEventIds.length === insertedText.length) {
                    pastedEventId = pastedInsertEventIds[i];
                }
                
                //get the previous neighbor
                const previousNeighborId = file.getPreviousNeighborId(row, col);
                
                //add specific properties
                insertTextEvent['type'] = 'INSERT';
                insertTextEvent['fileId'] = file.id;
                insertTextEvent['character'] = utilities.escapeSpecialCharacter(newText);
                insertTextEvent['previousNeighborId'] = previousNeighborId === 'none' ? null : previousNeighborId;
                insertTextEvent['lineNumber'] = row + 1;
                insertTextEvent['column'] = col + 1;
                insertTextEvent['pastedEventId'] = pastedEventId;

                //add the event to the array
                bulkInserts.push(insertTextEvent);

                //insert the character in the text file state
                file.addInsertEventByPos(eventId, newText, row, col);

                //if this code character was a newline
                if(newText === '\n' || newText === '\r\n') {
                    //go to the next row
                    row++;

                    //set the column back to the beginning of the line
                    col = 0;
                } else { //a non-newline character
                    //move to the next column
                    col++;
                }
            }

            //add all the events to the collection in memory
            this.addEvents(bulkInserts);
        } catch(ex) {
            console.log(`Error on insertTextEvents`);
            console.log(`file: ${file}, timestamp: ${timestamp}, createdByDevGroupId: ${createdByDevGroupId}, branchId: ${branchId}, insertedText: ${insertedText}, row: ${row}, col: ${col}, pastedInsertEventIds: ${pastedInsertEventIds}`);
        }
    }
    
    /*
     * Creates one or more 'DELETE' events
     */
    insertDeleteEvents(file, timestamp, createdByDevGroupId, branchId, row, col, numElementsToDelete) {
        //holds a collection of deletes
        const bulkDeletes = [];

        //go through each new character being deleted
        for(let i = 0;i < numElementsToDelete;i++) {
            //create an event id and store it in the object
            const eventId = this.generateId();
            
            //create core event
            const deleteTextEvent = this.fillCoreEvent(eventId,EventManager.nextId, timestamp, createdByDevGroupId, branchId);

            //get the insert event that is being deleted
            const insertEventBeingDeleted = file.getEvent(row, col);
            
            //if a windows newline is being removed
            if(insertEventBeingDeleted.character === '\r\n') {
                //the editor will have an extra character (it counts \r and \n 
                //as two separate characters whereas we store it in a single event)
                //remove the extra character
                numElementsToDelete--;
            }

            //add specific properties
            deleteTextEvent['type'] = 'DELETE';
            deleteTextEvent['fileId'] = file.id;
            deleteTextEvent['character'] = utilities.escapeSpecialCharacter(insertEventBeingDeleted.character);
            deleteTextEvent['previousNeighborId'] = insertEventBeingDeleted.id;
            deleteTextEvent['lineNumber'] = row + 1;
            deleteTextEvent['column'] = col + 1;
            
            //add the event to the array
            bulkDeletes.push(deleteTextEvent);
            
            //remove the event in the text file state
            file.removeInsertEventByPos(row, col);
        }
        //add all the events to the collection in memory
        this.addEvents(bulkDeletes);
    }
    
    /*
     * Adds some data (delete timestamp and event id of the delete) to every 
     * insert event that was deleted.
     */
    updateInsertEventsThatWereDeleted(allEvents) {
        //holds all of the delete events
        const allDeleteEvents = {};

        //go through all of the events in reverse to pick up delete events before 
        //the insert events that they delete
        for(let i = allEvents.length - 1;i >= 0;i--) {
            const currentEvent = allEvents[i];

            //if this is a delete event
            if(currentEvent.type === 'DELETE') {
                //store the delete event in an object keyed by the id of the 
                //insert event being deleted (previousNeighborId)
                allDeleteEvents[currentEvent.previousNeighborId] = currentEvent;
            } else if(currentEvent.type === 'INSERT') { //insert event
                //if the current insert event has been deleted
                if(allDeleteEvents[currentEvent.id]) {
                    //get the delete event
                    const deleteEvent = allDeleteEvents[currentEvent.id];
                    
                    //add two new properties to the insert event
                    currentEvent['deletedByEventId'] = deleteEvent.id;
                    currentEvent['deletedAtTimestamp'] = deleteEvent.timestamp;

                    //remove the delete event from the object
                    delete allDeleteEvents[currentEvent.id];
                }
            } //else- not an insert or a delete so ignore
        }
    }
}
//used to autogenerate ids
EventManager.nextId = 0;

module.exports = EventManager;